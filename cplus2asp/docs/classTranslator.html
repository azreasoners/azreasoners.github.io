<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>cplus2asp: Translator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cplus2asp
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">An action-language to ASP compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classTranslator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classTranslator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Translator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that provides data storage and translation capabilities.  
 <a href="classTranslator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="old_2Translator_8h_source.html">Translator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d95c49c85f8825e1c6c2a0c65ab1c4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a9d95c49c85f8825e1c6c2a0c65ab1c4b">Translator</a> (Language in=LANG_CPLUS)</td></tr>
<tr class="memdesc:a9d95c49c85f8825e1c6c2a0c65ab1c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a9d95c49c85f8825e1c6c2a0c65ab1c4b">More...</a><br/></td></tr>
<tr class="separator:a9d95c49c85f8825e1c6c2a0c65ab1c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23c8af9b2cc9ecd17bb6e9ccb9401ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ae23c8af9b2cc9ecd17bb6e9ccb9401ad">hasFoundAbnormalities</a> () const </td></tr>
<tr class="memdesc:ae23c8af9b2cc9ecd17bb6e9ccb9401ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the translator has encountered any abnormality constants.  <a href="#ae23c8af9b2cc9ecd17bb6e9ccb9401ad">More...</a><br/></td></tr>
<tr class="separator:ae23c8af9b2cc9ecd17bb6e9ccb9401ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435e80a2c5794cf19c4627b1dd354eb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a435e80a2c5794cf19c4627b1dd354eb9">hasFoundAdditiveConstants</a> () const </td></tr>
<tr class="memdesc:a435e80a2c5794cf19c4627b1dd354eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the translator has encountered any additive constants.  <a href="#a435e80a2c5794cf19c4627b1dd354eb9">More...</a><br/></td></tr>
<tr class="separator:a435e80a2c5794cf19c4627b1dd354eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a671f7816dae79de670e35df5215432cc"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a671f7816dae79de670e35df5215432cc">sanitizeConstantName</a> (std::string const &amp;originalName)</td></tr>
<tr class="memdesc:a671f7816dae79de670e35df5215432cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a C+ constant name to be compatible with ASP naming/syntax conventions.  <a href="#a671f7816dae79de670e35df5215432cc">More...</a><br/></td></tr>
<tr class="separator:a671f7816dae79de670e35df5215432cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd39be74d4be1c81072986b6d79ffe2"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a3cd39be74d4be1c81072986b6d79ffe2">sanitizeObjectName</a> (std::string const &amp;originalName)</td></tr>
<tr class="memdesc:a3cd39be74d4be1c81072986b6d79ffe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a C+ object name to be compatible with ASP naming/syntax conventions.  <a href="#a3cd39be74d4be1c81072986b6d79ffe2">More...</a><br/></td></tr>
<tr class="separator:a3cd39be74d4be1c81072986b6d79ffe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a9991e4f136e62021d89c3ef314eae"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#af8a9991e4f136e62021d89c3ef314eae">sanitizeSortName</a> (std::string const &amp;originalName)</td></tr>
<tr class="memdesc:af8a9991e4f136e62021d89c3ef314eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a C+ sort name to be compatible with ASP naming/syntax conventions.  <a href="#af8a9991e4f136e62021d89c3ef314eae">More...</a><br/></td></tr>
<tr class="separator:af8a9991e4f136e62021d89c3ef314eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0b011e7bc390c45d99ff4f1df12ab1"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a7b0b011e7bc390c45d99ff4f1df12ab1">sanitizeVariableName</a> (std::string const &amp;originalName)</td></tr>
<tr class="memdesc:a7b0b011e7bc390c45d99ff4f1df12ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a C+ variable name to be compatible with ASP naming/syntax conventions.  <a href="#a7b0b011e7bc390c45d99ff4f1df12ab1">More...</a><br/></td></tr>
<tr class="separator:a7b0b011e7bc390c45d99ff4f1df12ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b7912d06f7d0e6378ccd8cc586e80d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a95b7912d06f7d0e6378ccd8cc586e80d">sanitizeString</a> (std::string const &amp;originalString)</td></tr>
<tr class="memdesc:a95b7912d06f7d0e6378ccd8cc586e80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms an arbitrary string such that the result will be compatible with ASP object/predicate naming and syntax conventions.  <a href="#a95b7912d06f7d0e6378ccd8cc586e80d">More...</a><br/></td></tr>
<tr class="separator:a95b7912d06f7d0e6378ccd8cc586e80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf2e102b780108a6d66f795f6774007"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a3cf2e102b780108a6d66f795f6774007">translateVariableDeclToString</a> (Variable const *transVar)</td></tr>
<tr class="memdesc:a3cf2e102b780108a6d66f795f6774007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of translateVariableDecl that returns the result as a string instead of sending the result to an output stream.  <a href="#a3cf2e102b780108a6d66f795f6774007">More...</a><br/></td></tr>
<tr class="separator:a3cf2e102b780108a6d66f795f6774007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88da67abf1048c89bf7b18599a6c2ae1"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a88da67abf1048c89bf7b18599a6c2ae1">numRangeToSortName</a> (std::string const &amp;min, std::string const &amp;max)</td></tr>
<tr class="memdesc:a88da67abf1048c89bf7b18599a6c2ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a standardized sort name representing a range of numbers.  <a href="#a88da67abf1048c89bf7b18599a6c2ae1">More...</a><br/></td></tr>
<tr class="separator:a88da67abf1048c89bf7b18599a6c2ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d43f47ea2676625f9acc6210b73972"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#aa5d43f47ea2676625f9acc6210b73972">sortNameToVariable</a> (std::string const &amp;sortName, bool sanitizeFirst=false)</td></tr>
<tr class="memdesc:aa5d43f47ea2676625f9acc6210b73972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a sort name into an acceptable variable name containing as much of the original sort name as possible.  <a href="#aa5d43f47ea2676625f9acc6210b73972">More...</a><br/></td></tr>
<tr class="separator:aa5d43f47ea2676625f9acc6210b73972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab915f8be91fb2110489b250a1427be0c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ab915f8be91fb2110489b250a1427be0c">mergeSubFormulas</a> (<a class="el" href="classParseElement.html">ParseElement</a> *first, <a class="el" href="classParseElement.html">ParseElement</a> *second)</td></tr>
<tr class="memdesc:ab915f8be91fb2110489b250a1427be0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sub-formulas together into one formula using an AND operation.  <a href="#ab915f8be91fb2110489b250a1427be0c">More...</a><br/></td></tr>
<tr class="separator:ab915f8be91fb2110489b250a1427be0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a237353d1182e41e51c3c3c99b66f2e63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a237353d1182e41e51c3c3c99b66f2e63">translatorNumErrors</a></td></tr>
<tr class="memdesc:a237353d1182e41e51c3c3c99b66f2e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks how many errors the translator module encounters while translating things.  <a href="#a237353d1182e41e51c3c3c99b66f2e63">More...</a><br/></td></tr>
<tr class="separator:a237353d1182e41e51c3c3c99b66f2e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dc79c758ae00960cdcf22ae8eebcf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ab9dc79c758ae00960cdcf22ae8eebcf2">translatorNumWarnings</a></td></tr>
<tr class="memdesc:ab9dc79c758ae00960cdcf22ae8eebcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks how many warnings the translator module encounters during operation.  <a href="#ab9dc79c758ae00960cdcf22ae8eebcf2">More...</a><br/></td></tr>
<tr class="separator:ab9dc79c758ae00960cdcf22ae8eebcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75abc327fac9fd6890fe20b76a0331b"><td class="memItemLeft" align="right" valign="top">Query *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">tempQuery</a></td></tr>
<tr class="memdesc:aa75abc327fac9fd6890fe20b76a0331b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helps the parser process and prepare queries for translation.  <a href="#aa75abc327fac9fd6890fe20b76a0331b">More...</a><br/></td></tr>
<tr class="separator:aa75abc327fac9fd6890fe20b76a0331b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
/\arity (or NULL).</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc800fd55e83e8d4adf412c4816f5ed84"></a>Finds the element associated with the </p>
</td></tr>
<tr class="memitem:abd86b749727e0b5f5d5f8a6fac9bb7e7"><td class="memItemLeft" align="right" valign="top">Element *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#abd86b749727e0b5f5d5f8a6fac9bb7e7">getSymbol</a> (std::string const &amp;name, size_t arity=0)</td></tr>
<tr class="separator:abd86b749727e0b5f5d5f8a6fac9bb7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae973090fa0d53bbf36bef3ccf6f50439"><td class="memItemLeft" align="right" valign="top">Constant *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ae973090fa0d53bbf36bef3ccf6f50439">getConstant</a> (std::string const &amp;name, size_t arity=0)</td></tr>
<tr class="memdesc:ae973090fa0d53bbf36bef3ccf6f50439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a constant identifier associated with the name/arity (or NULL);.  <a href="#ae973090fa0d53bbf36bef3ccf6f50439">More...</a><br/></td></tr>
<tr class="separator:ae973090fa0d53bbf36bef3ccf6f50439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2840215dfa751426551708eca2141f5"><td class="memItemLeft" align="right" valign="top">Object *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ad2840215dfa751426551708eca2141f5">getObject</a> (std::string const &amp;name, size_t arity=0)</td></tr>
<tr class="memdesc:ad2840215dfa751426551708eca2141f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a object identifier associated with the name/arity (or NULL);.  <a href="#ad2840215dfa751426551708eca2141f5">More...</a><br/></td></tr>
<tr class="separator:ad2840215dfa751426551708eca2141f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a229b868ba6ee176754ec2e342b6bd"><td class="memItemLeft" align="right" valign="top">Sort *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#af8a229b868ba6ee176754ec2e342b6bd">getSort</a> (std::string const &amp;name)</td></tr>
<tr class="memdesc:af8a229b868ba6ee176754ec2e342b6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a sort identifier associated with the name/arity (or NULL);.  <a href="#af8a229b868ba6ee176754ec2e342b6bd">More...</a><br/></td></tr>
<tr class="separator:af8a229b868ba6ee176754ec2e342b6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6f7aec671147c3ce4f2cd1e05ddcb6"><td class="memItemLeft" align="right" valign="top">Variable *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#add6f7aec671147c3ce4f2cd1e05ddcb6">getVariable</a> (std::string const &amp;name)</td></tr>
<tr class="memdesc:add6f7aec671147c3ce4f2cd1e05ddcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a variable identifier associated with the name/arity (or NULL);.  <a href="#add6f7aec671147c3ce4f2cd1e05ddcb6">More...</a><br/></td></tr>
<tr class="separator:add6f7aec671147c3ce4f2cd1e05ddcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f07647fcf8849ed861f4d3cdd0e20cc"><td class="memItemLeft" align="right" valign="top">Query *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a2f07647fcf8849ed861f4d3cdd0e20cc">getQuery</a> (std::string const &amp;testLabel)</td></tr>
<tr class="memdesc:a2f07647fcf8849ed861f4d3cdd0e20cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a stored query with the given label in the translator's data structures.  <a href="#a2f07647fcf8849ed861f4d3cdd0e20cc">More...</a><br/></td></tr>
<tr class="separator:a2f07647fcf8849ed861f4d3cdd0e20cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab255d800190701bc36af2f4b7582c1d0"><td class="memItemLeft" align="right" valign="top">Object *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">getOrCreateObject</a> (std::string const &amp;symName, Object::ObjectType type=Object::OBJ_NAME, bool internal=false, size_t arity=0)</td></tr>
<tr class="memdesc:ab255d800190701bc36af2f4b7582c1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for getting an Object type reference or dynamically adding it if it doesn't occur.  <a href="#ab255d800190701bc36af2f4b7582c1d0">More...</a><br/></td></tr>
<tr class="separator:ab255d800190701bc36af2f4b7582c1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915d7f328ae4d090a55309522275886c"><td class="memItemLeft" align="right" valign="top">SymbolTable::SymTblResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a915d7f328ae4d090a55309522275886c">addSymbol</a> (Element *elem)</td></tr>
<tr class="memdesc:a915d7f328ae4d090a55309522275886c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to add a new symbol to the translator's data structures.  <a href="#a915d7f328ae4d090a55309522275886c">More...</a><br/></td></tr>
<tr class="separator:a915d7f328ae4d090a55309522275886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81fe4e23f74e16c264e2ede86469715"><td class="memItemLeft" align="right" valign="top">Sort *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ab81fe4e23f74e16c264e2ede86469715">addSort</a> (std::string const &amp;sortName, bool internal, <a class="el" href="bcplusparser_2src_2bcplus_2parser_2detail_2lemon__parser_8cpp.html#a1e748d96d374dd429d856e584e62878d">SortList</a> *subsorts=NULL, bool translateDeclaration=true, bool warnOnDup=false)</td></tr>
<tr class="memdesc:ab81fe4e23f74e16c264e2ede86469715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to create and add a sort object to the translator.  <a href="#ab81fe4e23f74e16c264e2ede86469715">More...</a><br/></td></tr>
<tr class="separator:ab81fe4e23f74e16c264e2ede86469715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a707e494f50c66fdfaed21bb8c95d63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a4a707e494f50c66fdfaed21bb8c95d63">addQuery</a> (Query *newQuery)</td></tr>
<tr class="memdesc:a4a707e494f50c66fdfaed21bb8c95d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to add a new Query object to the translator's data structures.  <a href="#a4a707e494f50c66fdfaed21bb8c95d63">More...</a><br/></td></tr>
<tr class="separator:a4a707e494f50c66fdfaed21bb8c95d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81edcdd33f60dca0b494ffdf3a856b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ae81edcdd33f60dca0b494ffdf3a856b0">translateConstantDecl</a> (Constant const *transConst)</td></tr>
<tr class="memdesc:ae81edcdd33f60dca0b494ffdf3a856b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a Constant element into an ASP-compatible constant declaration.  <a href="#ae81edcdd33f60dca0b494ffdf3a856b0">More...</a><br/></td></tr>
<tr class="separator:ae81edcdd33f60dca0b494ffdf3a856b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05427462bb0825e125b6d4f3054cf78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#aa05427462bb0825e125b6d4f3054cf78">translateObjectDecl</a> (Object const *transObj, Sort const *sortObj)</td></tr>
<tr class="memdesc:aa05427462bb0825e125b6d4f3054cf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates an Object element into an ASP-compatible declaration of an object as a member of a sort's domain.  <a href="#aa05427462bb0825e125b6d4f3054cf78">More...</a><br/></td></tr>
<tr class="separator:aa05427462bb0825e125b6d4f3054cf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0211f521a042860033e17aa451da1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a5b0211f521a042860033e17aa451da1e">handleLUACall</a> (<a class="el" href="classObjectLikeElement.html">ObjectLikeElement</a> const *lua_elem)</td></tr>
<tr class="memdesc:a5b0211f521a042860033e17aa451da1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a LUA call by adding the result to the computed sort.  <a href="#a5b0211f521a042860033e17aa451da1e">More...</a><br/></td></tr>
<tr class="separator:a5b0211f521a042860033e17aa451da1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac261db6a4a61d4b0e9c86874199bbe9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ac261db6a4a61d4b0e9c86874199bbe9e">translateSortDecl</a> (Sort const *transSort)</td></tr>
<tr class="memdesc:ac261db6a4a61d4b0e9c86874199bbe9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a Sort element into an ASP-compatible sort declaration.  <a href="#ac261db6a4a61d4b0e9c86874199bbe9e">More...</a><br/></td></tr>
<tr class="separator:ac261db6a4a61d4b0e9c86874199bbe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cf4f330597ed14aa67a18fdf4df9b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a99cf4f330597ed14aa67a18fdf4df9b1">translateSubsortDecl</a> (Sort const *transSupersort, Sort const *transSubsort)</td></tr>
<tr class="memdesc:a99cf4f330597ed14aa67a18fdf4df9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a declaration of a super/sub-sort relationship into ASP-compatible syntax.  <a href="#a99cf4f330597ed14aa67a18fdf4df9b1">More...</a><br/></td></tr>
<tr class="separator:a99cf4f330597ed14aa67a18fdf4df9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9040939e5a6702b9713daa1381da635e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a9040939e5a6702b9713daa1381da635e">translateVariableDecl</a> (Variable const *transVar)</td></tr>
<tr class="memdesc:a9040939e5a6702b9713daa1381da635e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a Variable element into an ASP-compatible variable declaration.  <a href="#a9040939e5a6702b9713daa1381da635e">More...</a><br/></td></tr>
<tr class="separator:a9040939e5a6702b9713daa1381da635e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9405371b013e5879931fdb3cf985de5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ae9405371b013e5879931fdb3cf985de5">translateQuery</a> (Query const *transQuery)</td></tr>
<tr class="memdesc:ae9405371b013e5879931fdb3cf985de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a Query into an ASP-compatible query declaration.  <a href="#ae9405371b013e5879931fdb3cf985de5">More...</a><br/></td></tr>
<tr class="separator:ae9405371b013e5879931fdb3cf985de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2745b2441a5759d77e02524ec9dad4ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a> (<a class="el" href="classParseElement.html">ParseElement</a> *head, <a class="el" href="classParseElement.html">ParseElement</a> *ifBody, <a class="el" href="classParseElement.html">ParseElement</a> *assumingBody, <a class="el" href="classParseElement.html">ParseElement</a> *afterBody, <a class="el" href="classParseElement.html">ParseElement</a> *unlessBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody)</td></tr>
<tr class="memdesc:a2745b2441a5759d77e02524ec9dad4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a causal law into ASP-compatible <a class="el" href="structrule.html">rule(s)</a>.  <a href="#a2745b2441a5759d77e02524ec9dad4ff">More...</a><br/></td></tr>
<tr class="separator:a2745b2441a5759d77e02524ec9dad4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fab087654bbbb9669118336b9ce489"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a75fab087654bbbb9669118336b9ce489">translateCausalLaw</a> (<a class="el" href="classParseElement.html">ParseElement</a> *head, <a class="el" href="classParseElement.html">ParseElement</a> *ifBody, <a class="el" href="classParseElement.html">ParseElement</a> *assumingBody, <a class="el" href="classParseElement.html">ParseElement</a> *afterBody, <a class="el" href="classParseElement.html">ParseElement</a> *whenBody, <a class="el" href="classParseElement.html">ParseElement</a> *followingBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody)</td></tr>
<tr class="memdesc:a75fab087654bbbb9669118336b9ce489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper wrapper to translateCausalLaw w/o an unlessBody.  <a href="#a75fab087654bbbb9669118336b9ce489">More...</a><br/></td></tr>
<tr class="separator:a75fab087654bbbb9669118336b9ce489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2c314812bca3c1c52f62f3dca0e4b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#aec2c314812bca3c1c52f62f3dca0e4b4">translateShowStmt</a> (ParseElementList const &amp;atomicFormulas)</td></tr>
<tr class="memdesc:aec2c314812bca3c1c52f62f3dca0e4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a ':- show' statement, adding the appropriate #show statements to the program.  <a href="#aec2c314812bca3c1c52f62f3dca0e4b4">More...</a><br/></td></tr>
<tr class="separator:aec2c314812bca3c1c52f62f3dca0e4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b01f7354c40ab8005ee08e87a791579"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a5b01f7354c40ab8005ee08e87a791579">translateDeclarativeLaw</a> (<a class="el" href="classParseElement.html">ParseElement</a> *head, <a class="el" href="classParseElement.html">ParseElement</a> *ifBody, <a class="el" href="classParseElement.html">ParseElement</a> *assumingBody, <a class="el" href="classParseElement.html">ParseElement</a> *afterBody, <a class="el" href="classParseElement.html">ParseElement</a> *unlessBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody, <a class="el" href="classSimpleUnaryOperator.html#ac0a7153989edd90defb764943758827a">SimpleUnaryOperator::UnaryOperatorType</a> opType)</td></tr>
<tr class="memdesc:a5b01f7354c40ab8005ee08e87a791579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms declarative laws ("inertial p", "exogenous a(X)", "rigid q", etc.) to basic form and calls the translator for them.  <a href="#a5b01f7354c40ab8005ee08e87a791579">More...</a><br/></td></tr>
<tr class="separator:a5b01f7354c40ab8005ee08e87a791579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30fbecad9b16306e8a328b5aaa3af80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ac30fbecad9b16306e8a328b5aaa3af80">translateAlwaysLaw</a> (<a class="el" href="classParseElement.html">ParseElement</a> *constraint, <a class="el" href="classParseElement.html">ParseElement</a> *unlessBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody)</td></tr>
<tr class="memdesc:ac30fbecad9b16306e8a328b5aaa3af80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a causal law of the form "always F [where G]." to basic form, then calls the translator for it.  <a href="#ac30fbecad9b16306e8a328b5aaa3af80">More...</a><br/></td></tr>
<tr class="separator:ac30fbecad9b16306e8a328b5aaa3af80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb752725c3e0a5fe04c3b43791f6181e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#adb752725c3e0a5fe04c3b43791f6181e">translateConstraintLaw</a> (<a class="el" href="classParseElement.html">ParseElement</a> *constraint, <a class="el" href="classParseElement.html">ParseElement</a> *afterBody, <a class="el" href="classParseElement.html">ParseElement</a> *unlessBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody, bool positive)</td></tr>
<tr class="memdesc:adb752725c3e0a5fe04c3b43791f6181e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a causal law of the form "constraint F [after H] [where J]." to basic form, then calls the translator for it.  <a href="#adb752725c3e0a5fe04c3b43791f6181e">More...</a><br/></td></tr>
<tr class="separator:adb752725c3e0a5fe04c3b43791f6181e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac188d9ed1e5882268f3eb29f21e2c6d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ac188d9ed1e5882268f3eb29f21e2c6d5">translateDefaultLaw</a> (<a class="el" href="classParseElement.html">ParseElement</a> *head, <a class="el" href="classParseElement.html">ParseElement</a> *ifBody, <a class="el" href="classParseElement.html">ParseElement</a> *assumingBody, <a class="el" href="classParseElement.html">ParseElement</a> *afterBody, <a class="el" href="classParseElement.html">ParseElement</a> *unlessBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody)</td></tr>
<tr class="memdesc:ac188d9ed1e5882268f3eb29f21e2c6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a causal law of the form "default F [if G] [after H] [where J]." to basic form, then calls the translator on it.  <a href="#ac188d9ed1e5882268f3eb29f21e2c6d5">More...</a><br/></td></tr>
<tr class="separator:ac188d9ed1e5882268f3eb29f21e2c6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26257de0623490f5d6fcc19dbcdffd28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a26257de0623490f5d6fcc19dbcdffd28">translateNonexecutableLaw</a> (<a class="el" href="classParseElement.html">ParseElement</a> *nonEx, <a class="el" href="classParseElement.html">ParseElement</a> *ifBody, <a class="el" href="classParseElement.html">ParseElement</a> *unlessBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody)</td></tr>
<tr class="memdesc:a26257de0623490f5d6fcc19dbcdffd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a causal law of the form "nonexecutable F [if G] [where H]." to basic form, then calls the translator for it.  <a href="#a26257de0623490f5d6fcc19dbcdffd28">More...</a><br/></td></tr>
<tr class="separator:a26257de0623490f5d6fcc19dbcdffd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c76f48f345c4258fe01a6a746e82ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a01c76f48f345c4258fe01a6a746e82ff">translatePossiblyCausedLaw</a> (<a class="el" href="classParseElement.html">ParseElement</a> *head, <a class="el" href="classParseElement.html">ParseElement</a> *ifBody, <a class="el" href="classParseElement.html">ParseElement</a> *assumingBody, <a class="el" href="classParseElement.html">ParseElement</a> *afterBody, <a class="el" href="classParseElement.html">ParseElement</a> *unlessBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody)</td></tr>
<tr class="memdesc:a01c76f48f345c4258fe01a6a746e82ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a causal law of the form "possibly caused F [if G] [after H] [where J]." to basic form, then calls the translator on it.  <a href="#a01c76f48f345c4258fe01a6a746e82ff">More...</a><br/></td></tr>
<tr class="separator:a01c76f48f345c4258fe01a6a746e82ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2676b6b181db69a8d1e3596e81ae25d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a2676b6b181db69a8d1e3596e81ae25d7">translateMayCauseLaw</a> (<a class="el" href="classParseElement.html">ParseElement</a> *causer, <a class="el" href="classParseElement.html">ParseElement</a> *causee, <a class="el" href="classParseElement.html">ParseElement</a> *ifBody, <a class="el" href="classParseElement.html">ParseElement</a> *assumingBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody)</td></tr>
<tr class="memdesc:a2676b6b181db69a8d1e3596e81ae25d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a causal law of the form "G may cause F [if H] [where J]." to basic form, then calls the translator on it.  <a href="#a2676b6b181db69a8d1e3596e81ae25d7">More...</a><br/></td></tr>
<tr class="separator:a2676b6b181db69a8d1e3596e81ae25d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b5b97e12ba10557cc4a10764616f44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ac8b5b97e12ba10557cc4a10764616f44">translateCausesLaw</a> (<a class="el" href="classParseElement.html">ParseElement</a> *causer, <a class="el" href="classParseElement.html">ParseElement</a> *causee, <a class="el" href="classParseElement.html">ParseElement</a> *ifBody, <a class="el" href="classParseElement.html">ParseElement</a> *assumingBody, <a class="el" href="classParseElement.html">ParseElement</a> *unlessBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody)</td></tr>
<tr class="memdesc:ac8b5b97e12ba10557cc4a10764616f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a causal law of the form "G causes F [if H] [where J]." to basic form, then calls the translator on it.  <a href="#ac8b5b97e12ba10557cc4a10764616f44">More...</a><br/></td></tr>
<tr class="separator:ac8b5b97e12ba10557cc4a10764616f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d4577d2e194a8ad15cdf11103ff278"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#aa6d4577d2e194a8ad15cdf11103ff278">translateIncrementLaw</a> (<a class="el" href="classParseElement.html">ParseElement</a> *causer, <a class="el" href="classParseElement.html">ParseElement</a> *causee, <a class="el" href="classParseElement.html">ParseElement</a> *increment, <a class="el" href="classParseElement.html">ParseElement</a> *ifBody, <a class="el" href="classParseElement.html">ParseElement</a> *assumingBody, <a class="el" href="classParseElement.html">ParseElement</a> *unlessBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody, bool isIncrement)</td></tr>
<tr class="memdesc:aa6d4577d2e194a8ad15cdf11103ff278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a causal law of the form "A increments B by N [if H] [where J]." to basic form, then calls the translator on it.  <a href="#aa6d4577d2e194a8ad15cdf11103ff278">More...</a><br/></td></tr>
<tr class="separator:aa6d4577d2e194a8ad15cdf11103ff278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bd93433890d0eb1c9d2fc0090a03bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#aa6bd93433890d0eb1c9d2fc0090a03bb">outputFooter</a> ()</td></tr>
<tr class="memdesc:aa6bd93433890d0eb1c9d2fc0090a03bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends any statements that have been witheld for the footer to the translated program.  <a href="#aa6bd93433890d0eb1c9d2fc0090a03bb">More...</a><br/></td></tr>
<tr class="separator:aa6bd93433890d0eb1c9d2fc0090a03bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939688f2e8d7f2a5ce94dc0e3b9ddc89"><td class="memItemLeft" align="right" valign="top">Sort *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a> (std::string const &amp;newSortName, <a class="el" href="bcplusparser_2src_2bcplus_2parser_2detail_2lemon__parser_8cpp.html#a1e748d96d374dd429d856e584e62878d">SortList</a> *subsorts=NULL)</td></tr>
<tr class="memdesc:a939688f2e8d7f2a5ce94dc0e3b9ddc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and adds a sort with the given name to the translator's internal data structures without translating or outputting it.  <a href="#a939688f2e8d7f2a5ce94dc0e3b9ddc89">More...</a><br/></td></tr>
<tr class="separator:a939688f2e8d7f2a5ce94dc0e3b9ddc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85a78110d57dcf071372dea802b36dd"><td class="memItemLeft" align="right" valign="top">Object *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ac85a78110d57dcf071372dea802b36dd">createInternalObject</a> (std::string const &amp;newObjName, <a class="el" href="bcplusparser_2src_2bcplus_2parser_2detail_2lemon__parser_8cpp.html#a1e748d96d374dd429d856e584e62878d">SortList</a> *params, Sort *ofSort)</td></tr>
<tr class="memdesc:ac85a78110d57dcf071372dea802b36dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and adds an object with the given name to the translator's internal data structures, connecting it as a member of the given sort's domain.  <a href="#ac85a78110d57dcf071372dea802b36dd">More...</a><br/></td></tr>
<tr class="separator:ac85a78110d57dcf071372dea802b36dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69aeab6a3d337188a8f8dd44be7bee4"><td class="memItemLeft" align="right" valign="top">NumberRange *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ab69aeab6a3d337188a8f8dd44be7bee4">createInternalNumRange</a> (std::string const &amp;newObjName, Sort *ofSort)</td></tr>
<tr class="memdesc:ab69aeab6a3d337188a8f8dd44be7bee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and adds a number range with the given name and bounds to the translator's internal data structures, connecting it as a member of the given sort's domain.  <a href="#ab69aeab6a3d337188a8f8dd44be7bee4">More...</a><br/></td></tr>
<tr class="separator:ab69aeab6a3d337188a8f8dd44be7bee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cde58cce92f4108d00c68319c78965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ad9cde58cce92f4108d00c68319c78965">allocateNewTempQuery</a> (bool deallocateFirst=false)</td></tr>
<tr class="memdesc:ad9cde58cce92f4108d00c68319c78965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new Query instance and assigns it to tempQuery.  <a href="#ad9cde58cce92f4108d00c68319c78965">More...</a><br/></td></tr>
<tr class="separator:ad9cde58cce92f4108d00c68319c78965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359ae1adacf0d1514fe5db102d45c3e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a359ae1adacf0d1514fe5db102d45c3e5">setOutput</a> (std::ostream &amp;newOst)</td></tr>
<tr class="memdesc:a359ae1adacf0d1514fe5db102d45c3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a translator instance's output stream to the passed stream.  <a href="#a359ae1adacf0d1514fe5db102d45c3e5">More...</a><br/></td></tr>
<tr class="separator:a359ae1adacf0d1514fe5db102d45c3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc813b8e7eb68cdeaf68cdd7f38d641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a4cc813b8e7eb68cdeaf68cdd7f38d641">setErrorOutput</a> (std::ostream &amp;newOst)</td></tr>
<tr class="memdesc:a4cc813b8e7eb68cdeaf68cdd7f38d641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a translator instance's error output stream to the passed stream.  <a href="#a4cc813b8e7eb68cdeaf68cdd7f38d641">More...</a><br/></td></tr>
<tr class="separator:a4cc813b8e7eb68cdeaf68cdd7f38d641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22e2028787ae2151f63cb82b6544c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ab22e2028787ae2151f63cb82b6544c40">setStaticTranslation</a> (bool staticTrans)</td></tr>
<tr class="memdesc:ab22e2028787ae2151f63cb82b6544c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the translator instance should output a static translation of the CCalc source file instead of an incremental/dynamic translation.  <a href="#ab22e2028787ae2151f63cb82b6544c40">More...</a><br/></td></tr>
<tr class="separator:ab22e2028787ae2151f63cb82b6544c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c14268a49b3551907e27ba347d13e93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a> (std::string const &amp;str, bool endWithNewline=false, bool location=true)</td></tr>
<tr class="memdesc:a7c14268a49b3551907e27ba347d13e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the contents of str to wherever the translator's error output stream is aimed.  <a href="#a7c14268a49b3551907e27ba347d13e93">More...</a><br/></td></tr>
<tr class="separator:a7c14268a49b3551907e27ba347d13e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07bcca529cd19ad8602fb4ec5ec16d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#aa07bcca529cd19ad8602fb4ec5ec16d9">warn</a> (std::string const &amp;str, bool endWithNewline=false, bool location=true)</td></tr>
<tr class="memdesc:aa07bcca529cd19ad8602fb4ec5ec16d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the contents of str to wherever the translator's error output stream is aimed.  <a href="#aa07bcca529cd19ad8602fb4ec5ec16d9">More...</a><br/></td></tr>
<tr class="separator:aa07bcca529cd19ad8602fb4ec5ec16d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394192f42210f4245faeac6acfd52758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a394192f42210f4245faeac6acfd52758">caution</a> (std::string const &amp;str, bool endWithNewline=false, bool location=true)</td></tr>
<tr class="memdesc:a394192f42210f4245faeac6acfd52758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the contents of str to wherever the translator's error output stream is aimed.  <a href="#a394192f42210f4245faeac6acfd52758">More...</a><br/></td></tr>
<tr class="separator:a394192f42210f4245faeac6acfd52758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7d2e5e3b8c5b67345485e2c5e9bb6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a3a7d2e5e3b8c5b67345485e2c5e9bb6e">pragma</a> (std::string const &amp;str, bool endWithNewline=false, bool location=true)</td></tr>
<tr class="memdesc:a3a7d2e5e3b8c5b67345485e2c5e9bb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the contents of str to wherever the translator's error output stream is aimed.  <a href="#a3a7d2e5e3b8c5b67345485e2c5e9bb6e">More...</a><br/></td></tr>
<tr class="separator:a3a7d2e5e3b8c5b67345485e2c5e9bb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c262ba866126a6a35e979a64d7e3518"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a9c262ba866126a6a35e979a64d7e3518">~Translator</a> ()</td></tr>
<tr class="memdesc:a9c262ba866126a6a35e979a64d7e3518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a9c262ba866126a6a35e979a64d7e3518">More...</a><br/></td></tr>
<tr class="separator:a9c262ba866126a6a35e979a64d7e3518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb634f19ffb6d601eae8ad032d72ce9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> (std::string const &amp;str, IPart incPart, bool endWithNewline=false)</td></tr>
<tr class="memdesc:acbb634f19ffb6d601eae8ad032d72ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the contents of str to wherever the translator's output stream is aimed.  <a href="#acbb634f19ffb6d601eae8ad032d72ce9">More...</a><br/></td></tr>
<tr class="separator:acbb634f19ffb6d601eae8ad032d72ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7447c0464738a176c4cc5f05397dfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a2c7447c0464738a176c4cc5f05397dfa">outputStmts</a> (StmtList const &amp;stmts)</td></tr>
<tr class="memdesc:a2c7447c0464738a176c4cc5f05397dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a list of statements to the translators output.  <a href="#a2c7447c0464738a176c4cc5f05397dfa">More...</a><br/></td></tr>
<tr class="separator:a2c7447c0464738a176c4cc5f05397dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3dafe51e51a6bc4bc63c7d35dc63f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#aed3dafe51e51a6bc4bc63c7d35dc63f3">addToFooter</a> (StmtList &amp;stmts)</td></tr>
<tr class="memdesc:aed3dafe51e51a6bc4bc63c7d35dc63f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the provided statement to the program's footer buffer, resulting them in being included in the footer in the future.  <a href="#aed3dafe51e51a6bc4bc63c7d35dc63f3">More...</a><br/></td></tr>
<tr class="separator:aed3dafe51e51a6bc4bc63c7d35dc63f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a621cce440c35279f1a4de95d0cad1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ad0a621cce440c35279f1a4de95d0cad1">outputSymbolTable</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ad0a621cce440c35279f1a4de95d0cad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instructs the translator to output its symbol table to the specified location.  <a href="#ad0a621cce440c35279f1a4de95d0cad1">More...</a><br/></td></tr>
<tr class="separator:ad0a621cce440c35279f1a4de95d0cad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864d4dc33098092fef562455dc97c9e2"><td class="memItemLeft" align="right" valign="top">Language&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a> () const </td></tr>
<tr class="memdesc:a864d4dc33098092fef562455dc97c9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the currently active language.  <a href="#a864d4dc33098092fef562455dc97c9e2">More...</a><br/></td></tr>
<tr class="separator:a864d4dc33098092fef562455dc97c9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2973b80adebf80f00ca209502465f8e5"><td class="memItemLeft" align="right" valign="top">static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">outputClauses</a> (std::ostream &amp;out, ClauseList const &amp;clauses, bool initConj=false)</td></tr>
<tr class="memdesc:a2973b80adebf80f00ca209502465f8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper method to output multiple clauses to an output stream.  <a href="#a2973b80adebf80f00ca209502465f8e5">More...</a><br/></td></tr>
<tr class="separator:a2973b80adebf80f00ca209502465f8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2965d026bb2cfb15f62b533beaa155"><td class="memItemLeft" align="right" valign="top">static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a0d2965d026bb2cfb15f62b533beaa155">bindAndTranslate</a> (std::ostream &amp;out, <a class="el" href="classParseElement.html">ParseElement</a> const *expr, Context &amp;context, bool upwardMobileClauses, bool suppressQuantifier=false)</td></tr>
<tr class="memdesc:a0d2965d026bb2cfb15f62b533beaa155"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper method to translate a sub expression, capturing all of its clauses and variables in the meanwhile.  <a href="#a0d2965d026bb2cfb15f62b533beaa155">More...</a><br/></td></tr>
<tr class="separator:a0d2965d026bb2cfb15f62b533beaa155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23889ec98e7b399eb1a79bb0e5878b24"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a23889ec98e7b399eb1a79bb0e5878b24">strToLanguage</a> (char const *str, Language &amp;outLang)</td></tr>
<tr class="memdesc:a23889ec98e7b399eb1a79bb0e5878b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the name of a language to its corresponding enum type.  <a href="#a23889ec98e7b399eb1a79bb0e5878b24">More...</a><br/></td></tr>
<tr class="separator:a23889ec98e7b399eb1a79bb0e5878b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e900621c5444895355f0c957f44618c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a4e900621c5444895355f0c957f44618c">setIncrementalPart</a> (IPart newIncPart)</td></tr>
<tr class="memdesc:a4e900621c5444895355f0c957f44618c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets incremental part to the provided part, outputting the appropriate clause to the translation output.  <a href="#a4e900621c5444895355f0c957f44618c">More...</a><br/></td></tr>
<tr class="separator:a4e900621c5444895355f0c957f44618c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3b8ac556462ee55d4a3d1b2bdadb61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#adf3b8ac556462ee55d4a3d1b2bdadb61">output</a> (std::string const &amp;str, bool endWithNewline=false)</td></tr>
<tr class="memdesc:adf3b8ac556462ee55d4a3d1b2bdadb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the contents of str to wherever the translator's output stream is aimed.  <a href="#adf3b8ac556462ee55d4a3d1b2bdadb61">More...</a><br/></td></tr>
<tr class="separator:adf3b8ac556462ee55d4a3d1b2bdadb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a88e8bc81269b07f6ce7a7b31aea94d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a8a88e8bc81269b07f6ce7a7b31aea94d">outputToErr</a> (std::string const &amp;hdr, std::string const &amp;str, bool endWithNewline, bool location)</td></tr>
<tr class="memdesc:a8a88e8bc81269b07f6ce7a7b31aea94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the contents of hdr followed by str to wherever the translator's error output stream is aimed.  <a href="#a8a88e8bc81269b07f6ce7a7b31aea94d">More...</a><br/></td></tr>
<tr class="separator:a8a88e8bc81269b07f6ce7a7b31aea94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c11ad8502a2aeec081563dc13232462"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#a5c11ad8502a2aeec081563dc13232462">resolveDynamicDeclarations</a> (BaseElementList &amp;undefined, BaseElementList &amp;reallyUndefined)</td></tr>
<tr class="memdesc:a5c11ad8502a2aeec081563dc13232462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to resolve dynamic declarations that weren't caught previously.  <a href="#a5c11ad8502a2aeec081563dc13232462">More...</a><br/></td></tr>
<tr class="separator:a5c11ad8502a2aeec081563dc13232462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6696248ca5c08d2fa8df07838d63e1b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ac6696248ca5c08d2fa8df07838d63e1b">makeCausalTranslation</a> (std::ostream &amp;<a class="el" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>, StmtList &amp;extraStmts, IPart ipart, bool assumingNotNot, std::string const &amp;baseTimeStamp, <a class="el" href="classParseElement.html">ParseElement</a> *head, <a class="el" href="classParseElement.html">ParseElement</a> *ifBody, <a class="el" href="classParseElement.html">ParseElement</a> *assumingBody, <a class="el" href="classParseElement.html">ParseElement</a> *unlessBody, <a class="el" href="classParseElement.html">ParseElement</a> *afterBody, <a class="el" href="classParseElement.html">ParseElement</a> *whereBody)</td></tr>
<tr class="memdesc:ac6696248ca5c08d2fa8df07838d63e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function for translating causal laws.  <a href="#ac6696248ca5c08d2fa8df07838d63e1b">More...</a><br/></td></tr>
<tr class="separator:ac6696248ca5c08d2fa8df07838d63e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c3fc88127578322d7065dd89ab54f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTranslator.html#ab7c3fc88127578322d7065dd89ab54f6">makeShowStmt</a> (<a class="el" href="classParseElement.html">ParseElement</a> *elem, StmtList &amp;stmts, Variable const *eql=NULL)</td></tr>
<tr class="memdesc:ab7c3fc88127578322d7065dd89ab54f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a '#show' statement for the provided element.  <a href="#ab7c3fc88127578322d7065dd89ab54f6">More...</a><br/></td></tr>
<tr class="separator:ab7c3fc88127578322d7065dd89ab54f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that provides data storage and translation capabilities. </p>
<p>Encapsulates a symbol table and data structures for the declared symbols, and provides methods to manipulate and translate the stored data. </p>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00057">57</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9d95c49c85f8825e1c6c2a0c65ab1c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Translator::Translator </td>
          <td>(</td>
          <td class="paramtype">Language&#160;</td>
          <td class="paramname"><em>in</em> = <code>LANG_CPLUS</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initializes attributes to blank/empty. Also sets up default internal sorts, objects, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input language that the translator will accept. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00270">270</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00259">addSymbol()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01987">createInternalNumRange()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01965">createInternalObject()</a>, <a class="el" href="old_2Translator_8h_source.html#l00565">createInternalSort()</a>, <a class="el" href="old_2Translator_8h_source.html#l00220">getSort()</a>, <a class="el" href="old_2Translator_8h_source.html#l00709">lang()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02037">setStaticTranslation()</a>, and <a class="el" href="old_2Translator_8h_source.html#l00093">tempQuery</a>.</p>
<div class="fragment"><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;{</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    Sort *newSort, *additiveConstantSort, *actionSort;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <a class="code" href="classbabb_1_1utils_1_1ReferencedWrapper.html">SortList</a> tmpList;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    mLanguage = <a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>;</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="comment">/**************************************** Initialize IO ********************************************/</span></div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    <span class="comment">// Open a null file output and set ostNull to it.</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    fNull.open(<span class="stringliteral">&quot;/dev/null&quot;</span>);</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    ostNullPtr = <span class="keyword">new</span> std::ostream(fNull.rdbuf());</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <span class="comment">// Start ostOutPtr and ostErrPtr using fNull as well.</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    ostOutPtr = <span class="keyword">new</span> std::ostream(ostNullPtr-&gt;rdbuf());</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    ostErrPtr = <span class="keyword">new</span> std::ostream(ostNullPtr-&gt;rdbuf());</div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    <span class="comment">// Allocate an initial tempQuery.</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <a class="code" href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">tempQuery</a> = <span class="keyword">new</span> Query();</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="comment">/**************************************** Initialize Sorts ********************************************/</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="comment">// Create boolean / boolean* domains</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    newSort = this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;boolean*&quot;</span>, NULL);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    newSort = this-&gt;<a class="code" href="classTranslator.html#af8a229b868ba6ee176754ec2e342b6bd">getSort</a>(<span class="stringliteral">&quot;boolean&quot;</span>);</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    this-&gt;<a class="code" href="classTranslator.html#ac85a78110d57dcf071372dea802b36dd">createInternalObject</a>(<span class="stringliteral">&quot;true&quot;</span>, NULL, newSort);</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    this-&gt;<a class="code" href="classTranslator.html#ac85a78110d57dcf071372dea802b36dd">createInternalObject</a>(<span class="stringliteral">&quot;false&quot;</span>, NULL, newSort);</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="comment">// Create step/astep domains, the action time sort.</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a> != LANG_MVPF) {</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        newSort = this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;astep&quot;</span>, NULL);</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        this-&gt;<a class="code" href="classTranslator.html#ab69aeab6a3d337188a8f8dd44be7bee4">createInternalNumRange</a>(<span class="stringliteral">&quot;0..maxstep-1&quot;</span>, newSort);</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        tmpList.push_back(newSort);</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        newSort = this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;step&quot;</span>, &amp;tmpList);</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        tmpList.clear();</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        this-&gt;<a class="code" href="classTranslator.html#ac85a78110d57dcf071372dea802b36dd">createInternalObject</a>(<span class="stringliteral">&quot;maxstep&quot;</span>, NULL, newSort);</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        <span class="comment">// The additiveConstant sort is a supersort for both additiveFluent and additiveAction.</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        additiveConstantSort = this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;additiveConstant&quot;</span>, NULL);</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        <span class="comment">// Action sorts.</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        tmpList.push_back(this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;abAction&quot;</span>, NULL));</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        tmpList.push_back(this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;attribute&quot;</span>, NULL));</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        tmpList.push_back(this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;exogenousAction&quot;</span>, NULL));</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;        newSort = this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;additiveAction&quot;</span>, NULL);</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        additiveConstantSort-&gt;addSubsort(newSort);</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        tmpList.push_back(newSort);</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        actionSort = this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;action&quot;</span>, &amp;tmpList);</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        tmpList.clear();</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        <span class="comment">// Fluent sorts.</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        tmpList.push_back(this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;inertialFluent&quot;</span>, NULL));</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        newSort = this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;additiveFluent&quot;</span>, NULL);</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;        additiveConstantSort-&gt;addSubsort(newSort);</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        tmpList.push_back(newSort);</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;        newSort = this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;simpleFluent&quot;</span>, &amp;tmpList);           <span class="comment">// inertialFluent and additiveFluent are both simpleFluents</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        tmpList.clear();</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        tmpList.push_back(newSort);</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;        tmpList.push_back(this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;sdFluent&quot;</span>, NULL));</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;        tmpList.push_back(this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;rigid&quot;</span>, NULL));             <span class="comment">// Rigids aren&#39;t technically &quot;fluents&quot; after translation, but in CCalc they still are.</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;        this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;fluent&quot;</span>, &amp;tmpList);</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        tmpList.clear();</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;</div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        <span class="comment">// Additive range sorts</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;        newSort = this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;nnAdditiveInteger&quot;</span>, NULL);              <span class="comment">// positive integer sort.</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        this-&gt;<a class="code" href="classTranslator.html#ab69aeab6a3d337188a8f8dd44be7bee4">createInternalNumRange</a>(<span class="stringliteral">&quot;0..maxAdditive&quot;</span>, newSort);</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;        newSort = this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;additiveInteger&quot;</span>, NULL);                <span class="comment">// positive + negative integer sort.</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;        this-&gt;<a class="code" href="classTranslator.html#ab69aeab6a3d337188a8f8dd44be7bee4">createInternalNumRange</a>(<span class="stringliteral">&quot;-maxAdditive..maxAdditive&quot;</span>, newSort);</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    </div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="comment">// Apparently afValue is a synonym for this sort.</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        newSort = this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;afValue&quot;</span>, NULL);</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        this-&gt;<a class="code" href="classTranslator.html#ab69aeab6a3d337188a8f8dd44be7bee4">createInternalNumRange</a>(<span class="stringliteral">&quot;-maxAdditive..maxAdditive&quot;</span>, newSort);</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    </div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        <span class="comment">// Add the contribution constant for additive constants.</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        tmpList.push_back(actionSort);</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        tmpList.push_back(additiveConstantSort);</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        <a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a>* contribution = <span class="keyword">new</span> <a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a>(<span class="stringliteral">&quot;contribution&quot;</span>, newSort, Constant::CONST_ACTION, <span class="keyword">true</span>, (ConstSortList*)&amp;tmpList);</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        tmpList.clear();</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        <a class="code" href="classTranslator.html#a915d7f328ae4d090a55309522275886c">addSymbol</a>(contribution);</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    }</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="comment">// Computed sort for LUA functions</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;    this-&gt;<a class="code" href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">createInternalSort</a>(<span class="stringliteral">&quot;computed&quot;</span>, NULL);</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    <span class="comment">// we want to use a dynamic translation.</span></div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <a class="code" href="classTranslator.html#ab22e2028787ae2151f63cb82b6544c40">setStaticTranslation</a>(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a> != LANG_MVPF);</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    blnFoundAbnormalities = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    blnFoundAdditive = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="comment">// Initialize the incremental part</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    mCurrentPart = IPART_NONE;</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_a915d7f328ae4d090a55309522275886c"><div class="ttname"><a href="classTranslator.html#a915d7f328ae4d090a55309522275886c">Translator::addSymbol</a></div><div class="ttdeci">SymbolTable::SymTblResult addSymbol(Element *elem)</div><div class="ttdoc">Attempts to add a new symbol to the translator&#39;s data structures. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00259">Translator.h:259</a></div></div>
<div class="ttc" id="classTranslator_html_af8a229b868ba6ee176754ec2e342b6bd"><div class="ttname"><a href="classTranslator.html#af8a229b868ba6ee176754ec2e342b6bd">Translator::getSort</a></div><div class="ttdeci">Sort * getSort(std::string const &amp;name)</div><div class="ttdoc">Finds a sort identifier associated with the name/arity (or NULL);. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00220">Translator.h:220</a></div></div>
<div class="ttc" id="namespacebcplus_1_1elements_html_ab532875292bfd1ac4993edaced4d8266"><div class="ttname"><a href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">bcplus::elements::Constant</a></div><div class="ttdeci">detail::IdentifierElement&lt; Term, detail::TermType::CONSTANT, symbols::ConstantSymbol, Term &gt; Constant</div><div class="ttdoc">A bare constant &#39;c&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00189">terms.h:189</a></div></div>
<div class="ttc" id="classTranslator_html_ab22e2028787ae2151f63cb82b6544c40"><div class="ttname"><a href="classTranslator.html#ab22e2028787ae2151f63cb82b6544c40">Translator::setStaticTranslation</a></div><div class="ttdeci">void setStaticTranslation(bool staticTrans)</div><div class="ttdoc">Sets whether the translator instance should output a static translation of the CCalc source file inst...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02037">Translator.cpp:2037</a></div></div>
<div class="ttc" id="classbabb_1_1utils_1_1ReferencedWrapper_html"><div class="ttname"><a href="classbabb_1_1utils_1_1ReferencedWrapper.html">babb::utils::ReferencedWrapper</a></div><div class="ttdoc">A base wrapper class for creating reference counted classes from non-reference counted ones...</div><div class="ttdef"><b>Definition:</b> <a href="as2transition_2include_2babb_2utils_2memory_2ReferencedWrapper_8h_source.html#l00013">ReferencedWrapper.h:13</a></div></div>
<div class="ttc" id="classTranslator_html_a864d4dc33098092fef562455dc97c9e2"><div class="ttname"><a href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">Translator::lang</a></div><div class="ttdeci">Language lang() const </div><div class="ttdoc">Gets the currently active language. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00709">Translator.h:709</a></div></div>
<div class="ttc" id="classTranslator_html_ab69aeab6a3d337188a8f8dd44be7bee4"><div class="ttname"><a href="classTranslator.html#ab69aeab6a3d337188a8f8dd44be7bee4">Translator::createInternalNumRange</a></div><div class="ttdeci">NumberRange * createInternalNumRange(std::string const &amp;newObjName, Sort *ofSort)</div><div class="ttdoc">Allocates and adds a number range with the given name and bounds to the translator&#39;s internal data st...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l01987">Translator.cpp:1987</a></div></div>
<div class="ttc" id="classTranslator_html_a939688f2e8d7f2a5ce94dc0e3b9ddc89"><div class="ttname"><a href="classTranslator.html#a939688f2e8d7f2a5ce94dc0e3b9ddc89">Translator::createInternalSort</a></div><div class="ttdeci">Sort * createInternalSort(std::string const &amp;newSortName, SortList *subsorts=NULL)</div><div class="ttdoc">Allocates and adds a sort with the given name to the translator&#39;s internal data structures without tr...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00565">Translator.h:565</a></div></div>
<div class="ttc" id="classTranslator_html_ac85a78110d57dcf071372dea802b36dd"><div class="ttname"><a href="classTranslator.html#ac85a78110d57dcf071372dea802b36dd">Translator::createInternalObject</a></div><div class="ttdeci">Object * createInternalObject(std::string const &amp;newObjName, SortList *params, Sort *ofSort)</div><div class="ttdoc">Allocates and adds an object with the given name to the translator&#39;s internal data structures...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l01965">Translator.cpp:1965</a></div></div>
<div class="ttc" id="classTranslator_html_aa75abc327fac9fd6890fe20b76a0331b"><div class="ttname"><a href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">Translator::tempQuery</a></div><div class="ttdeci">Query * tempQuery</div><div class="ttdoc">Helps the parser process and prepare queries for translation. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00093">Translator.h:93</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9c262ba866126a6a35e979a64d7e3518"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Translator::~Translator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Deallocates all memory associated with the objects in the list attributes and clears their contents. </p>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02201">2201</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00093">tempQuery</a>.</p>
<div class="fragment"><div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;{</div>
<div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;    <span class="keywordflow">if</span>(this-&gt;<a class="code" href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">tempQuery</a>)</div>
<div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;    {</div>
<div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;        <span class="keyword">delete</span> <a class="code" href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">tempQuery</a>;</div>
<div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;        <a class="code" href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">tempQuery</a> = NULL;</div>
<div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;    }</div>
<div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;</div>
<div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;    <span class="keywordflow">for</span> (std::list&lt;Query*&gt;::iterator it = queries.begin(); it != queries.end(); it++)</div>
<div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;        <span class="keyword">delete</span> *it;</div>
<div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;</div>
<div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;</div>
<div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;    queries.clear();</div>
<div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;    <span class="comment">// Reset and deallocate the internal ostream pointers.</span></div>
<div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;    <span class="keywordflow">if</span>(ostNullPtr)</div>
<div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;    {</div>
<div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;        <span class="keywordflow">if</span>(ostOutPtr)</div>
<div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;        {</div>
<div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;            ostOutPtr-&gt;rdbuf(ostNullPtr-&gt;rdbuf());</div>
<div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;        }</div>
<div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;        <span class="keywordflow">if</span>(ostErrPtr)</div>
<div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;        {</div>
<div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;            ostErrPtr-&gt;rdbuf(ostNullPtr-&gt;rdbuf());</div>
<div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;        }</div>
<div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;    }</div>
<div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;    <span class="keyword">delete</span> ostOutPtr;</div>
<div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;    <span class="keyword">delete</span> ostErrPtr;</div>
<div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;    <span class="keyword">delete</span> ostNullPtr;</div>
<div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;    <span class="comment">// Close fNull so we don&#39;t leave an open file handle.</span></div>
<div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;    fNull.close();</div>
<div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_aa75abc327fac9fd6890fe20b76a0331b"><div class="ttname"><a href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">Translator::tempQuery</a></div><div class="ttdeci">Query * tempQuery</div><div class="ttdoc">Helps the parser process and prepare queries for translation. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00093">Translator.h:93</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4a707e494f50c66fdfaed21bb8c95d63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Translator::addQuery </td>
          <td>(</td>
          <td class="paramtype">Query *&#160;</td>
          <td class="paramname"><em>newQuery</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to add a new Query object to the translator's data structures. </p>
<p>A query with the same label must not already be present, or it will be flagged as a duplicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newQuery</td><td>- A populated Query instance to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from SymbolTable's SymTblResult enum indicating success/failure of the add. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00469">469</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l00367">getQuery()</a>.</p>
<div class="fragment"><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;{</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;    <span class="keywordtype">int</span> retVal = SymbolTable::ADDSYM_ERR; <span class="comment">// Start pessimistic.</span></div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;    <span class="keywordflow">if</span>(newQuery)</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    {</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        <span class="comment">// Do some basic sanity checks, then try adding it into local data structures.</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        <span class="keywordflow">if</span>(newQuery-&gt;label == <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;        {</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;            newQuery-&gt;label = <span class="stringliteral">&quot;0&quot;</span>; <span class="comment">// An unlabeled query defaults to being query 0.</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        }</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        <span class="comment">// Note: We no longer require queries to specify a maximum step.</span></div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        <span class="comment">// If it turns out we do need a max step (ie static translation)</span></div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        <span class="comment">// the wrapper will take care of it.</span></div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        <span class="keywordflow">if</span>(this-&gt;<a class="code" href="classTranslator.html#a2f07647fcf8849ed861f4d3cdd0e20cc">getQuery</a>(newQuery-&gt;label) == NULL)</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        {</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;            queries.push_back(newQuery);</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;            retVal = SymbolTable::ADDSYM_OK;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        }</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        {   <span class="comment">// A query with this label already exists, flag the dupe.</span></div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;            retVal = SymbolTable::ADDSYM_DUP;</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;        }</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;    }</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_a2f07647fcf8849ed861f4d3cdd0e20cc"><div class="ttname"><a href="classTranslator.html#a2f07647fcf8849ed861f4d3cdd0e20cc">Translator::getQuery</a></div><div class="ttdeci">Query * getQuery(std::string const &amp;testLabel)</div><div class="ttdoc">Searches for a stored query with the given label in the translator&#39;s data structures. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00367">Translator.cpp:367</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab81fe4e23f74e16c264e2ede86469715"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sort * Translator::addSort </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>sortName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bcplusparser_2src_2bcplus_2parser_2detail_2lemon__parser_8cpp.html#a1e748d96d374dd429d856e584e62878d">SortList</a> *&#160;</td>
          <td class="paramname"><em>subsorts</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>translateDeclaration</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warnOnDup</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to create and add a sort object to the translator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sortName</td><td>The name of the sort to add. </td></tr>
    <tr><td class="paramname">internal</td><td>- Whether this symbol is internal to the translator or not. </td></tr>
    <tr><td class="paramname">subsorts</td><td>A (possibly NULL) list of subsorts to attach to the sort. In the event the sort already exists, these subsorts will be added to the existing sort. </td></tr>
    <tr><td class="paramname">translateDeclaration</td><td>Whether to add the declaration to the translation output. </td></tr>
    <tr><td class="paramname">warnOnDup</td><td>Whether to print a warning if the sort declaration is a duplicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created sort or the previously existing sort. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00400">400</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00259">addSymbol()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00382">getOrCreateObject()</a>, <a class="el" href="old_2Translator_8h_source.html#l00207">getSymbol()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00238">sortNameToVariable()</a>, <a class="el" href="src_2cplus2asp_2utils_8h_source.html#l00088">utils::to_string()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00594">translateObjectDecl()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00651">translateSortDecl()</a>, <a class="el" href="utils_8cpp_source.html#l00078">utils::trimWhitespace()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l02083">warn()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8h_source.html#l00565">createInternalSort()</a>.</p>
<div class="fragment"><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;{</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    std::string trimmedName = <a class="code" href="namespaceutils.html#a59fd1c19114035e71e5887fa296d185e">utils::trimWhitespace</a>(sortName);</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;    Element* retVal = NULL;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;    <span class="keywordtype">bool</span> needTrans = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    <span class="keywordflow">if</span> ((retVal = <a class="code" href="classTranslator.html#abd86b749727e0b5f5d5f8a6fac9bb7e7">getSymbol</a>(trimmedName))) {</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;        <span class="keywordflow">if</span> (retVal-&gt;getElemType() != Element::ELEM_SORT) {</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;Detected conflicting definition of identifier \&quot;&quot;</span> + trimmedName + std::string(<span class="stringliteral">&quot;/0&quot;</span>) + <span class="stringliteral">&quot;\&quot;.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (warnOnDup) {</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;            <span class="comment">// Duplicate.</span></div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;            <a class="code" href="classTranslator.html#aa07bcca529cd19ad8602fb4ec5ec16d9">warn</a>(<span class="stringliteral">&quot;Found duplicate definition of identifier \&quot;&quot;</span> + trimmedName + std::string(<span class="stringliteral">&quot;/0&quot;</span>) + <span class="stringliteral">&quot;\&quot;.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        }</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        <span class="comment">// It doesn&#39;t exist already. Add it.</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        needTrans = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;        <span class="comment">// Select a unique variable.</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        std::string baseName = <a class="code" href="classTranslator.html#aa5d43f47ea2676625f9acc6210b73972">sortNameToVariable</a>(trimmedName, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        <span class="keywordtype">size_t</span> i = 0;</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        std::string varName = baseName;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        <span class="keywordflow">while</span> (<a class="code" href="classTranslator.html#abd86b749727e0b5f5d5f8a6fac9bb7e7">getSymbol</a>(varName, 0)) {</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;            varName = baseName + <a class="code" href="namespaceutils.html#a8f62b72e0def57deb33132dfd5d4a0ec">utils::to_string</a>(++i);</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        }</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;        <a class="code" href="namespacebcplus_1_1elements.html#a3e6f840af4a14452b75d90ee8ada34f3">Variable</a>* sortVar = <span class="keyword">new</span> <a class="code" href="namespacebcplus_1_1elements.html#a3e6f840af4a14452b75d90ee8ada34f3">Variable</a>(varName, <span class="keyword">true</span>, NULL);</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        mSymbolTable.addSymbol(sortVar);</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        retVal = <span class="keyword">new</span> Sort(trimmedName, sortVar, <span class="keyword">internal</span>);</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        <a class="code" href="classTranslator.html#a915d7f328ae4d090a55309522275886c">addSymbol</a>(retVal);</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    }</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    <span class="comment">// If the sort is &quot;something*&quot; we should ensure that its parent exists and that</span></div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="comment">// the appropriate subsorts are present.</span></div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    <span class="keywordflow">if</span> (trimmedName.at(trimmedName.length()-1) == <span class="charliteral">&#39;*&#39;</span>) {</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        Sort* parentSort = <a class="code" href="classTranslator.html#ab81fe4e23f74e16c264e2ede86469715">addSort</a>(trimmedName.substr(0, trimmedName.length()-1), <span class="keyword">internal</span>, subsorts, translateDeclaration, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;        needTrans |= ((Sort*)retVal)-&gt;addSubsort(parentSort, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        <span class="comment">// In addition, we should add the &#39;none&#39; object.</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;        <a class="code" href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">Object</a>* none = <a class="code" href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">getOrCreateObject</a>(<span class="stringliteral">&quot;none&quot;</span>, Object::OBJ_NAME);</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;        <span class="keywordtype">bool</span> needObjTrans = ((Sort*)retVal)-&gt;addObject(none, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;        <span class="comment">// Translate it, if necessary.</span></div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        <span class="keywordflow">if</span> (translateDeclaration &amp;&amp; needObjTrans) {</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;            <a class="code" href="classTranslator.html#aa05427462bb0825e125b6d4f3054cf78">translateObjectDecl</a>(none, (Sort*)retVal);</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        }</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        <span class="keywordflow">if</span> (subsorts) {</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;            <span class="keywordflow">for</span> (SortList::iterator it = subsorts-&gt;begin(); it != subsorts-&gt;end(); it++)</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;                needTrans |= ((Sort*)retVal)-&gt;addSubsort(*it, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;        }</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    }</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;    <span class="comment">// Translate the declaration if anything has changed or the sort is new.</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <span class="keywordflow">if</span> (translateDeclaration &amp;&amp; needTrans) {</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        <a class="code" href="classTranslator.html#ac261db6a4a61d4b0e9c86874199bbe9e">translateSortDecl</a>((Sort*)retVal);</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    }</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;    <span class="keywordflow">return</span> ((Sort*)retVal);</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;}</div>
<div class="ttc" id="namespacebcplus_1_1elements_html_a5484f87e7a51fb686edfbd620d3a0804"><div class="ttname"><a href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">bcplus::elements::Object</a></div><div class="ttdeci">detail::IdentifierElement&lt; Term, detail::TermType::OBJECT, symbols::ObjectSymbol, Term &gt; Object</div><div class="ttdoc">An object constant &#39;t&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00172">terms.h:172</a></div></div>
<div class="ttc" id="classTranslator_html_a915d7f328ae4d090a55309522275886c"><div class="ttname"><a href="classTranslator.html#a915d7f328ae4d090a55309522275886c">Translator::addSymbol</a></div><div class="ttdeci">SymbolTable::SymTblResult addSymbol(Element *elem)</div><div class="ttdoc">Attempts to add a new symbol to the translator&#39;s data structures. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00259">Translator.h:259</a></div></div>
<div class="ttc" id="classTranslator_html_aa5d43f47ea2676625f9acc6210b73972"><div class="ttname"><a href="classTranslator.html#aa5d43f47ea2676625f9acc6210b73972">Translator::sortNameToVariable</a></div><div class="ttdeci">static std::string sortNameToVariable(std::string const &amp;sortName, bool sanitizeFirst=false)</div><div class="ttdoc">Transforms a sort name into an acceptable variable name containing as much of the original sort name ...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00238">Translator.cpp:238</a></div></div>
<div class="ttc" id="namespacebcplus_1_1elements_html_a3e6f840af4a14452b75d90ee8ada34f3"><div class="ttname"><a href="namespacebcplus_1_1elements.html#a3e6f840af4a14452b75d90ee8ada34f3">bcplus::elements::Variable</a></div><div class="ttdeci">detail::IdentifierElement_bare&lt; Term, detail::TermType::VARIABLE, symbols::VariableSymbol &gt; Variable</div><div class="ttdoc">A variable &#39;V&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00180">terms.h:180</a></div></div>
<div class="ttc" id="classTranslator_html_ac261db6a4a61d4b0e9c86874199bbe9e"><div class="ttname"><a href="classTranslator.html#ac261db6a4a61d4b0e9c86874199bbe9e">Translator::translateSortDecl</a></div><div class="ttdeci">void translateSortDecl(Sort const *transSort)</div><div class="ttdoc">Translates a Sort element into an ASP-compatible sort declaration. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00651">Translator.cpp:651</a></div></div>
<div class="ttc" id="classTranslator_html_aa07bcca529cd19ad8602fb4ec5ec16d9"><div class="ttname"><a href="classTranslator.html#aa07bcca529cd19ad8602fb4ec5ec16d9">Translator::warn</a></div><div class="ttdeci">void warn(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02083">Translator.cpp:2083</a></div></div>
<div class="ttc" id="classTranslator_html_aa05427462bb0825e125b6d4f3054cf78"><div class="ttname"><a href="classTranslator.html#aa05427462bb0825e125b6d4f3054cf78">Translator::translateObjectDecl</a></div><div class="ttdeci">void translateObjectDecl(Object const *transObj, Sort const *sortObj)</div><div class="ttdoc">Translates an Object element into an ASP-compatible declaration of an object as a member of a sort&#39;s ...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00594">Translator.cpp:594</a></div></div>
<div class="ttc" id="namespaceutils_html_a8f62b72e0def57deb33132dfd5d4a0ec"><div class="ttname"><a href="namespaceutils.html#a8f62b72e0def57deb33132dfd5d4a0ec">utils::to_string</a></div><div class="ttdeci">std::string to_string(T val, std::ios_base &amp;(*fmt)(std::ios_base &amp;)=std::dec, int precision=-1)</div><div class="ttdoc">Transforms something (usually a number) into a string representation of itself. </div><div class="ttdef"><b>Definition:</b> <a href="src_2cplus2asp_2utils_8h_source.html#l00088">utils.h:88</a></div></div>
<div class="ttc" id="classTranslator_html_a7c14268a49b3551907e27ba347d13e93"><div class="ttname"><a href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">Translator::error</a></div><div class="ttdeci">void error(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02076">Translator.cpp:2076</a></div></div>
<div class="ttc" id="classTranslator_html_ab255d800190701bc36af2f4b7582c1d0"><div class="ttname"><a href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">Translator::getOrCreateObject</a></div><div class="ttdeci">Object * getOrCreateObject(std::string const &amp;symName, Object::ObjectType type=Object::OBJ_NAME, bool internal=false, size_t arity=0)</div><div class="ttdoc">Helper function for getting an Object type reference or dynamically adding it if it doesn&#39;t occur...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00382">Translator.cpp:382</a></div></div>
<div class="ttc" id="classTranslator_html_ab81fe4e23f74e16c264e2ede86469715"><div class="ttname"><a href="classTranslator.html#ab81fe4e23f74e16c264e2ede86469715">Translator::addSort</a></div><div class="ttdeci">Sort * addSort(std::string const &amp;sortName, bool internal, SortList *subsorts=NULL, bool translateDeclaration=true, bool warnOnDup=false)</div><div class="ttdoc">Attempts to create and add a sort object to the translator. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00400">Translator.cpp:400</a></div></div>
<div class="ttc" id="namespaceutils_html_a59fd1c19114035e71e5887fa296d185e"><div class="ttname"><a href="namespaceutils.html#a59fd1c19114035e71e5887fa296d185e">utils::trimWhitespace</a></div><div class="ttdeci">std::string trimWhitespace(std::string const &amp;text)</div><div class="ttdoc">Trims whitespace from both ends of a text string. </div><div class="ttdef"><b>Definition:</b> <a href="utils_8cpp_source.html#l00078">utils.cpp:78</a></div></div>
<div class="ttc" id="classTranslator_html_abd86b749727e0b5f5d5f8a6fac9bb7e7"><div class="ttname"><a href="classTranslator.html#abd86b749727e0b5f5d5f8a6fac9bb7e7">Translator::getSymbol</a></div><div class="ttdeci">Element * getSymbol(std::string const &amp;name, size_t arity=0)</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00207">Translator.h:207</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a915d7f328ae4d090a55309522275886c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SymbolTable::SymTblResult Translator::addSymbol </td>
          <td>(</td>
          <td class="paramtype">Element *&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to add a new symbol to the translator's data structures. </p>
<p>The object must not already be present in the symbol table, or it will be flagged as a duplicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newConst</td><td>- A populated symbol instance to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A value from SymbolTable's SymTblResult enum indicating success/failure of the add. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00259">259</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00400">addSort()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01987">createInternalNumRange()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01965">createInternalObject()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00382">getOrCreateObject()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00270">Translator()</a>.</p>
<div class="fragment"><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;{ <span class="keywordflow">return</span> mSymbolTable.addSymbol(elem); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aed3dafe51e51a6bc4bc63c7d35dc63f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::addToFooter </td>
          <td>(</td>
          <td class="paramtype">StmtList &amp;&#160;</td>
          <td class="paramname"><em>stmts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the provided statement to the program's footer buffer, resulting them in being included in the footer in the future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmts</td><td>- The statements to be added to the footer. Will be emptied by the operation. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00691">691</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l01378">translateShowStmt()</a>.</p>
<div class="fragment"><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;{ mFooterStmts.splice(mFooterStmts.end(), stmts); }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad9cde58cce92f4108d00c68319c78965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::allocateNewTempQuery </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deallocateFirst</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new Query instance and assigns it to tempQuery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deallocateFirst</td><td>- If true, will deallocate the contents of tempQuery before the reallocation. (Default: false) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02017">2017</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00093">tempQuery</a>.</p>
<div class="fragment"><div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;{</div>
<div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;    <span class="keywordflow">if</span>(deallocateFirst &amp;&amp; <a class="code" href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">tempQuery</a>)</div>
<div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;    {</div>
<div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;        <span class="keyword">delete</span> <a class="code" href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">tempQuery</a>;</div>
<div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;        <a class="code" href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">tempQuery</a> = NULL;</div>
<div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;    }</div>
<div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;    <a class="code" href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">tempQuery</a> = <span class="keyword">new</span> Query();</div>
<div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_aa75abc327fac9fd6890fe20b76a0331b"><div class="ttname"><a href="classTranslator.html#aa75abc327fac9fd6890fe20b76a0331b">Translator::tempQuery</a></div><div class="ttdeci">Query * tempQuery</div><div class="ttdoc">Helps the parser process and prepare queries for translation. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00093">Translator.h:93</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0d2965d026bb2cfb15f62b533beaa155"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Translator::bindAndTranslate </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> const *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Context &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upwardMobileClauses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suppressQuantifier</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper method to translate a sub expression, capturing all of its clauses and variables in the meanwhile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>- The stream to output to. </td></tr>
    <tr><td class="paramname">expr</td><td>- The expression to translate. </td></tr>
    <tr><td class="paramname">context</td><td>- The current translation context. </td></tr>
    <tr><td class="paramname">upwardMobileClauses</td><td>- Whether we should migrate clauses to the parent context if no quantification was needed. </td></tr>
    <tr><td class="paramname">suppressQuantifier</td><td>- Whether to suppress the generation of quantifiers generated when leaving the context. Free variables will be simply dropped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02150">2150</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02140">outputClauses()</a>, and <a class="el" href="classParseElement.html#ac6eaa4986aba513b3f0064c878dd6caa">ParseElement::translate()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l01236">makeCausalTranslation()</a>, <a class="el" href="parser__types_8cpp_source.html#l00070">SimpleUnaryOperator::translate()</a>, <a class="el" href="parser__types_8cpp_source.html#l00398">SimpleBinaryOperator::translate()</a>, <a class="el" href="parser__types_8cpp_source.html#l00824">BigQuantifiers::translate()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00737">translateQuery()</a>.</p>
<div class="fragment"><div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;                                                                                                                                                       {</div>
<div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;</div>
<div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;    <span class="keywordflow">if</span> (!expr) <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;</div>
<div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;    <a class="code" href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">ClauseList</a> localClauses, localVariables;</div>
<div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;    Context localContext = context.mkBindClauses(&amp;localClauses).mkBindVars(&amp;localVariables);</div>
<div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;    std::ostringstream tmp;</div>
<div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;</div>
<div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;    expr-&gt;translate(tmp, localContext);</div>
<div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;</div>
<div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;    <span class="comment">// Existential quantification (if needed).</span></div>
<div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;    <span class="keywordflow">if</span> (!localVariables.empty() &amp;&amp; !suppressQuantifier) {</div>
<div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;        out &lt;&lt; <span class="stringliteral">&quot;?[&quot;</span>;</div>
<div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;</div>
<div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;        <span class="keywordflow">for</span> (std::list&lt;std::string&gt;::const_iterator it = localVariables.begin(); it != localVariables.end(); ) {</div>
<div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;                out &lt;&lt; *it;</div>
<div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;                <span class="keywordflow">if</span> (++it != localVariables.end()) out &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;        }</div>
<div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;        out &lt;&lt; <span class="stringliteral">&quot;]:&quot;</span>;</div>
<div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;    }</div>
<div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;</div>
<div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;    <span class="comment">//if ((!localVariables.empty() &amp;&amp; !suppressQuantifier)</span></div>
<div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;    <span class="comment">//      || (!upwardMobileClauses &amp;&amp; !localClauses.empty()))</span></div>
<div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;    <span class="comment">//{</span></div>
<div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;        out &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;    <span class="comment">//}</span></div>
<div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;</div>
<div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;    out &lt;&lt; tmp.str();</div>
<div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;</div>
<div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;    <span class="keywordflow">if</span> ((!localVariables.empty() &amp;&amp; !suppressQuantifier) || (!localClauses.empty() &amp;&amp; !upwardMobileClauses)) {</div>
<div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;        <a class="code" href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">Translator::outputClauses</a>(out, localClauses, <span class="keyword">true</span>);</div>
<div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;        <span class="comment">//out &lt;&lt; &quot;)&quot;;</span></div>
<div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!localClauses.empty()){</div>
<div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;        context.transferExtraClauses(localClauses);</div>
<div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;    }</div>
<div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;    out &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;</div>
<div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;}</div>
<div class="ttc" id="namespacecplus2asp_1_1cplus2asp__bin_html_a2fbffbd697b2a504d23669a23961be4b"><div class="ttname"><a href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">cplus2asp::cplus2asp_bin::ClauseList</a></div><div class="ttdeci">ReferencedList&lt; std::string &gt;::type ClauseList</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00027">types.h:27</a></div></div>
<div class="ttc" id="classTranslator_html_a2973b80adebf80f00ca209502465f8e5"><div class="ttname"><a href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">Translator::outputClauses</a></div><div class="ttdeci">static std::ostream &amp; outputClauses(std::ostream &amp;out, ClauseList const &amp;clauses, bool initConj=false)</div><div class="ttdoc">helper method to output multiple clauses to an output stream. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02140">Translator.cpp:2140</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a394192f42210f4245faeac6acfd52758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::caution </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endWithNewline</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>location</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the contents of str to wherever the translator's error output stream is aimed. </p>
<p>Mirrors output to the standard output stream as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The text to output. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02090">2090</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02101">outputToErr()</a>.</p>
<div class="fragment"><div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;{</div>
<div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;    <a class="code" href="classTranslator.html#a8a88e8bc81269b07f6ce7a7b31aea94d">outputToErr</a>(<span class="stringliteral">&quot;% Caution&quot;</span>,str,endWithNewline,location);</div>
<div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_a8a88e8bc81269b07f6ce7a7b31aea94d"><div class="ttname"><a href="classTranslator.html#a8a88e8bc81269b07f6ce7a7b31aea94d">Translator::outputToErr</a></div><div class="ttdeci">void outputToErr(std::string const &amp;hdr, std::string const &amp;str, bool endWithNewline, bool location)</div><div class="ttdoc">Outputs the contents of hdr followed by str to wherever the translator&#39;s error output stream is aimed...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02101">Translator.cpp:2101</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab69aeab6a3d337188a8f8dd44be7bee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NumberRange * Translator::createInternalNumRange </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>newObjName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort *&#160;</td>
          <td class="paramname"><em>ofSort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and adds a number range with the given name and bounds to the translator's internal data structures, connecting it as a member of the given sort's domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newObjName</td><td>- The base name for the new object. </td></tr>
    <tr><td class="paramname">ofSort</td><td>- The sort the new object is a member of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created and added number range, or NULL on an error. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01987">1987</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00259">addSymbol()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00270">Translator()</a>.</p>
<div class="fragment"><div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;{</div>
<div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;    NumberRange* retVal = NULL;</div>
<div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;    <span class="keywordflow">if</span>(ofSort)</div>
<div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;    {</div>
<div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;        retVal = <span class="keyword">new</span> NumberRange(newObjName);</div>
<div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;        <span class="keywordtype">int</span> addSymResult = this-&gt;<a class="code" href="classTranslator.html#a915d7f328ae4d090a55309522275886c">addSymbol</a>(retVal);</div>
<div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;        <span class="keywordflow">if</span>(addSymResult != SymbolTable::ADDSYM_OK)</div>
<div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;        {   <span class="comment">// Something went wrong adding the object, skip connecting &amp; translating it.</span></div>
<div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;            <span class="keywordflow">if</span>(addSymResult == SymbolTable::ADDSYM_DUP)</div>
<div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;            {   <span class="comment">// Duplicate object. don&#39;t bother adding it.</span></div>
<div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;                <span class="keyword">delete</span> retVal;</div>
<div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;                retVal = NULL;</div>
<div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;            }</div>
<div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;            {   <span class="comment">// A real object error. Skip adding it.</span></div>
<div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;                <span class="keyword">delete</span> retVal;</div>
<div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;                retVal = NULL;</div>
<div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;            }</div>
<div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;        }</div>
<div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;        {   <span class="comment">// Object add went okay, connect the sort to the object.</span></div>
<div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;            ofSort-&gt;addObject(retVal);</div>
<div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;        }</div>
<div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;    }</div>
<div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_a915d7f328ae4d090a55309522275886c"><div class="ttname"><a href="classTranslator.html#a915d7f328ae4d090a55309522275886c">Translator::addSymbol</a></div><div class="ttdeci">SymbolTable::SymTblResult addSymbol(Element *elem)</div><div class="ttdoc">Attempts to add a new symbol to the translator&#39;s data structures. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00259">Translator.h:259</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac85a78110d57dcf071372dea802b36dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Object * Translator::createInternalObject </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>newObjName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bcplusparser_2src_2bcplus_2parser_2detail_2lemon__parser_8cpp.html#a1e748d96d374dd429d856e584e62878d">SortList</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort *&#160;</td>
          <td class="paramname"><em>ofSort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and adds an object with the given name to the translator's internal data structures, connecting it as a member of the given sort's domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newObjName</td><td>- The base name for the new object. </td></tr>
    <tr><td class="paramname">params</td><td>- A list of Sort pointers representing the parameters of the object. NULL if there are no params. </td></tr>
    <tr><td class="paramname">ofSort</td><td>- The sort the new object is a member of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created and added object, or NULL on an error. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01965">1965</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00259">addSymbol()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>, <a class="el" href="old_2Translator_8h_source.html#l00207">getSymbol()</a>, and <a class="el" href="src_2cplus2asp_2utils_8h_source.html#l00088">utils::to_string()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00270">Translator()</a>.</p>
<div class="fragment"><div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;{</div>
<div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;    Element* retVal = <a class="code" href="classTranslator.html#abd86b749727e0b5f5d5f8a6fac9bb7e7">getSymbol</a>(newObjName, (params) ? params-&gt;size() : 0);</div>
<div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;</div>
<div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;    <span class="keywordflow">if</span> (retVal &amp;&amp; retVal-&gt;getElemType() != Element::ELEM_OBJ)</div>
<div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;Detected conflicting definition of \&quot;&quot;</span> + retVal-&gt;baseName() + <span class="stringliteral">&quot;/&quot;</span> + <a class="code" href="namespaceutils.html#a8f62b72e0def57deb33132dfd5d4a0ec">utils::to_string</a>(retVal-&gt;arity()) + <span class="stringliteral">&quot;\&quot;.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;        </div>
<div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;    <span class="keywordflow">if</span> (!retVal) {</div>
<div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;        retVal = <span class="keyword">new</span> <a class="code" href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">Object</a>(newObjName, Object::OBJ_NAME, <span class="keyword">true</span>, params);</div>
<div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classTranslator.html#a915d7f328ae4d090a55309522275886c">addSymbol</a>(retVal) != SymbolTable::ADDSYM_OK) {</div>
<div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;An error occurred while processing declaration of \&quot;&quot;</span> + retVal-&gt;baseName() + <span class="stringliteral">&quot;/&quot;</span> + <a class="code" href="namespaceutils.html#a8f62b72e0def57deb33132dfd5d4a0ec">utils::to_string</a>(retVal-&gt;arity()) + <span class="stringliteral">&quot;\&quot;.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;            <span class="keyword">delete</span> retVal;</div>
<div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;            retVal = NULL;</div>
<div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;        }</div>
<div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;    }</div>
<div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;</div>
<div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;    <span class="keywordflow">if</span> (retVal &amp;&amp; ofSort) ofSort-&gt;addObject((<a class="code" href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">Object</a>*)retVal);</div>
<div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;</div>
<div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;    <span class="keywordflow">return</span> ((<a class="code" href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">Object</a>*)retVal);</div>
<div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;}</div>
<div class="ttc" id="namespacebcplus_1_1elements_html_a5484f87e7a51fb686edfbd620d3a0804"><div class="ttname"><a href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">bcplus::elements::Object</a></div><div class="ttdeci">detail::IdentifierElement&lt; Term, detail::TermType::OBJECT, symbols::ObjectSymbol, Term &gt; Object</div><div class="ttdoc">An object constant &#39;t&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00172">terms.h:172</a></div></div>
<div class="ttc" id="classTranslator_html_a915d7f328ae4d090a55309522275886c"><div class="ttname"><a href="classTranslator.html#a915d7f328ae4d090a55309522275886c">Translator::addSymbol</a></div><div class="ttdeci">SymbolTable::SymTblResult addSymbol(Element *elem)</div><div class="ttdoc">Attempts to add a new symbol to the translator&#39;s data structures. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00259">Translator.h:259</a></div></div>
<div class="ttc" id="namespaceutils_html_a8f62b72e0def57deb33132dfd5d4a0ec"><div class="ttname"><a href="namespaceutils.html#a8f62b72e0def57deb33132dfd5d4a0ec">utils::to_string</a></div><div class="ttdeci">std::string to_string(T val, std::ios_base &amp;(*fmt)(std::ios_base &amp;)=std::dec, int precision=-1)</div><div class="ttdoc">Transforms something (usually a number) into a string representation of itself. </div><div class="ttdef"><b>Definition:</b> <a href="src_2cplus2asp_2utils_8h_source.html#l00088">utils.h:88</a></div></div>
<div class="ttc" id="classTranslator_html_a7c14268a49b3551907e27ba347d13e93"><div class="ttname"><a href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">Translator::error</a></div><div class="ttdeci">void error(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02076">Translator.cpp:2076</a></div></div>
<div class="ttc" id="classTranslator_html_abd86b749727e0b5f5d5f8a6fac9bb7e7"><div class="ttname"><a href="classTranslator.html#abd86b749727e0b5f5d5f8a6fac9bb7e7">Translator::getSymbol</a></div><div class="ttdeci">Element * getSymbol(std::string const &amp;name, size_t arity=0)</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00207">Translator.h:207</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a939688f2e8d7f2a5ce94dc0e3b9ddc89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sort* Translator::createInternalSort </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>newSortName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bcplusparser_2src_2bcplus_2parser_2detail_2lemon__parser_8cpp.html#a1e748d96d374dd429d856e584e62878d">SortList</a> *&#160;</td>
          <td class="paramname"><em>subsorts</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and adds a sort with the given name to the translator's internal data structures without translating or outputting it. </p>
<p>Also sets up a default Variable for the sort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSortName</td><td>- The base name for the new sort. </td></tr>
    <tr><td class="paramname">subsorts</td><td>- A list of Sort pointers to sorts that are subsorts of of the sort to be created. NULL if there are no subsorts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created and added sort, or NULL on an error. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00565">565</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l00400">addSort()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00270">Translator()</a>.</p>
<div class="fragment"><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;        { <span class="keywordflow">return</span> <a class="code" href="classTranslator.html#ab81fe4e23f74e16c264e2ede86469715">addSort</a>(newSortName, <span class="keyword">true</span>, subsorts, <span class="keyword">false</span>); }</div>
<div class="ttc" id="classTranslator_html_ab81fe4e23f74e16c264e2ede86469715"><div class="ttname"><a href="classTranslator.html#ab81fe4e23f74e16c264e2ede86469715">Translator::addSort</a></div><div class="ttdeci">Sort * addSort(std::string const &amp;sortName, bool internal, SortList *subsorts=NULL, bool translateDeclaration=true, bool warnOnDup=false)</div><div class="ttdoc">Attempts to create and add a sort object to the translator. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00400">Translator.cpp:400</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7c14268a49b3551907e27ba347d13e93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::error </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endWithNewline</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>location</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the contents of str to wherever the translator's error output stream is aimed. </p>
<p>Mirrors output to the standard output stream as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The text to output. </td></tr>
    <tr><td class="paramname">endWithNewline</td><td>- Whether to terminate the message in a newline. </td></tr>
    <tr><td class="paramname">location</td><td>- Whether to include the parser's current location in the message. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02076">2076</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02101">outputToErr()</a>, and <a class="el" href="old_2Translator_8h_source.html#l00091">translatorNumErrors</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00400">addSort()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01965">createInternalObject()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00382">getOrCreateObject()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01741">translateCausesLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01511">translateConstraintLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01796">translateIncrementLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01679">translateMayCauseLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01605">translateNonexecutableLaw()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00737">translateQuery()</a>.</p>
<div class="fragment"><div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;{</div>
<div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;    <a class="code" href="classTranslator.html#a8a88e8bc81269b07f6ce7a7b31aea94d">outputToErr</a>(<span class="stringliteral">&quot;% Error&quot;</span>,str,endWithNewline,location);</div>
<div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;    this-&gt;<a class="code" href="classTranslator.html#a237353d1182e41e51c3c3c99b66f2e63">translatorNumErrors</a>++;</div>
<div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_a237353d1182e41e51c3c3c99b66f2e63"><div class="ttname"><a href="classTranslator.html#a237353d1182e41e51c3c3c99b66f2e63">Translator::translatorNumErrors</a></div><div class="ttdeci">int translatorNumErrors</div><div class="ttdoc">Tracks how many errors the translator module encounters while translating things. ...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00091">Translator.h:91</a></div></div>
<div class="ttc" id="classTranslator_html_a8a88e8bc81269b07f6ce7a7b31aea94d"><div class="ttname"><a href="classTranslator.html#a8a88e8bc81269b07f6ce7a7b31aea94d">Translator::outputToErr</a></div><div class="ttdeci">void outputToErr(std::string const &amp;hdr, std::string const &amp;str, bool endWithNewline, bool location)</div><div class="ttdoc">Outputs the contents of hdr followed by str to wherever the translator&#39;s error output stream is aimed...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02101">Translator.cpp:2101</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae973090fa0d53bbf36bef3ccf6f50439"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Constant* Translator::getConstant </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a constant identifier associated with the name/arity (or NULL);. </p>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00210">210</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l02117">resolveDynamicDeclarations()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l01796">translateIncrementLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                                                                            { </div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        Element *elem;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        <span class="keywordflow">return</span> (<a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a>*)(((elem = mSymbolTable.findSymbol(<a class="code" href="structsymbol.html#a6230a18d2907cfebc06f3e66599bba89">name</a>, arity)) &amp;&amp; elem-&gt;getElemType() == Element::ELEM_CONST) ? elem : NULL); </div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    }</div>
<div class="ttc" id="namespacebcplus_1_1elements_html_ab532875292bfd1ac4993edaced4d8266"><div class="ttname"><a href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">bcplus::elements::Constant</a></div><div class="ttdeci">detail::IdentifierElement&lt; Term, detail::TermType::CONSTANT, symbols::ConstantSymbol, Term &gt; Constant</div><div class="ttdoc">A bare constant &#39;c&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00189">terms.h:189</a></div></div>
<div class="ttc" id="structsymbol_html_a6230a18d2907cfebc06f3e66599bba89"><div class="ttname"><a href="structsymbol.html#a6230a18d2907cfebc06f3e66599bba89">symbol::name</a></div><div class="ttdeci">const char * name</div><div class="ttdef"><b>Definition:</b> <a href="as2transition_2lemon_2lemon_8c_source.html#l00246">lemon.c:246</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad2840215dfa751426551708eca2141f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Object* Translator::getObject </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a object identifier associated with the name/arity (or NULL);. </p>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00215">215</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                                                                        {</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        Element *elem;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="keywordflow">return</span> (<a class="code" href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">Object</a>*)(((elem = mSymbolTable.findSymbol(<a class="code" href="structsymbol.html#a6230a18d2907cfebc06f3e66599bba89">name</a>, arity)) &amp;&amp; elem-&gt;getElemType() == Element::ELEM_OBJ) ? elem : NULL); </div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    }</div>
<div class="ttc" id="namespacebcplus_1_1elements_html_a5484f87e7a51fb686edfbd620d3a0804"><div class="ttname"><a href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">bcplus::elements::Object</a></div><div class="ttdeci">detail::IdentifierElement&lt; Term, detail::TermType::OBJECT, symbols::ObjectSymbol, Term &gt; Object</div><div class="ttdoc">An object constant &#39;t&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00172">terms.h:172</a></div></div>
<div class="ttc" id="structsymbol_html_a6230a18d2907cfebc06f3e66599bba89"><div class="ttname"><a href="structsymbol.html#a6230a18d2907cfebc06f3e66599bba89">symbol::name</a></div><div class="ttdeci">const char * name</div><div class="ttdef"><b>Definition:</b> <a href="as2transition_2lemon_2lemon_8c_source.html#l00246">lemon.c:246</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab255d800190701bc36af2f4b7582c1d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Object * Translator::getOrCreateObject </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>symName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Object::ObjectType&#160;</td>
          <td class="paramname"><em>type</em> = <code>Object::OBJ_NAME</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>internal</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for getting an Object type reference or dynamically adding it if it doesn't occur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symName</td><td>- The base name of the object to find. </td></tr>
    <tr><td class="paramname">type</td><td>- The type of object that the should be created. </td></tr>
    <tr><td class="paramname">internal</td><td>- Whether this symbol is internal to the translator or not. </td></tr>
    <tr><td class="paramname">arity</td><td>- The number of (anonymous) arguments the object has. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first matching Object instance (or the newly created one if none were found) </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00382">382</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00259">addSymbol()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>, <a class="el" href="old_2Translator_8h_source.html#l00207">getSymbol()</a>, and <a class="el" href="src_2cplus2asp_2utils_8h_source.html#l00088">utils::to_string()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00400">addSort()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01485">translateAlwaysLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01511">translateConstraintLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01796">translateIncrementLaw()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l01605">translateNonexecutableLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                                                                                                                  {</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    Element* ret = <a class="code" href="classTranslator.html#abd86b749727e0b5f5d5f8a6fac9bb7e7">getSymbol</a>(symName, arity);</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <span class="keywordflow">if</span> (!ret) {</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        ret = <span class="keyword">new</span> <a class="code" href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">Object</a>(symName, <a class="code" href="structsymbol.html#aafff7593df974a98ea04be2b7450091e">type</a>, <span class="keyword">internal</span>, arity);</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classTranslator.html#a915d7f328ae4d090a55309522275886c">addSymbol</a>(ret) != SymbolTable::ADDSYM_OK) {</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;            <span class="keyword">delete</span> ret;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        }</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret-&gt;getElemType() != Element::ELEM_OBJ) {</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;Detected conflicting definition of identifier \&quot;&quot;</span> + symName + <span class="stringliteral">&quot;/&quot;</span> + <a class="code" href="namespaceutils.html#a8f62b72e0def57deb33132dfd5d4a0ec">utils::to_string</a>(arity)+<span class="stringliteral">&quot;\&quot;.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    }</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    <span class="keywordflow">return</span> (<a class="code" href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">Object</a>*)ret;</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;}</div>
<div class="ttc" id="namespacebcplus_1_1elements_html_a5484f87e7a51fb686edfbd620d3a0804"><div class="ttname"><a href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">bcplus::elements::Object</a></div><div class="ttdeci">detail::IdentifierElement&lt; Term, detail::TermType::OBJECT, symbols::ObjectSymbol, Term &gt; Object</div><div class="ttdoc">An object constant &#39;t&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00172">terms.h:172</a></div></div>
<div class="ttc" id="classTranslator_html_a915d7f328ae4d090a55309522275886c"><div class="ttname"><a href="classTranslator.html#a915d7f328ae4d090a55309522275886c">Translator::addSymbol</a></div><div class="ttdeci">SymbolTable::SymTblResult addSymbol(Element *elem)</div><div class="ttdoc">Attempts to add a new symbol to the translator&#39;s data structures. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00259">Translator.h:259</a></div></div>
<div class="ttc" id="namespaceutils_html_a8f62b72e0def57deb33132dfd5d4a0ec"><div class="ttname"><a href="namespaceutils.html#a8f62b72e0def57deb33132dfd5d4a0ec">utils::to_string</a></div><div class="ttdeci">std::string to_string(T val, std::ios_base &amp;(*fmt)(std::ios_base &amp;)=std::dec, int precision=-1)</div><div class="ttdoc">Transforms something (usually a number) into a string representation of itself. </div><div class="ttdef"><b>Definition:</b> <a href="src_2cplus2asp_2utils_8h_source.html#l00088">utils.h:88</a></div></div>
<div class="ttc" id="classTranslator_html_a7c14268a49b3551907e27ba347d13e93"><div class="ttname"><a href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">Translator::error</a></div><div class="ttdeci">void error(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02076">Translator.cpp:2076</a></div></div>
<div class="ttc" id="structsymbol_html_aafff7593df974a98ea04be2b7450091e"><div class="ttname"><a href="structsymbol.html#aafff7593df974a98ea04be2b7450091e">symbol::type</a></div><div class="ttdeci">enum symbol_type type</div><div class="ttdef"><b>Definition:</b> <a href="as2transition_2lemon_2lemon_8c_source.html#l00248">lemon.c:248</a></div></div>
<div class="ttc" id="classTranslator_html_abd86b749727e0b5f5d5f8a6fac9bb7e7"><div class="ttname"><a href="classTranslator.html#abd86b749727e0b5f5d5f8a6fac9bb7e7">Translator::getSymbol</a></div><div class="ttdeci">Element * getSymbol(std::string const &amp;name, size_t arity=0)</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00207">Translator.h:207</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2f07647fcf8849ed861f4d3cdd0e20cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Query * Translator::getQuery </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>testLabel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a stored query with the given label in the translator's data structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">testLabel</td><td>- The label of the query to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first matching query with the given label, or NULL if a match isn't found. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00367">367</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00469">addQuery()</a>.</p>
<div class="fragment"><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;{</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    Query* retVal = NULL;</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="keywordflow">for</span>(std::list&lt;Query*&gt;::iterator qIter = queries.begin(); qIter != queries.end(); qIter++)</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    {</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;        <span class="keywordflow">if</span>((*qIter)-&gt;label == testLabel)</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        {</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;            retVal = *qIter;</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        }</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    }</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af8a229b868ba6ee176754ec2e342b6bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sort* Translator::getSort </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a sort identifier associated with the name/arity (or NULL);. </p>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00220">220</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00624">handleLUACall()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02037">setStaticTranslation()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00270">Translator()</a>.</p>
<div class="fragment"><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;                                                {</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        Element *elem;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        <span class="keywordflow">return</span> (Sort*)(((elem = mSymbolTable.findSymbol(<a class="code" href="structsymbol.html#a6230a18d2907cfebc06f3e66599bba89">name</a>, 0)) &amp;&amp; elem-&gt;getElemType() == Element::ELEM_SORT) ? elem : NULL); </div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    }</div>
<div class="ttc" id="structsymbol_html_a6230a18d2907cfebc06f3e66599bba89"><div class="ttname"><a href="structsymbol.html#a6230a18d2907cfebc06f3e66599bba89">symbol::name</a></div><div class="ttdeci">const char * name</div><div class="ttdef"><b>Definition:</b> <a href="as2transition_2lemon_2lemon_8c_source.html#l00246">lemon.c:246</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abd86b749727e0b5f5d5f8a6fac9bb7e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Element* Translator::getSymbol </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00207">207</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00400">addSort()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01965">createInternalObject()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00382">getOrCreateObject()</a>.</p>
<div class="fragment"><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;{ <span class="keywordflow">return</span> mSymbolTable.findSymbol(<a class="code" href="structsymbol.html#a6230a18d2907cfebc06f3e66599bba89">name</a>, arity); }</div>
<div class="ttc" id="structsymbol_html_a6230a18d2907cfebc06f3e66599bba89"><div class="ttname"><a href="structsymbol.html#a6230a18d2907cfebc06f3e66599bba89">symbol::name</a></div><div class="ttdeci">const char * name</div><div class="ttdef"><b>Definition:</b> <a href="as2transition_2lemon_2lemon_8c_source.html#l00246">lemon.c:246</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="add6f7aec671147c3ce4f2cd1e05ddcb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Variable* Translator::getVariable </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a variable identifier associated with the name/arity (or NULL);. </p>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00225">225</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;                                                        {</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        Element *elem;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        <span class="keywordflow">return</span> (<a class="code" href="namespacebcplus_1_1elements.html#a3e6f840af4a14452b75d90ee8ada34f3">Variable</a>*)(((elem = mSymbolTable.findSymbol(<a class="code" href="structsymbol.html#a6230a18d2907cfebc06f3e66599bba89">name</a>, 0)) &amp;&amp; elem-&gt;getElemType() == Element::ELEM_VAR) ? elem : NULL); </div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    }</div>
<div class="ttc" id="structsymbol_html_a6230a18d2907cfebc06f3e66599bba89"><div class="ttname"><a href="structsymbol.html#a6230a18d2907cfebc06f3e66599bba89">symbol::name</a></div><div class="ttdeci">const char * name</div><div class="ttdef"><b>Definition:</b> <a href="as2transition_2lemon_2lemon_8c_source.html#l00246">lemon.c:246</a></div></div>
<div class="ttc" id="namespacebcplus_1_1elements_html_a3e6f840af4a14452b75d90ee8ada34f3"><div class="ttname"><a href="namespacebcplus_1_1elements.html#a3e6f840af4a14452b75d90ee8ada34f3">bcplus::elements::Variable</a></div><div class="ttdeci">detail::IdentifierElement_bare&lt; Term, detail::TermType::VARIABLE, symbols::VariableSymbol &gt; Variable</div><div class="ttdoc">A variable &#39;V&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00180">terms.h:180</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5b0211f521a042860033e17aa451da1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::handleLUACall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classObjectLikeElement.html">ObjectLikeElement</a> const *&#160;</td>
          <td class="paramname"><em>lua_elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles a LUA call by adding the result to the computed sort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lua_elem</td><td>The lua call to handle. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00624">624</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00220">getSort()</a>, <a class="el" href="old_2Translator_8h_source.html#l00709">lang()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02260">output()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02140">outputClauses()</a>, and <a class="el" href="parser__types_8cpp_source.html#l01204">ObjectLikeElement::translate()</a>.</p>
<div class="fragment"><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                                                                {</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;    StmtList stmts;</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;    Sort *sortObj = <a class="code" href="classTranslator.html#af8a229b868ba6ee176754ec2e342b6bd">getSort</a>(<span class="stringliteral">&quot;computed&quot;</span>);</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    <a class="code" href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">ClauseList</a> extraClauses, freeVars;</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    Context c(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_MAXIMIZED_INTERNAL, IPart::IPART_BASE, Context::BASE_STR, &amp;extraClauses, &amp;freeVars, <span class="keyword">false</span>, <span class="keyword">true</span>, &amp;stmts);</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    std::stringstream stmtBuilder;                  <span class="comment">// Used to build each individual statement required for this declaration.</span></div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;    stmtBuilder &lt;&lt; sortObj-&gt;fullTransName() &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;    lua_elem-&gt;translate(stmtBuilder, c);</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;    stmtBuilder &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;    </div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;    <span class="keywordflow">if</span> (extraClauses.size()) {</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;        stmtBuilder &lt;&lt; <span class="stringliteral">&quot; &lt;- &quot;</span>;</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;        <a class="code" href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">outputClauses</a>(stmtBuilder, extraClauses, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;    }</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    </div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;    stmtBuilder &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;    <span class="comment">// Output the statement</span></div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>(stmtBuilder.str(), IPART_BASE, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;}</div>
<div class="ttc" id="namespacecplus2asp_1_1cplus2asp__bin_html_a2fbffbd697b2a504d23669a23961be4b"><div class="ttname"><a href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">cplus2asp::cplus2asp_bin::ClauseList</a></div><div class="ttdeci">ReferencedList&lt; std::string &gt;::type ClauseList</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00027">types.h:27</a></div></div>
<div class="ttc" id="classTranslator_html_af8a229b868ba6ee176754ec2e342b6bd"><div class="ttname"><a href="classTranslator.html#af8a229b868ba6ee176754ec2e342b6bd">Translator::getSort</a></div><div class="ttdeci">Sort * getSort(std::string const &amp;name)</div><div class="ttdoc">Finds a sort identifier associated with the name/arity (or NULL);. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00220">Translator.h:220</a></div></div>
<div class="ttc" id="classTranslator_html_a2973b80adebf80f00ca209502465f8e5"><div class="ttname"><a href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">Translator::outputClauses</a></div><div class="ttdeci">static std::ostream &amp; outputClauses(std::ostream &amp;out, ClauseList const &amp;clauses, bool initConj=false)</div><div class="ttdoc">helper method to output multiple clauses to an output stream. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02140">Translator.cpp:2140</a></div></div>
<div class="ttc" id="classTranslator_html_a864d4dc33098092fef562455dc97c9e2"><div class="ttname"><a href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">Translator::lang</a></div><div class="ttdeci">Language lang() const </div><div class="ttdoc">Gets the currently active language. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00709">Translator.h:709</a></div></div>
<div class="ttc" id="classTranslator_html_acbb634f19ffb6d601eae8ad032d72ce9"><div class="ttname"><a href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">Translator::output</a></div><div class="ttdeci">void output(std::string const &amp;str, IPart incPart, bool endWithNewline=false)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02260">Translator.cpp:2260</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae23c8af9b2cc9ecd17bb6e9ccb9401ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::hasFoundAbnormalities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the translator has encountered any abnormality constants. </p>
<dl class="section return"><dt>Returns</dt><dd>True if one or more static or dynamic abnormalities have been declared. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00198">198</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;{ <span class="keywordflow">return</span> blnFoundAbnormalities; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a435e80a2c5794cf19c4627b1dd354eb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::hasFoundAdditiveConstants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the translator has encountered any additive constants. </p>
<dl class="section return"><dt>Returns</dt><dd>True if one or more additive constants have been declared. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00204">204</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;{ <span class="keywordflow">return</span> blnFoundAdditive; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a864d4dc33098092fef562455dc97c9e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Language Translator::lang </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the currently active language. </p>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00709">709</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00624">handleLUACall()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01236">makeCausalTranslation()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01420">makeShowStmt()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02037">setStaticTranslation()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00737">translateQuery()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00270">Translator()</a>.</p>
<div class="fragment"><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;{ <span class="keywordflow">return</span> mLanguage; }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac6696248ca5c08d2fa8df07838d63e1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Translator::makeCausalTranslation </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StmtList &amp;&#160;</td>
          <td class="paramname"><em>extraStmts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IPart&#160;</td>
          <td class="paramname"><em>ipart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>assumingNotNot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>baseTimeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>ifBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>assumingBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>unlessBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>afterBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function for translating causal laws. </p>
<p>Called by translateCausalLaw </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output[out]</td><td>- The output stream to write the generated translation to. </td></tr>
    <tr><td class="paramname">extraStmts[out]</td><td>- A list of extra statments generated by translating this law. </td></tr>
    <tr><td class="paramname">ipart</td><td>- The incremental part that this law belongs to. </td></tr>
    <tr><td class="paramname">assumingNotNot</td><td>- Whether the rule's assumingBody needs to be wrapped in double negation. </td></tr>
    <tr><td class="paramname">baseTimeStamp</td><td>- The timestamp to use for the translated law. </td></tr>
    <tr><td class="paramname">head</td><td>- The head portion of the causal law ("caused head..."). </td></tr>
    <tr><td class="paramname">ifBody</td><td>- The part of the law's body associated with the if keyword ("...if ifBody..."). </td></tr>
    <tr><td class="paramname">assumingBody</td><td>- The part of the law's body associated with the if keyword ("...assuming ifBody..."). </td></tr>
    <tr><td class="paramname">unlessBody</td><td>- The part of the law's body associated with the unless keyword ("...unless unlessBody..."). </td></tr>
    <tr><td class="paramname">afterBody</td><td>- The part of the law's body associated with the after keyword ("...after afterBody..."). </td></tr>
    <tr><td class="paramname">whereBody</td><td>- The part of the law's body associated with the where keyword ("...where whereBody."). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>If head and ifBody are: not NULL, both const-like or both UOP_NOT(const-like), make a choice rule out of head and translate that. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01236">1236</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02150">bindAndTranslate()</a>, <a class="el" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants()</a>, <a class="el" href="old_2Translator_8h_source.html#l00709">lang()</a>, <a class="el" href="parser__types_8h_source.html#l00084">ParseElement::MASK_ACTION</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02260">output()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02140">outputClauses()</a>, and <a class="el" href="classParseElement.html#ac6eaa4986aba513b3f0064c878dd6caa">ParseElement::translate()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;{</div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;    <a class="code" href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">ClauseList</a> localClauses;</div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;    Context localContext;</div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;    <span class="keywordtype">bool</span> bodyContent = <span class="keyword">false</span>;       <span class="comment">// true if the law&#39;s body has any content to-date.</span></div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;</div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;    std::string actionTimeStamp = baseTimeStamp + <span class="stringliteral">&quot;-1&quot;</span>;</div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;</div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;    <span class="comment">// Translate!</span></div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;</div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;    <span class="comment">// The head</span></div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;<span class="comment"></span></div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;    localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_HEAD, ipart, baseTimeStamp, &amp;localClauses, NULL, <span class="keyword">false</span>, <span class="keyword">true</span>, &amp;extraStmts);</div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;    <a class="code" href="classTranslator.html#a0d2965d026bb2cfb15f62b533beaa155">bindAndTranslate</a>(<a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>, head, localContext, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;</div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;    <span class="comment">// The body, if there is one.</span></div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;    <span class="keywordflow">if</span>(ifBody</div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;            || assumingBody</div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;            || unlessBody</div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;            || afterBody</div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;            || whereBody</div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;            || localClauses.size() &gt; 0)</div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;    {</div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;        <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot; &lt;- &quot;</span>;</div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;</div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;        <span class="comment">// head clauses should be placed in the scope of double negation.</span></div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;        <span class="keywordflow">if</span> (localClauses.size()) {</div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;            bodyContent = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;            <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot;not not (&quot;</span>;</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;            <a class="code" href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">outputClauses</a>(<a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>, localClauses, <span class="keyword">false</span>);</div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;            <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;            localClauses.clear();</div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;</div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;        }</div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;</div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;        <span class="comment">// &quot;if&quot; part of body, if there is one.</span></div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;        <span class="keywordflow">if</span>(ifBody)</div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;        {</div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;            <span class="keywordflow">if</span>(bodyContent) <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot; &amp; &quot;</span>;</div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;            <span class="keywordflow">else</span> bodyContent = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;</div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;            <span class="comment">// If we&#39;re translating a law that needs a &quot;not not (...)&quot; body wrapper to break cycles, add it.</span></div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;            localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_BODY, ipart, baseTimeStamp, &amp;localClauses, NULL, <span class="keyword">false</span>, <span class="keyword">false</span>, &amp;extraStmts);</div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;            ifBody-&gt;<a class="code" href="classParseElement.html#ac6eaa4986aba513b3f0064c878dd6caa">translate</a>(<a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>, localContext);</div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;        }</div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;</div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;        <span class="comment">// &quot;assuming&quot; part of body, if there is one.</span></div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;        <span class="keywordflow">if</span>(assumingBody)</div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;        {</div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;            <span class="comment">// add a connective if necessary.</span></div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;            <span class="keywordflow">if</span>(bodyContent) <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot; &amp; &quot;</span>;</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;            <span class="keywordflow">else</span> bodyContent = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;</div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;            <span class="comment">// If we&#39;re translating a law that needs a &quot;not not (...)&quot; body wrapper to break cycles, add it.</span></div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;            <span class="keywordflow">if</span>(assumingNotNot) {</div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;                <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot;not not (&quot;</span>;</div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;                localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_BODY, ipart, baseTimeStamp, NULL, NULL, <span class="keyword">true</span>, <span class="keyword">false</span>, &amp;extraStmts);</div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;                <a class="code" href="classTranslator.html#a0d2965d026bb2cfb15f62b533beaa155">bindAndTranslate</a>(<a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>, assumingBody, localContext, <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;                <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;            }</div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;            <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;                localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_BODY, ipart, baseTimeStamp, &amp;localClauses, NULL, <span class="keyword">false</span>, <span class="keyword">false</span>, &amp;extraStmts);</div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;                assumingBody-&gt;<a class="code" href="classParseElement.html#ac6eaa4986aba513b3f0064c878dd6caa">translate</a>(<a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>, localContext);</div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;            }</div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;        }</div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;</div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;        <span class="comment">// &quot;unless&quot; part of body, if there is one.</span></div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;        <span class="keywordflow">if</span>(unlessBody)</div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;        {</div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;            <span class="comment">// add a connective if necessary.</span></div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;            <span class="keywordflow">if</span>(bodyContent) <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot; &amp; &quot;</span>;</div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;            <span class="keywordflow">else</span> bodyContent = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;</div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;            <span class="comment">// Translate the unless body wrapped in negation.</span></div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;            <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot;not (&quot;</span>;</div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;</div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;            std::string tmp = </div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;                    unlessBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>)</div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;                            ? dynamicTimeStamp + <span class="stringliteral">&quot;-1&quot;</span></div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;                            : staticTimeStamp; </div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;</div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;            localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_BODY, ipart, tmp,</div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;                    NULL, NULL, <span class="keyword">true</span>, <span class="keyword">false</span>, &amp;extraStmts);</div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;            <a class="code" href="classTranslator.html#a0d2965d026bb2cfb15f62b533beaa155">bindAndTranslate</a>(<a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>, unlessBody, localContext, <span class="keyword">false</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;            <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;        }</div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;</div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;        <span class="comment">// &quot;after&quot; part of body, if there is one.</span></div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;        <span class="keywordflow">if</span>(afterBody)</div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;        {</div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;            <span class="comment">// add a connective if necessary.</span></div>
<div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;            <span class="keywordflow">if</span>(bodyContent) <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot; &amp; &quot;</span>;</div>
<div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;            <span class="keywordflow">else</span> bodyContent = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;</div>
<div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;            <span class="comment">// If we&#39;re translating a law that needs a &quot;not not (...)&quot; body wrapper to break cycles, add it.</span></div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;<span class="comment">//          if(afterNotNot) {</span></div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;<span class="comment">//              output &lt;&lt; &quot;not not (&quot;;</span></div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="comment">//              localContext = Context(Context::POS_BODY, ipart, actionTimeStamp, NULL, NULL, true, false, &amp;extraStmts);</span></div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="comment">//              bindAndTranslate(output, afterBody, localContext, false, true);</span></div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;<span class="comment">//              output &lt;&lt; &quot;)&quot;;</span></div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;<span class="comment">//          }</span></div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;<span class="comment">//          else {</span></div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;                localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_BODY, ipart, actionTimeStamp, &amp;localClauses, NULL, <span class="keyword">false</span>, <span class="keyword">false</span>, &amp;extraStmts);</div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;                afterBody-&gt;<a class="code" href="classParseElement.html#ac6eaa4986aba513b3f0064c878dd6caa">translate</a>(<a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>, localContext);</div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;<span class="comment">//          }</span></div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;</div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;        }</div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;        </div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;</div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;        <span class="comment">// &quot;where&quot; part of body, if there is one.</span></div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;        <span class="keywordflow">if</span>(whereBody)</div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;        {</div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;            <span class="comment">// add a connective if necessary</span></div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;            <span class="keywordflow">if</span>(bodyContent) <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot; &amp; &quot;</span>;</div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;            <span class="keywordflow">else</span> bodyContent = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;            localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_BODY, ipart, baseTimeStamp, &amp;localClauses, NULL, <span class="keyword">false</span>, <span class="keyword">false</span>, &amp;extraStmts);</div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;            whereBody-&gt;<a class="code" href="classParseElement.html#ac6eaa4986aba513b3f0064c878dd6caa">translate</a>(<a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>, localContext);</div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;        }</div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;        </div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;        <span class="comment">// handle extra clauses</span></div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;        <a class="code" href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">outputClauses</a>(<a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>, localClauses, bodyContent);</div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;    }</div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;    <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a> &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;</div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>;</div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;}</div>
<div class="ttc" id="classParseElement_html_ac6eaa4986aba513b3f0064c878dd6caa"><div class="ttname"><a href="classParseElement.html#ac6eaa4986aba513b3f0064c878dd6caa">ParseElement::translate</a></div><div class="ttdeci">virtual std::ostream &amp; translate(std::ostream &amp;out, Context &amp;context) const =0</div><div class="ttdoc">Method that generates a translated string representation of the element with preceeding @ if a symbol...</div></div>
<div class="ttc" id="namespacecplus2asp_1_1cplus2asp__bin_html_a2fbffbd697b2a504d23669a23961be4b"><div class="ttname"><a href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">cplus2asp::cplus2asp_bin::ClauseList</a></div><div class="ttdeci">ReferencedList&lt; std::string &gt;::type ClauseList</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00027">types.h:27</a></div></div>
<div class="ttc" id="classTranslator_html_a0d2965d026bb2cfb15f62b533beaa155"><div class="ttname"><a href="classTranslator.html#a0d2965d026bb2cfb15f62b533beaa155">Translator::bindAndTranslate</a></div><div class="ttdeci">static std::ostream &amp; bindAndTranslate(std::ostream &amp;out, ParseElement const *expr, Context &amp;context, bool upwardMobileClauses, bool suppressQuantifier=false)</div><div class="ttdoc">helper method to translate a sub expression, capturing all of its clauses and variables in the meanwh...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02150">Translator.cpp:2150</a></div></div>
<div class="ttc" id="classTranslator_html_a2973b80adebf80f00ca209502465f8e5"><div class="ttname"><a href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">Translator::outputClauses</a></div><div class="ttdeci">static std::ostream &amp; outputClauses(std::ostream &amp;out, ClauseList const &amp;clauses, bool initConj=false)</div><div class="ttdoc">helper method to output multiple clauses to an output stream. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02140">Translator.cpp:2140</a></div></div>
<div class="ttc" id="classParseElement_html_aa0ff7094f640ccd042bb7fa636a5028d"><div class="ttname"><a href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants</a></div><div class="ttdeci">virtual bool hasConstants(unsigned int types, bool includeParams=true, bool includeEq=true) const =0</div><div class="ttdoc">Returns true if the element (or any of its children) are constants of the provided types...</div></div>
<div class="ttc" id="classTranslator_html_a864d4dc33098092fef562455dc97c9e2"><div class="ttname"><a href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">Translator::lang</a></div><div class="ttdeci">Language lang() const </div><div class="ttdoc">Gets the currently active language. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00709">Translator.h:709</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00084">parser_types.h:84</a></div></div>
<div class="ttc" id="classTranslator_html_acbb634f19ffb6d601eae8ad032d72ce9"><div class="ttname"><a href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">Translator::output</a></div><div class="ttdeci">void output(std::string const &amp;str, IPart incPart, bool endWithNewline=false)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02260">Translator.cpp:2260</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab7c3fc88127578322d7065dd89ab54f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::makeShowStmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StmtList &amp;&#160;</td>
          <td class="paramname"><em>stmts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Variable const *&#160;</td>
          <td class="paramname"><em>eql</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a '#show' statement for the provided element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">elem</td><td>The atomic formula to construct the show statement for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stmts</td><td>The list to add the resulting statement to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">eql</td><td>The variable to set the constant to (required if elem is a bare constant). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01420">1420</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants()</a>, <a class="el" href="old_2Translator_8h_source.html#l00709">lang()</a>, <a class="el" href="parser__types_8h_source.html#l00084">ParseElement::MASK_ACTION</a>, and <a class="el" href="classParseElement.html#ac6eaa4986aba513b3f0064c878dd6caa">ParseElement::translate()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l01378">translateShowStmt()</a>.</p>
<div class="fragment"><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;                                                                                      {</div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;    Context localContext;</div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;    <span class="keywordtype">bool</span> <a class="code" href="structaction.html">action</a> = elem-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>); </div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;    std::stringstream tmp;</div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;</div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;    <span class="keywordflow">if</span> (!action) {</div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;        <span class="keywordflow">if</span> (eql) localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_BODY, IPART_BASE, Context::BASE_STR, eql-&gt;fullTransName(), NULL, NULL, <span class="keyword">false</span>, <span class="keyword">false</span>, &amp;stmts);</div>
<div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;        <span class="keywordflow">else</span> localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_BODY, IPART_BASE, Context::BASE_STR, NULL, NULL, <span class="keyword">false</span>, <span class="keyword">false</span>, &amp;stmts);</div>
<div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;        tmp &lt;&lt; <span class="stringliteral">&quot;#show &quot;</span>;</div>
<div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;        elem-&gt;<a class="code" href="classParseElement.html#ac6eaa4986aba513b3f0064c878dd6caa">translate</a>(tmp, localContext);</div>
<div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;        tmp &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;        stmts.push_back(Statement(tmp.str(), IPART_BASE));</div>
<div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;        tmp.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;    }</div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;</div>
<div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;</div>
<div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;    tmp &lt;&lt; dynamicTimeStamp;</div>
<div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;    <span class="keywordflow">if</span> (action) tmp &lt;&lt; <span class="stringliteral">&quot;-1&quot;</span>;</div>
<div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;    std::string tmpstr = tmp.str();</div>
<div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;</div>
<div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;</div>
<div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;    <span class="keywordflow">if</span> (eql) localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_BODY, IPART_CUMULATIVE, </div>
<div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;        tmpstr, </div>
<div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;        eql-&gt;fullTransName(), NULL, NULL, <span class="keyword">false</span>, <span class="keyword">false</span>, &amp;stmts);</div>
<div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;    <span class="keywordflow">else</span> localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(), Context::POS_BODY, IPART_CUMULATIVE, </div>
<div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;        tmpstr, </div>
<div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;        <span class="stringliteral">&quot;&quot;</span>, NULL, NULL, <span class="keyword">false</span>, <span class="keyword">false</span>, &amp;stmts);</div>
<div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;    </div>
<div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;    tmp.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;    tmp &lt;&lt; <span class="stringliteral">&quot;#show &quot;</span>;</div>
<div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;    elem-&gt;<a class="code" href="classParseElement.html#ac6eaa4986aba513b3f0064c878dd6caa">translate</a>(tmp, localContext);</div>
<div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;    tmp &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;    stmts.push_back(Statement(tmp.str(), IPART_CUMULATIVE));</div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;</div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;</div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;}</div>
<div class="ttc" id="classParseElement_html_ac6eaa4986aba513b3f0064c878dd6caa"><div class="ttname"><a href="classParseElement.html#ac6eaa4986aba513b3f0064c878dd6caa">ParseElement::translate</a></div><div class="ttdeci">virtual std::ostream &amp; translate(std::ostream &amp;out, Context &amp;context) const =0</div><div class="ttdoc">Method that generates a translated string representation of the element with preceeding @ if a symbol...</div></div>
<div class="ttc" id="structaction_html"><div class="ttname"><a href="structaction.html">action</a></div><div class="ttdef"><b>Definition:</b> <a href="as2transition_2lemon_2lemon_8c_source.html#l00323">lemon.c:323</a></div></div>
<div class="ttc" id="classParseElement_html_aa0ff7094f640ccd042bb7fa636a5028d"><div class="ttname"><a href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants</a></div><div class="ttdeci">virtual bool hasConstants(unsigned int types, bool includeParams=true, bool includeEq=true) const =0</div><div class="ttdoc">Returns true if the element (or any of its children) are constants of the provided types...</div></div>
<div class="ttc" id="classTranslator_html_a864d4dc33098092fef562455dc97c9e2"><div class="ttname"><a href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">Translator::lang</a></div><div class="ttdeci">Language lang() const </div><div class="ttdoc">Gets the currently active language. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00709">Translator.h:709</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00084">parser_types.h:84</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab915f8be91fb2110489b250a1427be0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParseElement.html">ParseElement</a> * Translator::mergeSubFormulas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sub-formulas together into one formula using an AND operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>- The first sub-formula of the pair. </td></tr>
    <tr><td class="paramname">second</td><td>- The second sub-formula of the pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dynamically-declared <a class="el" href="classParseElement.html" title="General parent of all self-contained, self-translating parse tree elements. ">ParseElement</a> pointer represnting the merging of the two sub-formulas. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00262">262</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="parser__types_8h_source.html#l00344">SimpleBinaryOperator::BOP_AND</a>.</p>
<div class="fragment"><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;{</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(first, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, second);</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;}</div>
<div class="ttc" id="classSimpleBinaryOperator_html_a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5"><div class="ttname"><a href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00344">parser_types.h:344</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html"><div class="ttname"><a href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a></div><div class="ttdoc">Child of ParseElement that represents a binary operator and the associated elements it operates on...</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00330">parser_types.h:330</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a88da67abf1048c89bf7b18599a6c2ae1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Translator::numRangeToSortName </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a standardized sort name representing a range of numbers. </p>
<p>Needed when a number range is given as the binding sort of certain declarations. Uses a consistent naming convention, so calling it twice on the same range produces identical results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>- The lower bound of the range. </td></tr>
    <tr><td class="paramname">max</td><td>- The upper bound of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A representation of the number range suitable for use as a sort name, or "" (blank) on an error. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00227">227</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l00059">NUMRANGE_TO_SORT_PREFIX</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00184">sanitizeString()</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;{</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    std::string tempStr = <a class="code" href="old_2Translator_8cpp.html#ac10826067766f03b8192ee7335034544">NUMRANGE_TO_SORT_PREFIX</a>;</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    tempStr += Context::ANON_STR;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    tempStr += <a class="code" href="classTranslator.html#a95b7912d06f7d0e6378ccd8cc586e80d">Translator::sanitizeString</a>(min);</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    tempStr += Context::ANON_STR;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    tempStr += <a class="code" href="classTranslator.html#a95b7912d06f7d0e6378ccd8cc586e80d">Translator::sanitizeString</a>(max);</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="keywordflow">return</span> tempStr;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_a95b7912d06f7d0e6378ccd8cc586e80d"><div class="ttname"><a href="classTranslator.html#a95b7912d06f7d0e6378ccd8cc586e80d">Translator::sanitizeString</a></div><div class="ttdeci">static std::string sanitizeString(std::string const &amp;originalString)</div><div class="ttdoc">Transforms an arbitrary string such that the result will be compatible with ASP object/predicate nami...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00184">Translator.cpp:184</a></div></div>
<div class="ttc" id="old_2Translator_8cpp_html_ac10826067766f03b8192ee7335034544"><div class="ttname"><a href="old_2Translator_8cpp.html#ac10826067766f03b8192ee7335034544">NUMRANGE_TO_SORT_PREFIX</a></div><div class="ttdeci">#define NUMRANGE_TO_SORT_PREFIX</div><div class="ttdoc">When converting a number range to a sort name, this is the prefix that will be attached. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00059">Translator.cpp:59</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acbb634f19ffb6d601eae8ad032d72ce9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::output </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IPart&#160;</td>
          <td class="paramname"><em>incPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endWithNewline</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the contents of str to wherever the translator's output stream is aimed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The text to output. </td></tr>
    <tr><td class="paramname">incPart</td><td>- The Incremental part that the chunk is associated with. </td></tr>
    <tr><td class="paramname">endWithNewline</td><td>- If true, will append a newline character to the end of str. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02260">2260</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02233">setIncrementalPart()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00624">handleLUACall()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01236">makeCausalTranslation()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02266">outputStmts()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02233">setIncrementalPart()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00594">translateObjectDecl()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00708">translateSubsortDecl()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00728">translateVariableDecl()</a>.</p>
<div class="fragment"><div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;                                                                              {</div>
<div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;    <span class="keywordflow">if</span> (mCurrentPart != ipart) <a class="code" href="classTranslator.html#a4e900621c5444895355f0c957f44618c">setIncrementalPart</a>(ipart);</div>
<div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160;    <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>(str, endWithNewline);</div>
<div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_a4e900621c5444895355f0c957f44618c"><div class="ttname"><a href="classTranslator.html#a4e900621c5444895355f0c957f44618c">Translator::setIncrementalPart</a></div><div class="ttdeci">bool setIncrementalPart(IPart newIncPart)</div><div class="ttdoc">Sets incremental part to the provided part, outputting the appropriate clause to the translation outp...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02233">Translator.cpp:2233</a></div></div>
<div class="ttc" id="classTranslator_html_acbb634f19ffb6d601eae8ad032d72ce9"><div class="ttname"><a href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">Translator::output</a></div><div class="ttdeci">void output(std::string const &amp;str, IPart incPart, bool endWithNewline=false)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02260">Translator.cpp:2260</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adf3b8ac556462ee55d4a3d1b2bdadb61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::output </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endWithNewline</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the contents of str to wherever the translator's output stream is aimed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The text to output. </td></tr>
    <tr><td class="paramname">endWithNewline</td><td>- If true, will append a newline character to the end of str. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02066">2066</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;{</div>
<div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;    (*ostOutPtr) &lt;&lt; str;</div>
<div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;    <span class="keywordflow">if</span>(endWithNewline)</div>
<div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;    {</div>
<div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;        (*ostOutPtr) &lt;&lt; std::endl;</div>
<div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;    }</div>
<div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2973b80adebf80f00ca209502465f8e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Translator::outputClauses </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClauseList const &amp;&#160;</td>
          <td class="paramname"><em>clauses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initConj</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper method to output multiple clauses to an output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>- The stream to output to. </td></tr>
    <tr><td class="paramname">clauses</td><td>- The clauses to print. </td></tr>
    <tr><td class="paramname">initConj</td><td>- Whether to output an initial conjunction symbol before the clauses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02140">2140</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l02150">bindAndTranslate()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00624">handleLUACall()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01236">makeCausalTranslation()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00496">translateConstantDecl()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00594">translateObjectDecl()</a>.</p>
<div class="fragment"><div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;                                                                                               {</div>
<div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;    <span class="keywordflow">if</span> (initConj &amp;&amp; !clauses.empty()) out &lt;&lt; <span class="stringliteral">&quot; &amp; &quot;</span>;</div>
<div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;    <span class="keywordflow">for</span> (std::list&lt;std::string&gt;::const_iterator it = clauses.begin(); it != clauses.end(); ) {</div>
<div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;        out &lt;&lt; *it;</div>
<div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;        <span class="keywordflow">if</span> (++it != clauses.end()) out &lt;&lt; <span class="stringliteral">&quot; &amp; &quot;</span>;</div>
<div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;    }</div>
<div class="line"><a name="l02146"></a><span class="lineno"> 2146</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa6bd93433890d0eb1c9d2fc0090a03bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::outputFooter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends any statements that have been witheld for the footer to the translated program. </p>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00551">551</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02266">outputStmts()</a>.</p>
<div class="fragment"><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;{ <a class="code" href="classTranslator.html#a2c7447c0464738a176c4cc5f05397dfa">outputStmts</a>(mFooterStmts); }</div>
<div class="ttc" id="classTranslator_html_a2c7447c0464738a176c4cc5f05397dfa"><div class="ttname"><a href="classTranslator.html#a2c7447c0464738a176c4cc5f05397dfa">Translator::outputStmts</a></div><div class="ttdeci">void outputStmts(StmtList const &amp;stmts)</div><div class="ttdoc">Outputs a list of statements to the translators output. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02266">Translator.cpp:2266</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2c7447c0464738a176c4cc5f05397dfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::outputStmts </td>
          <td>(</td>
          <td class="paramtype">StmtList const &amp;&#160;</td>
          <td class="paramname"><em>stmts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a list of statements to the translators output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmts</td><td>- The statements to print. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02266">2266</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02260">output()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8h_source.html#l00551">outputFooter()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00496">translateConstantDecl()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00737">translateQuery()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00651">translateSortDecl()</a>.</p>
<div class="fragment"><div class="line"><a name="l02266"></a><span class="lineno"> 2266</span>&#160;                                                  {</div>
<div class="line"><a name="l02267"></a><span class="lineno"> 2267</span>&#160;    <span class="keywordflow">for</span> (StmtList::const_iterator it = stmts.begin(); it != stmts.end(); it++) {</div>
<div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;        <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>(it-&gt;first, it-&gt;second, <span class="keyword">true</span>);</div>
<div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;    }</div>
<div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_acbb634f19ffb6d601eae8ad032d72ce9"><div class="ttname"><a href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">Translator::output</a></div><div class="ttdeci">void output(std::string const &amp;str, IPart incPart, bool endWithNewline=false)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02260">Translator.cpp:2260</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad0a621cce440c35279f1a4de95d0cad1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Translator::outputSymbolTable </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instructs the translator to output its symbol table to the specified location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output stream to dump the symbol table to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02273">2273</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="src_2cplus2asp_2utils_8h_source.html#l00088">utils::to_string()</a>.</p>
<div class="fragment"><div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;                                                               {</div>
<div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;    <span class="keyword">using</span> boost::property_tree::ptree;</div>
<div class="line"><a name="l02275"></a><span class="lineno"> 2275</span>&#160;</div>
<div class="line"><a name="l02276"></a><span class="lineno"> 2276</span>&#160;    ptree table, *node, *node2;</div>
<div class="line"><a name="l02277"></a><span class="lineno"> 2277</span>&#160;    std::string loc;</div>
<div class="line"><a name="l02278"></a><span class="lineno"> 2278</span>&#160;    boost::property_tree::xml_writer_settings&lt;char&gt; settings(<span class="charliteral">&#39;\t&#39;</span>, 1);</div>
<div class="line"><a name="l02279"></a><span class="lineno"> 2279</span>&#160;</div>
<div class="line"><a name="l02280"></a><span class="lineno"> 2280</span>&#160;</div>
<div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;    <span class="keywordflow">for</span> (Element <span class="keyword">const</span>* s : mSymbolTable) {</div>
<div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160;        <span class="comment">// ignore all internal symbols</span></div>
<div class="line"><a name="l02283"></a><span class="lineno"> 2283</span>&#160;        <span class="keywordflow">if</span> (s-&gt;internal()) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l02284"></a><span class="lineno"> 2284</span>&#160;    </div>
<div class="line"><a name="l02285"></a><span class="lineno"> 2285</span>&#160;        loc = <span class="stringliteral">&quot;symbols.&quot;</span> + Element::elemTypeToString(s-&gt;getElemType()) + <span class="stringliteral">&quot;s&quot;</span>;</div>
<div class="line"><a name="l02286"></a><span class="lineno"> 2286</span>&#160;</div>
<div class="line"><a name="l02287"></a><span class="lineno"> 2287</span>&#160;</div>
<div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;        <span class="keywordflow">switch</span> (s-&gt;getElemType()) {</div>
<div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;        <span class="keywordflow">case</span> Element::ELEM_CONST:</div>
<div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;            loc += <span class="stringliteral">&quot;.&quot;</span> ;</div>
<div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;            <span class="keywordflow">if</span> (((<a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a>*)s)-&gt;isAction())</div>
<div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;                loc += <span class="stringliteral">&quot;actions.&quot;</span>;</div>
<div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((<a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a>*)s)-&gt;isFluent())</div>
<div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;                loc += <span class="stringliteral">&quot;fluents.&quot;</span>;</div>
<div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((<a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a>*)s)-&gt;isAbnormal())</div>
<div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;                loc += <span class="stringliteral">&quot;abnormalities.&quot;</span>;</div>
<div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;                loc += <span class="stringliteral">&quot;unknown.&quot;</span>;</div>
<div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;            loc += ((<a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a>*)s)-&gt;constTypeStr();</div>
<div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;</div>
<div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;            node = &amp;table.add(loc, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;</div>
<div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;            node-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.name&quot;</span>, s-&gt;baseName());</div>
<div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;            node-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.arity&quot;</span>, s-&gt;arity());</div>
<div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;            node-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.trans_name&quot;</span>, s-&gt;baseTransName());</div>
<div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160;</div>
<div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;</div>
<div class="line"><a name="l02308"></a><span class="lineno"> 2308</span>&#160;            <span class="keywordflow">if</span> (((<a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a>*)s)-&gt;constType() == Constant::CONST_ATTRIBUTE) {</div>
<div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;                node-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.parent&quot;</span>, ((Attribute*)s)-&gt;parent()-&gt;baseName()</div>
<div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160;                    + <span class="stringliteral">&quot;/&quot;</span> + <a class="code" href="namespaceutils.html#a8f62b72e0def57deb33132dfd5d4a0ec">utils::to_string</a>(((Attribute*)s)-&gt;parent()-&gt;arity()));</div>
<div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;            }</div>
<div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;</div>
<div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160;</div>
<div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160;        <span class="keywordflow">case</span> Element::ELEM_VAR:</div>
<div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160;            loc += <span class="stringliteral">&quot;.&quot;</span> + Element::elemTypeToString(s-&gt;getElemType()); </div>
<div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160;            node = &amp;table.add(loc, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;</div>
<div class="line"><a name="l02319"></a><span class="lineno"> 2319</span>&#160;            node-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.name&quot;</span>, s-&gt;baseName());</div>
<div class="line"><a name="l02320"></a><span class="lineno"> 2320</span>&#160;            node-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.trans_name&quot;</span>, s-&gt;baseTransName());</div>
<div class="line"><a name="l02321"></a><span class="lineno"> 2321</span>&#160;            node-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.domain&quot;</span>, ((<a class="code" href="namespacebcplus_1_1elements.html#a3e6f840af4a14452b75d90ee8ada34f3">Variable</a>*)s)-&gt;domain()-&gt;baseName());</div>
<div class="line"><a name="l02322"></a><span class="lineno"> 2322</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02323"></a><span class="lineno"> 2323</span>&#160;        <span class="keywordflow">case</span> Element::ELEM_SORT:</div>
<div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;            loc += <span class="stringliteral">&quot;.&quot;</span> + Element::elemTypeToString(s-&gt;getElemType()); </div>
<div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;            node = &amp;table.add(loc, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160;</div>
<div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160;            node-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.name&quot;</span>, s-&gt;baseName());</div>
<div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;            node-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.trans_name&quot;</span>, s-&gt;baseTransName());</div>
<div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160;</div>
<div class="line"><a name="l02330"></a><span class="lineno"> 2330</span>&#160;</div>
<div class="line"><a name="l02331"></a><span class="lineno"> 2331</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">Object</a> <span class="keyword">const</span>* obj : *(Sort*)s) {</div>
<div class="line"><a name="l02332"></a><span class="lineno"> 2332</span>&#160;                node2 = &amp;node-&gt;add(<span class="stringliteral">&quot;object&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l02333"></a><span class="lineno"> 2333</span>&#160;                node2-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.name&quot;</span>, obj-&gt;baseName());</div>
<div class="line"><a name="l02334"></a><span class="lineno"> 2334</span>&#160;                node2-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.trans_name&quot;</span>, obj-&gt;baseTransName());</div>
<div class="line"><a name="l02335"></a><span class="lineno"> 2335</span>&#160;                node2-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.arity&quot;</span>, obj-&gt;arity());</div>
<div class="line"><a name="l02336"></a><span class="lineno"> 2336</span>&#160;            }</div>
<div class="line"><a name="l02337"></a><span class="lineno"> 2337</span>&#160;</div>
<div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;            <span class="keywordflow">for</span> (SortList::const_iterator it = ((Sort*)s)-&gt;beginSubsorts(); it != ((Sort*)s)-&gt;endSubsorts(); it++) {</div>
<div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;                node2 = &amp;node-&gt;add(<span class="stringliteral">&quot;subsort.&lt;xmlattr&gt;.name&quot;</span>, (*it)-&gt;baseName());</div>
<div class="line"><a name="l02340"></a><span class="lineno"> 2340</span>&#160;                </div>
<div class="line"><a name="l02341"></a><span class="lineno"> 2341</span>&#160;</div>
<div class="line"><a name="l02342"></a><span class="lineno"> 2342</span>&#160;                <span class="keywordflow">for</span> (<a class="code" href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">Object</a> <span class="keyword">const</span>* obj : **it) {</div>
<div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;                    node2 = &amp;node-&gt;add(<span class="stringliteral">&quot;object&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160;                    node2-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.name&quot;</span>, obj-&gt;baseName());</div>
<div class="line"><a name="l02345"></a><span class="lineno"> 2345</span>&#160;                    node2-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.trans_name&quot;</span>, obj-&gt;baseTransName());</div>
<div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;                    node2-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.arity&quot;</span>, obj-&gt;arity());</div>
<div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160;                }</div>
<div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;            }</div>
<div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;</div>
<div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;        <span class="keywordflow">case</span> Element::ELEM_OBJ:</div>
<div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160;            <span class="comment">// handled by sorts.</span></div>
<div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;            <span class="keywordflow">break</span>;  </div>
<div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160;        }</div>
<div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;</div>
<div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;    }</div>
<div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;</div>
<div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;    <span class="keywordflow">for</span> (Query <span class="keyword">const</span>* q : queries) {</div>
<div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;        node = &amp;table.add(<span class="stringliteral">&quot;queries.query&quot;</span>, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;        node-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.label&quot;</span>, q-&gt;label);</div>
<div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;        node-&gt;add(<span class="stringliteral">&quot;&lt;xmlattr&gt;.steps&quot;</span>, q-&gt;maxstep);</div>
<div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;    }</div>
<div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;</div>
<div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;    write_xml(out, table, settings);</div>
<div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;    <span class="keywordflow">return</span> out;</div>
<div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;}</div>
<div class="ttc" id="namespacebcplus_1_1elements_html_a5484f87e7a51fb686edfbd620d3a0804"><div class="ttname"><a href="namespacebcplus_1_1elements.html#a5484f87e7a51fb686edfbd620d3a0804">bcplus::elements::Object</a></div><div class="ttdeci">detail::IdentifierElement&lt; Term, detail::TermType::OBJECT, symbols::ObjectSymbol, Term &gt; Object</div><div class="ttdoc">An object constant &#39;t&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00172">terms.h:172</a></div></div>
<div class="ttc" id="namespacebcplus_1_1elements_html_ab532875292bfd1ac4993edaced4d8266"><div class="ttname"><a href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">bcplus::elements::Constant</a></div><div class="ttdeci">detail::IdentifierElement&lt; Term, detail::TermType::CONSTANT, symbols::ConstantSymbol, Term &gt; Constant</div><div class="ttdoc">A bare constant &#39;c&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00189">terms.h:189</a></div></div>
<div class="ttc" id="namespacebcplus_1_1elements_html_a3e6f840af4a14452b75d90ee8ada34f3"><div class="ttname"><a href="namespacebcplus_1_1elements.html#a3e6f840af4a14452b75d90ee8ada34f3">bcplus::elements::Variable</a></div><div class="ttdeci">detail::IdentifierElement_bare&lt; Term, detail::TermType::VARIABLE, symbols::VariableSymbol &gt; Variable</div><div class="ttdoc">A variable &#39;V&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00180">terms.h:180</a></div></div>
<div class="ttc" id="namespaceutils_html_a8f62b72e0def57deb33132dfd5d4a0ec"><div class="ttname"><a href="namespaceutils.html#a8f62b72e0def57deb33132dfd5d4a0ec">utils::to_string</a></div><div class="ttdeci">std::string to_string(T val, std::ios_base &amp;(*fmt)(std::ios_base &amp;)=std::dec, int precision=-1)</div><div class="ttdoc">Transforms something (usually a number) into a string representation of itself. </div><div class="ttdef"><b>Definition:</b> <a href="src_2cplus2asp_2utils_8h_source.html#l00088">utils.h:88</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8a88e8bc81269b07f6ce7a7b31aea94d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::outputToErr </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>hdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endWithNewline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the contents of hdr followed by str to wherever the translator's error output stream is aimed. </p>
<p>Mirrors output to the standard output stream as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The text to output. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02101">2101</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l02090">caution()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02096">pragma()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l02083">warn()</a>.</p>
<div class="fragment"><div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;                                                                                                           {</div>
<div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;    (*ostErrPtr) &lt;&lt; hdr;</div>
<div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;    <span class="keywordflow">if</span> (location) {</div>
<div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;        (*ostErrPtr) &lt;&lt; <span class="stringliteral">&quot; at &quot;</span></div>
<div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;            &lt;&lt; ltsyyGetFileName() &lt;&lt; <span class="stringliteral">&quot;:&quot;</span></div>
<div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;            &lt;&lt; ltsyyGetLoc().first_line</div>
<div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;            &lt;&lt; <span class="stringliteral">&quot;.&quot;</span></div>
<div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;            &lt;&lt; ltsyyGetLoc().first_column;</div>
<div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;    }</div>
<div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;    (*ostErrPtr) &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; str;</div>
<div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;</div>
<div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;    <span class="keywordflow">if</span>(endWithNewline)</div>
<div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;        (*ostErrPtr) &lt;&lt; std::endl;</div>
<div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3a7d2e5e3b8c5b67345485e2c5e9bb6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::pragma </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endWithNewline</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>location</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the contents of str to wherever the translator's error output stream is aimed. </p>
<p>Mirrors output to the standard output stream as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The text to output. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02096">2096</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02101">outputToErr()</a>.</p>
<div class="fragment"><div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;{</div>
<div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;    <a class="code" href="classTranslator.html#a8a88e8bc81269b07f6ce7a7b31aea94d">outputToErr</a>(<span class="stringliteral">&quot;% Pragma&quot;</span>,str,endWithNewline,location);</div>
<div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_a8a88e8bc81269b07f6ce7a7b31aea94d"><div class="ttname"><a href="classTranslator.html#a8a88e8bc81269b07f6ce7a7b31aea94d">Translator::outputToErr</a></div><div class="ttdeci">void outputToErr(std::string const &amp;hdr, std::string const &amp;str, bool endWithNewline, bool location)</div><div class="ttdoc">Outputs the contents of hdr followed by str to wherever the translator&#39;s error output stream is aimed...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02101">Translator.cpp:2101</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5c11ad8502a2aeec081563dc13232462"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::resolveDynamicDeclarations </td>
          <td>(</td>
          <td class="paramtype">BaseElementList &amp;&#160;</td>
          <td class="paramname"><em>undefined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseElementList &amp;&#160;</td>
          <td class="paramname"><em>reallyUndefined</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to resolve dynamic declarations that weren't caught previously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">undefined</td><td>The list of identifiers (should be constants) that appear to be undefined. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reallyUndefined</td><td>A list to add the identifiers that have not been resovled by this method to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if we managed to resolve all of the requested identifiers. False otherwise. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02117">2117</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00210">getConstant()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00737">translateQuery()</a>.</p>
<div class="fragment"><div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160;                                                                                                        {</div>
<div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;    <span class="comment">// Track the old size.</span></div>
<div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;    <span class="keywordtype">size_t</span> prevSize = reallyUndefined.size();   </div>
<div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;    <a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a>* ref;</div>
<div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;    </div>
<div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;    <span class="comment">// Move through each of the possibly undefined constants and attempt to find a definition for it.</span></div>
<div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;    <span class="keywordflow">for</span> (BaseElementList::iterator uIt = undefined.begin(); uIt != undefined.end(); uIt++) {</div>
<div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;</div>
<div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;        <span class="keywordflow">if</span> ((ref = <a class="code" href="classTranslator.html#ae973090fa0d53bbf36bef3ccf6f50439">getConstant</a>((*uIt)-&gt;baseName(), (*uIt)-&gt;arity()))) {</div>
<div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;            <span class="comment">// found it</span></div>
<div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;            (*uIt)-&gt;ref(ref);</div>
<div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;            <span class="comment">// it really is undefined...</span></div>
<div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;            reallyUndefined.push_back(*uIt);</div>
<div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;        }</div>
<div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;    }</div>
<div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;</div>
<div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;</div>
<div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;    <span class="comment">// Check if we&#39;ve added anything to the &#39;really undefined list&#39;.</span></div>
<div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;    <span class="keywordflow">return</span> reallyUndefined.size() == prevSize;</div>
<div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;}</div>
<div class="ttc" id="namespacebcplus_1_1elements_html_ab532875292bfd1ac4993edaced4d8266"><div class="ttname"><a href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">bcplus::elements::Constant</a></div><div class="ttdeci">detail::IdentifierElement&lt; Term, detail::TermType::CONSTANT, symbols::ConstantSymbol, Term &gt; Constant</div><div class="ttdoc">A bare constant &#39;c&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00189">terms.h:189</a></div></div>
<div class="ttc" id="classTranslator_html_ae973090fa0d53bbf36bef3ccf6f50439"><div class="ttname"><a href="classTranslator.html#ae973090fa0d53bbf36bef3ccf6f50439">Translator::getConstant</a></div><div class="ttdeci">Constant * getConstant(std::string const &amp;name, size_t arity=0)</div><div class="ttdoc">Finds a constant identifier associated with the name/arity (or NULL);. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00210">Translator.h:210</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a671f7816dae79de670e35df5215432cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Translator::sanitizeConstantName </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>originalName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a C+ constant name to be compatible with ASP naming/syntax conventions. </p>
<p>Uses a consistent sanitization scheme, so calling it twice on the same input will produce the same output both times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalName</td><td>- The original base name of the constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sanitized name for the constant, or "" (blank) on an error. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00076">76</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="utilities_8cpp_source.html#l00057">utils::isDigit()</a>, <a class="el" href="utilities_8cpp_source.html#l00079">utils::isUppercase()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00061">SANITIZE_CONST_PREFIX</a>.</p>

<p>Referenced by <a class="el" href="parser__types_8cpp_source.html#l01068">ConstantLikeElement::translate()</a>, and <a class="el" href="parser__types_8cpp_source.html#l01126">ConstantLikeElement::translateAsConstant()</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;{</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    std::string tempStr = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="comment">// If the name starts with an underscore, number, or upper-case letter,</span></div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="comment">// prepend a sanitizing prefix, otherwise just use the original name.</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="comment">// Does not check originalName for &quot;invalid&quot; characters.</span></div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keywordflow">if</span>(originalName.length() &gt; 0)</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    {</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="keywordflow">if</span>(originalName[0] == <span class="charliteral">&#39;_&#39;</span> || <a class="code" href="namespaceutils.html#a44be81b93c8f841f33c69ec28246a53b">utils::isDigit</a>(originalName[0]) || <a class="code" href="namespaceutils.html#ac57e929ed74995cf8d9fbd3fe137e1b8">utils::isUppercase</a>(originalName[0]))</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;            tempStr += <a class="code" href="old_2Translator_8cpp.html#a004facfa7ede0b21ce8020165ab72943">SANITIZE_CONST_PREFIX</a>;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;            tempStr += originalName;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        }</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        {</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;            tempStr += originalName;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;        }</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    }</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="keywordflow">return</span> tempStr;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;}</div>
<div class="ttc" id="old_2Translator_8cpp_html_a004facfa7ede0b21ce8020165ab72943"><div class="ttname"><a href="old_2Translator_8cpp.html#a004facfa7ede0b21ce8020165ab72943">SANITIZE_CONST_PREFIX</a></div><div class="ttdeci">#define SANITIZE_CONST_PREFIX</div><div class="ttdoc">The prefix to stick on constant names when they need to be sanitized. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00061">Translator.cpp:61</a></div></div>
<div class="ttc" id="namespaceutils_html_ac57e929ed74995cf8d9fbd3fe137e1b8"><div class="ttname"><a href="namespaceutils.html#ac57e929ed74995cf8d9fbd3fe137e1b8">utils::isUppercase</a></div><div class="ttdeci">bool isUppercase(char testChar)</div><div class="ttdoc">Checks if a character is an upper-case (English) letter or not. </div><div class="ttdef"><b>Definition:</b> <a href="utilities_8cpp_source.html#l00079">utilities.cpp:79</a></div></div>
<div class="ttc" id="namespaceutils_html_a44be81b93c8f841f33c69ec28246a53b"><div class="ttname"><a href="namespaceutils.html#a44be81b93c8f841f33c69ec28246a53b">utils::isDigit</a></div><div class="ttdeci">bool isDigit(char testChar)</div><div class="ttdoc">Checks if a character represents a digit or not. </div><div class="ttdef"><b>Definition:</b> <a href="utilities_8cpp_source.html#l00057">utilities.cpp:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3cd39be74d4be1c81072986b6d79ffe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Translator::sanitizeObjectName </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>originalName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a C+ object name to be compatible with ASP naming/syntax conventions. </p>
<p>Uses a consistent sanitization scheme, so calling it twice on the same input will produce the same output both times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalName</td><td>- The original base name of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sanitized name for the object, or "" (blank) on an error. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00098">98</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="utilities_8cpp_source.html#l00079">utils::isUppercase()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00063">SANITIZE_OBJ_PREFIX</a>.</p>

<p>Referenced by <a class="el" href="parser__types_8cpp_source.html#l01204">ObjectLikeElement::translate()</a>.</p>
<div class="fragment"><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;{</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    std::string tempStr = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="comment">// If the name starts with an underscore or upper-case letter,</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="comment">// prepend a sanitizing prefix, otherwise just use the original name.</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    <span class="comment">// Checks for math symbols that need transforming.</span></div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    <span class="keywordflow">if</span>(originalName.length() &gt; 0)</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    {</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="keywordflow">if</span>(originalName[0] == <span class="charliteral">&#39;_&#39;</span> || <a class="code" href="namespaceutils.html#ac57e929ed74995cf8d9fbd3fe137e1b8">utils::isUppercase</a>(originalName[0]))</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            tempStr += <a class="code" href="old_2Translator_8cpp.html#affc21e089066a9cb68a0b78fd1b4f59a">SANITIZE_OBJ_PREFIX</a>;</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            tempStr += originalName;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        }</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        {</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            tempStr += originalName;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        }</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="comment">// Turn CCalc integer division into ASP integer division.</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keywordtype">size_t</span> transPos = tempStr.find(<span class="stringliteral">&quot;//&quot;</span>);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <span class="keywordflow">while</span>(transPos != std::string::npos)</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        {</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            tempStr.replace(transPos, 2, <span class="stringliteral">&quot;/&quot;</span>);</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            transPos = tempStr.find(<span class="stringliteral">&quot;//&quot;</span>);</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        }</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;        <span class="comment">// Turn CCalc &quot;mod&quot; into ASP modulus.</span></div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        transPos = tempStr.find(<span class="stringliteral">&quot;mod&quot;</span>);</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;        <span class="keywordflow">while</span>(transPos != std::string::npos)</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        {</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            tempStr.replace(transPos, 3, <span class="stringliteral">&quot;\\&quot;</span>);</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;            transPos = tempStr.find(<span class="stringliteral">&quot;mod&quot;</span>);</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        }</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    }</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="keywordflow">return</span> tempStr;</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;}</div>
<div class="ttc" id="namespaceutils_html_ac57e929ed74995cf8d9fbd3fe137e1b8"><div class="ttname"><a href="namespaceutils.html#ac57e929ed74995cf8d9fbd3fe137e1b8">utils::isUppercase</a></div><div class="ttdeci">bool isUppercase(char testChar)</div><div class="ttdoc">Checks if a character is an upper-case (English) letter or not. </div><div class="ttdef"><b>Definition:</b> <a href="utilities_8cpp_source.html#l00079">utilities.cpp:79</a></div></div>
<div class="ttc" id="old_2Translator_8cpp_html_affc21e089066a9cb68a0b78fd1b4f59a"><div class="ttname"><a href="old_2Translator_8cpp.html#affc21e089066a9cb68a0b78fd1b4f59a">SANITIZE_OBJ_PREFIX</a></div><div class="ttdeci">#define SANITIZE_OBJ_PREFIX</div><div class="ttdoc">The prefix to stick on object names when they need to be sanitized. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00063">Translator.cpp:63</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af8a9991e4f136e62021d89c3ef314eae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Translator::sanitizeSortName </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>originalName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a C+ sort name to be compatible with ASP naming/syntax conventions. </p>
<p>Uses a consistent sanitization scheme, so calling it twice on the same input will produce the same output both times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalName</td><td>- The original base name of the sort. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sanitized name for the sort, or "" (blank) on an error. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00134">134</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="utilities_8cpp_source.html#l00057">utils::isDigit()</a>, <a class="el" href="utilities_8cpp_source.html#l00079">utils::isUppercase()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00065">SANITIZE_SORT_PREFIX</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00238">sortNameToVariable()</a>.</p>
<div class="fragment"><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;{</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    std::string tempStr = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    <span class="comment">// If the name starts with an underscore, number, or upper-case letter,</span></div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="comment">// prepend a sanitizing prefix, otherwise just use the original name.</span></div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <span class="comment">// Checks original name for &quot;*&quot; and turns it into &quot;_star&quot;.</span></div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="keywordflow">if</span>(originalName.length() &gt; 0)</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    {</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">if</span>(originalName[0] == <span class="charliteral">&#39;_&#39;</span> || <a class="code" href="namespaceutils.html#a44be81b93c8f841f33c69ec28246a53b">utils::isDigit</a>(originalName[0]) || <a class="code" href="namespaceutils.html#ac57e929ed74995cf8d9fbd3fe137e1b8">utils::isUppercase</a>(originalName[0]))</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        {</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;            tempStr += <a class="code" href="old_2Translator_8cpp.html#a6c2109464448d898b345d22ca67ae618">SANITIZE_SORT_PREFIX</a>;</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        }</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; originalName.length(); i++)</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;        {</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            <span class="keywordflow">if</span>(originalName[i] == <span class="charliteral">&#39;*&#39;</span>)</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;            {</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                tempStr += <span class="stringliteral">&quot;_star&quot;</span>;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            }</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            {</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                tempStr += originalName[i];</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;            }</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;        }</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    }</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    <span class="keywordflow">return</span> tempStr;</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;}</div>
<div class="ttc" id="old_2Translator_8cpp_html_a6c2109464448d898b345d22ca67ae618"><div class="ttname"><a href="old_2Translator_8cpp.html#a6c2109464448d898b345d22ca67ae618">SANITIZE_SORT_PREFIX</a></div><div class="ttdeci">#define SANITIZE_SORT_PREFIX</div><div class="ttdoc">The prefix to stick on sort names when they need to be sanitized. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00065">Translator.cpp:65</a></div></div>
<div class="ttc" id="namespaceutils_html_ac57e929ed74995cf8d9fbd3fe137e1b8"><div class="ttname"><a href="namespaceutils.html#ac57e929ed74995cf8d9fbd3fe137e1b8">utils::isUppercase</a></div><div class="ttdeci">bool isUppercase(char testChar)</div><div class="ttdoc">Checks if a character is an upper-case (English) letter or not. </div><div class="ttdef"><b>Definition:</b> <a href="utilities_8cpp_source.html#l00079">utilities.cpp:79</a></div></div>
<div class="ttc" id="namespaceutils_html_a44be81b93c8f841f33c69ec28246a53b"><div class="ttname"><a href="namespaceutils.html#a44be81b93c8f841f33c69ec28246a53b">utils::isDigit</a></div><div class="ttdeci">bool isDigit(char testChar)</div><div class="ttdoc">Checks if a character represents a digit or not. </div><div class="ttdef"><b>Definition:</b> <a href="utilities_8cpp_source.html#l00057">utilities.cpp:57</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a95b7912d06f7d0e6378ccd8cc586e80d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Translator::sanitizeString </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>originalString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms an arbitrary string such that the result will be compatible with ASP object/predicate naming and syntax conventions. </p>
<p>Uses a consistent sanitization scheme, so calling it twice on the same input will produce the same output both times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalString</td><td>- The raw string to sanitize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sanitized version of the string, or "" (blank) on an error. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00184">184</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="utilities_8cpp_source.html#l00057">utils::isDigit()</a>, <a class="el" href="utilities_8cpp_source.html#l00090">utils::isLetter()</a>, <a class="el" href="utilities_8cpp_source.html#l00079">utils::isUppercase()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00071">SANITIZE_STR_REPLACE</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00227">numRangeToSortName()</a>.</p>
<div class="fragment"><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;{</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    std::string tempStr = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    <span class="keywordflow">if</span>(originalString.length() &gt; 0)</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    {</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;        <span class="comment">// If the string starts with an underscore or upper-case letter,</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <span class="comment">// prepend a sanitizing prefix.</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        <span class="keywordflow">if</span>(originalString[0] == <span class="charliteral">&#39;_&#39;</span> || <a class="code" href="namespaceutils.html#ac57e929ed74995cf8d9fbd3fe137e1b8">utils::isUppercase</a>(originalString[0]))</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;            tempStr += <a class="code" href="old_2Translator_8cpp.html#afe846241fe2092f21f1bc6d854681a60">SANITIZE_STR_REPLACE</a>;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        }</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <span class="comment">// If any characters in the string are not alphanumeric or underscores,</span></div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <span class="comment">// replace them with a sanitized character.</span></div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; originalString.length(); i++)</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        {</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            <span class="keywordflow">if</span>(originalString[i] != <span class="charliteral">&#39;_&#39;</span> &amp;&amp; !<a class="code" href="namespaceutils.html#a03c142afcaa9483be87a424729b93512">utils::isLetter</a>(originalString[i]) &amp;&amp; !<a class="code" href="namespaceutils.html#a44be81b93c8f841f33c69ec28246a53b">utils::isDigit</a>(originalString[i]))</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            {</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                tempStr += <a class="code" href="old_2Translator_8cpp.html#afe846241fe2092f21f1bc6d854681a60">SANITIZE_STR_REPLACE</a>;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;            }</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            {</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                tempStr += originalString[i];</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            }</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        }</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    }</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordflow">return</span> tempStr;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;}</div>
<div class="ttc" id="namespaceutils_html_ac57e929ed74995cf8d9fbd3fe137e1b8"><div class="ttname"><a href="namespaceutils.html#ac57e929ed74995cf8d9fbd3fe137e1b8">utils::isUppercase</a></div><div class="ttdeci">bool isUppercase(char testChar)</div><div class="ttdoc">Checks if a character is an upper-case (English) letter or not. </div><div class="ttdef"><b>Definition:</b> <a href="utilities_8cpp_source.html#l00079">utilities.cpp:79</a></div></div>
<div class="ttc" id="namespaceutils_html_a44be81b93c8f841f33c69ec28246a53b"><div class="ttname"><a href="namespaceutils.html#a44be81b93c8f841f33c69ec28246a53b">utils::isDigit</a></div><div class="ttdeci">bool isDigit(char testChar)</div><div class="ttdoc">Checks if a character represents a digit or not. </div><div class="ttdef"><b>Definition:</b> <a href="utilities_8cpp_source.html#l00057">utilities.cpp:57</a></div></div>
<div class="ttc" id="old_2Translator_8cpp_html_afe846241fe2092f21f1bc6d854681a60"><div class="ttname"><a href="old_2Translator_8cpp.html#afe846241fe2092f21f1bc6d854681a60">SANITIZE_STR_REPLACE</a></div><div class="ttdeci">#define SANITIZE_STR_REPLACE</div><div class="ttdoc">What to use to replace &quot;bad&quot; characters in a string that needs to be sanitized. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00071">Translator.cpp:71</a></div></div>
<div class="ttc" id="namespaceutils_html_a03c142afcaa9483be87a424729b93512"><div class="ttname"><a href="namespaceutils.html#a03c142afcaa9483be87a424729b93512">utils::isLetter</a></div><div class="ttdeci">bool isLetter(char testChar)</div><div class="ttdoc">Checks if a character is an English letter or not, regardless of case. </div><div class="ttdef"><b>Definition:</b> <a href="utilities_8cpp_source.html#l00090">utilities.cpp:90</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7b0b011e7bc390c45d99ff4f1df12ab1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Translator::sanitizeVariableName </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>originalName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a C+ variable name to be compatible with ASP naming/syntax conventions. </p>
<p>Uses a consistent sanitization scheme, so calling it twice on the same input will produce the same output both times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalName</td><td>- The original base name of the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sanitized name for the variable, or "" (blank) on an error. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00162">162</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="utilities_8cpp_source.html#l00057">utils::isDigit()</a>, <a class="el" href="utilities_8cpp_source.html#l00068">utils::isLowercase()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00067">SANITIZE_VAR_PREFIX</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00238">sortNameToVariable()</a>, <a class="el" href="parser__types_8cpp_source.html#l01299">VariableLikeElement::translateAsConstant()</a>, and <a class="el" href="parser__types_8cpp_source.html#l01284">VariableLikeElement::translateAsVariable()</a>.</p>
<div class="fragment"><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;{</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    std::string tempStr = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="comment">// If the name starts with an underscore, number, or lower-case letter,</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="comment">// prepend a sanitizing prefix, otherwise just use the original name.</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="comment">// Does not check originalName for &quot;invalid&quot; characters.</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="keywordflow">if</span>(originalName.length() &gt; 0)</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    {</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        <span class="keywordflow">if</span>(originalName[0] == <span class="charliteral">&#39;_&#39;</span> || <a class="code" href="namespaceutils.html#a44be81b93c8f841f33c69ec28246a53b">utils::isDigit</a>(originalName[0]) || <a class="code" href="namespaceutils.html#a20c81f2e83ce4ba23caf12a83b56262a">utils::isLowercase</a>(originalName[0]))</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        {</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;            tempStr += <a class="code" href="old_2Translator_8cpp.html#ac6b1dc2a12cc8c3c078efbc8de01c0b3">SANITIZE_VAR_PREFIX</a>;</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;            tempStr += originalName;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        }</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        {</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            tempStr += originalName;</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        }</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    }</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keywordflow">return</span> tempStr;</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;}</div>
<div class="ttc" id="namespaceutils_html_a44be81b93c8f841f33c69ec28246a53b"><div class="ttname"><a href="namespaceutils.html#a44be81b93c8f841f33c69ec28246a53b">utils::isDigit</a></div><div class="ttdeci">bool isDigit(char testChar)</div><div class="ttdoc">Checks if a character represents a digit or not. </div><div class="ttdef"><b>Definition:</b> <a href="utilities_8cpp_source.html#l00057">utilities.cpp:57</a></div></div>
<div class="ttc" id="namespaceutils_html_a20c81f2e83ce4ba23caf12a83b56262a"><div class="ttname"><a href="namespaceutils.html#a20c81f2e83ce4ba23caf12a83b56262a">utils::isLowercase</a></div><div class="ttdeci">bool isLowercase(char testChar)</div><div class="ttdoc">Checks if a character is an lower-case (English) letter or not. </div><div class="ttdef"><b>Definition:</b> <a href="utilities_8cpp_source.html#l00068">utilities.cpp:68</a></div></div>
<div class="ttc" id="old_2Translator_8cpp_html_ac6b1dc2a12cc8c3c078efbc8de01c0b3"><div class="ttname"><a href="old_2Translator_8cpp.html#ac6b1dc2a12cc8c3c078efbc8de01c0b3">SANITIZE_VAR_PREFIX</a></div><div class="ttdeci">#define SANITIZE_VAR_PREFIX</div><div class="ttdoc">The prefix to stick on variable names when they need to be sanitized. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00067">Translator.cpp:67</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4cc813b8e7eb68cdeaf68cdd7f38d641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::setErrorOutput </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>newOst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a translator instance's error output stream to the passed stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newOst</td><td>- The output stream the translator module should use when reporting errors or other problems. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02055">2055</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;{</div>
<div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;    <span class="keywordflow">if</span>(ostErrPtr)</div>
<div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;    {</div>
<div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;        ostErrPtr-&gt;rdbuf(newOst.rdbuf());</div>
<div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;    }</div>
<div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4e900621c5444895355f0c957f44618c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::setIncrementalPart </td>
          <td>(</td>
          <td class="paramtype">IPart&#160;</td>
          <td class="paramname"><em>newIncPart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets incremental part to the provided part, outputting the appropriate clause to the translation output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newIncPart</td><td>- The new incremental module to work with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02233">2233</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02260">output()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l02260">output()</a>.</p>
<div class="fragment"><div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;                                                    {</div>
<div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;    <span class="keywordflow">if</span> (!ostOutPtr) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;    <span class="keywordflow">if</span> (newIncPart == mCurrentPart) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;</div>
<div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;    <span class="keywordflow">if</span> (!blnStaticTrans) {</div>
<div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;        <span class="keywordflow">switch</span> (newIncPart) {</div>
<div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;        <span class="keywordflow">case</span> IPART_BASE:</div>
<div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;            <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>(<span class="stringliteral">&quot;#base.&quot;</span>,<span class="keyword">true</span>);</div>
<div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;        <span class="keywordflow">case</span> IPART_CUMULATIVE:</div>
<div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;            <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>(<span class="stringliteral">&quot;#cumulative &quot;</span> + dynamicTimeStamp + <span class="stringliteral">&quot;.&quot;</span>,<span class="keyword">true</span>);</div>
<div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;        <span class="keywordflow">case</span> IPART_VOLATILE:</div>
<div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;            <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>(<span class="stringliteral">&quot;#volatile &quot;</span> + dynamicTimeStamp + <span class="stringliteral">&quot;.&quot;</span>,<span class="keyword">true</span>);</div>
<div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;        <span class="keywordflow">case</span> IPART_NONE:</div>
<div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;        <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;        }</div>
<div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;    }</div>
<div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;</div>
<div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;    mCurrentPart = newIncPart;</div>
<div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;</div>
<div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_acbb634f19ffb6d601eae8ad032d72ce9"><div class="ttname"><a href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">Translator::output</a></div><div class="ttdeci">void output(std::string const &amp;str, IPart incPart, bool endWithNewline=false)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02260">Translator.cpp:2260</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a359ae1adacf0d1514fe5db102d45c3e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::setOutput </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>newOst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a translator instance's output stream to the passed stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newOst</td><td>- The output stream the translator should use to output its translations. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02028">2028</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;{</div>
<div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;    <span class="keywordflow">if</span>(ostOutPtr)</div>
<div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;    {</div>
<div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;        ostOutPtr-&gt;rdbuf(newOst.rdbuf());</div>
<div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;    }</div>
<div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab22e2028787ae2151f63cb82b6544c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::setStaticTranslation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>staticTrans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the translator instance should output a static translation of the CCalc source file instead of an incremental/dynamic translation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">staticTrans</td><td>- Whether a static translation should be used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02037">2037</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00220">getSort()</a>, and <a class="el" href="old_2Translator_8h_source.html#l00709">lang()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00270">Translator()</a>.</p>
<div class="fragment"><div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;                                                      {</div>
<div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;    blnStaticTrans = staticTrans;</div>
<div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;</div>
<div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;    <span class="comment">// Make sure we update the timestamps.</span></div>
<div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>() == LANG_MVPF) {</div>
<div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;        staticTimeStamp = <span class="stringliteral">&quot;0&quot;</span>;</div>
<div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;        dynamicTimeStamp = <span class="stringliteral">&quot;0&quot;</span>;</div>
<div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (staticTrans) {</div>
<div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;        staticTimeStamp = <a class="code" href="classTranslator.html#af8a229b868ba6ee176754ec2e342b6bd">getSort</a>(<span class="stringliteral">&quot;step&quot;</span>)-&gt;varTransName();</div>
<div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;        dynamicTimeStamp = <a class="code" href="classTranslator.html#af8a229b868ba6ee176754ec2e342b6bd">getSort</a>(<span class="stringliteral">&quot;astep&quot;</span>)-&gt;varTransName();</div>
<div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;        staticTimeStamp = <span class="stringliteral">&quot;maxstep&quot;</span>;</div>
<div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;        dynamicTimeStamp = <span class="stringliteral">&quot;maxstep&quot;</span>;</div>
<div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;    }</div>
<div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;</div>
<div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_af8a229b868ba6ee176754ec2e342b6bd"><div class="ttname"><a href="classTranslator.html#af8a229b868ba6ee176754ec2e342b6bd">Translator::getSort</a></div><div class="ttdeci">Sort * getSort(std::string const &amp;name)</div><div class="ttdoc">Finds a sort identifier associated with the name/arity (or NULL);. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00220">Translator.h:220</a></div></div>
<div class="ttc" id="classTranslator_html_a864d4dc33098092fef562455dc97c9e2"><div class="ttname"><a href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">Translator::lang</a></div><div class="ttdeci">Language lang() const </div><div class="ttdoc">Gets the currently active language. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00709">Translator.h:709</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa5d43f47ea2676625f9acc6210b73972"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Translator::sortNameToVariable </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>sortName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sanitizeFirst</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a sort name into an acceptable variable name containing as much of the original sort name as possible. </p>
<p>Uses a consistent naming convention, so calling it twice on the same range produces identical results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sortName</td><td>- The sort name to transform. </td></tr>
    <tr><td class="paramname">sanitizeFirst</td><td>- If true, will pass the sort name through sanitizeSortName before transforming it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An acceptable variable representation of the sort name, or "" (blank) on an error. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00238">238</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l00134">sanitizeSortName()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00162">sanitizeVariableName()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00069">SORT_TO_VAR_PREFIX</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00400">addSort()</a>.</p>
<div class="fragment"><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;{</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    std::string tempStr = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    std::string baseName = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <span class="keywordflow">if</span>(sanitizeFirst)</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        baseName = <a class="code" href="classTranslator.html#af8a9991e4f136e62021d89c3ef314eae">Translator::sanitizeSortName</a>(sortName);</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    }</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    {</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        baseName = sortName;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    }</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    <span class="comment">// Prepend a variable-compatible prefix to the sort name, then call</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <span class="comment">// the variable name sanitizer on the result to ensure it&#39;s a good name.</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;    <span class="keywordflow">if</span>(baseName.length() &gt; 0)</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;    {</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        tempStr += <a class="code" href="old_2Translator_8cpp.html#a6a9634ed065ef128c617addc4a893c28">SORT_TO_VAR_PREFIX</a>;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        tempStr += baseName;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;        tempStr = <a class="code" href="classTranslator.html#a7b0b011e7bc390c45d99ff4f1df12ab1">Translator::sanitizeVariableName</a>(tempStr);</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    }</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;    <span class="keywordflow">return</span> tempStr;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_af8a9991e4f136e62021d89c3ef314eae"><div class="ttname"><a href="classTranslator.html#af8a9991e4f136e62021d89c3ef314eae">Translator::sanitizeSortName</a></div><div class="ttdeci">static std::string sanitizeSortName(std::string const &amp;originalName)</div><div class="ttdoc">Transforms a C+ sort name to be compatible with ASP naming/syntax conventions. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00134">Translator.cpp:134</a></div></div>
<div class="ttc" id="old_2Translator_8cpp_html_a6a9634ed065ef128c617addc4a893c28"><div class="ttname"><a href="old_2Translator_8cpp.html#a6a9634ed065ef128c617addc4a893c28">SORT_TO_VAR_PREFIX</a></div><div class="ttdeci">#define SORT_TO_VAR_PREFIX</div><div class="ttdoc">The prefix used to variable-ify sort names. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00069">Translator.cpp:69</a></div></div>
<div class="ttc" id="classTranslator_html_a7b0b011e7bc390c45d99ff4f1df12ab1"><div class="ttname"><a href="classTranslator.html#a7b0b011e7bc390c45d99ff4f1df12ab1">Translator::sanitizeVariableName</a></div><div class="ttdeci">static std::string sanitizeVariableName(std::string const &amp;originalName)</div><div class="ttdoc">Transforms a C+ variable name to be compatible with ASP naming/syntax conventions. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00162">Translator.cpp:162</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a23889ec98e7b399eb1a79bb0e5878b24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::strToLanguage </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Language &amp;&#160;</td>
          <td class="paramname"><em>outLang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the name of a language to its corresponding enum type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>The name of the language. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outLang</td><td>A variable to place the enumerated language type in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02191">2191</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;                                                                 {</div>
<div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;    <span class="keywordflow">if</span> (!strcmp(str, <span class="stringliteral">&quot;bc&quot;</span>)) outLang = Language::LANG_BC;</div>
<div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(str, <span class="stringliteral">&quot;bc+&quot;</span>)) outLang = Language::LANG_BCPLUS;</div>
<div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(str, <span class="stringliteral">&quot;c+&quot;</span>)) outLang = Language::LANG_CPLUS;</div>
<div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(str, <span class="stringliteral">&quot;mvpf&quot;</span>)) outLang = Language::LANG_MVPF;</div>
<div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac30fbecad9b16306e8a328b5aaa3af80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::translateAlwaysLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>unlessBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a causal law of the form "always F [where G]." to basic form, then calls the translator for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint</td><td>- The condition that must be true. </td></tr>
    <tr><td class="paramname">unlessBody</td><td>- Optional formula that acts as an abnormality condition. </td></tr>
    <tr><td class="paramname">whereBody</td><td>- A conditional formula to govern when the law applies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything translates properly, false if anything goes wrong. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01485">1485</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="parser__types_8cpp_source.html#l00355">SimpleUnaryOperator::detachPostOp()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00382">getOrCreateObject()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>, and <a class="el" href="parser__types_8h_source.html#l00262">SimpleUnaryOperator::UOP_NOT</a>.</p>
<div class="fragment"><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;{</div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;    <span class="keywordtype">bool</span> retVal = <span class="keyword">false</span>; <span class="comment">// Start pessimistic.</span></div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;    <span class="keywordflow">if</span>(constraint != NULL)</div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;    {</div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;        <span class="comment">// &quot;not constraint&quot; is the afterBody.</span></div>
<div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;        <a class="code" href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a>* tempPE = <span class="keyword">new</span> <a class="code" href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a>(<a class="code" href="classSimpleUnaryOperator.html#ac0a7153989edd90defb764943758827aa2521e3f2084fe2a72431630a1f6eeb37">SimpleUnaryOperator::UOP_NOT</a>, constraint);</div>
<div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;</div>
<div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;        <span class="comment">// The head is &quot;false&quot;.</span></div>
<div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;        <a class="code" href="classObjectLikeElement.html">ObjectLikeElement</a>* tempObj = <span class="keyword">new</span> <a class="code" href="classObjectLikeElement.html">ObjectLikeElement</a>(<span class="stringliteral">&quot;false&quot;</span>, <a class="code" href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">getOrCreateObject</a>(<span class="stringliteral">&quot;false&quot;</span>));</div>
<div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;</div>
<div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;        <span class="comment">// The law becomes &quot;caused false after -F when H where G.&quot;</span></div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;        <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(tempObj, NULL, NULL, tempPE, unlessBody, whereBody);</div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;        <span class="keyword">delete</span> tempObj;</div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;        tempPE-&gt;<a class="code" href="classSimpleUnaryOperator.html#a7327224ac87e0b3d511c8d84295ff980">detachPostOp</a>();</div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;        <span class="keyword">delete</span> tempPE;</div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;        retVal = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;    }</div>
<div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;}</div>
<div class="ttc" id="classObjectLikeElement_html"><div class="ttname"><a href="classObjectLikeElement.html">ObjectLikeElement</a></div><div class="ttdoc">Child of BaseLikeElement that represents a base element with the behavior of an object. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00786">parser_types.h:786</a></div></div>
<div class="ttc" id="classSimpleUnaryOperator_html_a7327224ac87e0b3d511c8d84295ff980"><div class="ttname"><a href="classSimpleUnaryOperator.html#a7327224ac87e0b3d511c8d84295ff980">SimpleUnaryOperator::detachPostOp</a></div><div class="ttdeci">ParseElement * detachPostOp()</div><div class="ttdoc">Detaches the operator&#39;s sub expression, returning it. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00355">parser_types.cpp:355</a></div></div>
<div class="ttc" id="classSimpleUnaryOperator_html_ac0a7153989edd90defb764943758827aa2521e3f2084fe2a72431630a1f6eeb37"><div class="ttname"><a href="classSimpleUnaryOperator.html#ac0a7153989edd90defb764943758827aa2521e3f2084fe2a72431630a1f6eeb37">SimpleUnaryOperator::UOP_NOT</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00262">parser_types.h:262</a></div></div>
<div class="ttc" id="classTranslator_html_a2745b2441a5759d77e02524ec9dad4ff"><div class="ttname"><a href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">Translator::translateCausalLaw</a></div><div class="ttdeci">void translateCausalLaw(ParseElement *head, ParseElement *ifBody, ParseElement *assumingBody, ParseElement *afterBody, ParseElement *unlessBody, ParseElement *whereBody)</div><div class="ttdoc">Translates a causal law into ASP-compatible rule(s). </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00838">Translator.cpp:838</a></div></div>
<div class="ttc" id="classTranslator_html_ab255d800190701bc36af2f4b7582c1d0"><div class="ttname"><a href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">Translator::getOrCreateObject</a></div><div class="ttdeci">Object * getOrCreateObject(std::string const &amp;symName, Object::ObjectType type=Object::OBJ_NAME, bool internal=false, size_t arity=0)</div><div class="ttdoc">Helper function for getting an Object type reference or dynamically adding it if it doesn&#39;t occur...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00382">Translator.cpp:382</a></div></div>
<div class="ttc" id="classSimpleUnaryOperator_html"><div class="ttname"><a href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a></div><div class="ttdoc">Child of ParseElement that represents a unary operator and the associated elements it operates on...</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00258">parser_types.h:258</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2745b2441a5759d77e02524ec9dad4ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::translateCausalLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>ifBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>assumingBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>afterBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>unlessBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates a causal law into ASP-compatible <a class="el" href="structrule.html">rule(s)</a>. </p>
<p>Sends the result to ostOut. This models a causal law of the basic form "caused head if ifBody after afterBody unless unlessBody when whenBody following followingBody where whereBody." Passing NULL for the various parameters will change what kind of translation is performed, and the type of elements (if any) in the parameters will also affect the translation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>- The head portion of the causal law ("caused head..."). </td></tr>
    <tr><td class="paramname">ifBody</td><td>- The part of the law's body associated with the if keyword ("...if ifBody..."). </td></tr>
    <tr><td class="paramname">assumingBody</td><td>- The part of the law's body associated with the if keyword ("...assuming ifBody..."). </td></tr>
    <tr><td class="paramname">afterBody</td><td>- The part of the law's body associated with the after keyword ("...after afterBody..."). </td></tr>
    <tr><td class="paramname">unlessBody</td><td>- The part of the law's body associated with the unless keyword ("...unless unlessBody..."). </td></tr>
    <tr><td class="paramname">whereBody</td><td>- The part of the law's body associated with the where keyword ("...where whereBody."). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00838">838</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00259">addSymbol()</a>, <a class="el" href="classParseElement.html#aed85d01764a3f624eacc78e284b75438">ParseElement::aggregateUndefined()</a>, <a class="el" href="parser__types_8h_source.html#l00344">SimpleBinaryOperator::BOP_AND</a>, <a class="el" href="parser__types_8cpp_source.html#l00729">SimpleBinaryOperator::detachPostOp()</a>, <a class="el" href="parser__types_8cpp_source.html#l00736">SimpleBinaryOperator::detachPreOp()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>, <a class="el" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName()</a>, <a class="el" href="old_2Translator_8h_source.html#l00220">getSort()</a>, <a class="el" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants()</a>, <a class="el" href="classParseElement.html#a85faf97e4baf292e34ede3ab83d7e126">ParseElement::hasLuaCalls()</a>, <a class="el" href="classParseElement.html#a33f6ca61ca9b8a4d817b6407b13ff0ff">ParseElement::isDefinite()</a>, <a class="el" href="parser__types_8h_source.html#l00162">ParseElement::isTrivial()</a>, <a class="el" href="old_2Translator_8h_source.html#l00709">lang()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01236">makeCausalTranslation()</a>, <a class="el" href="parser__types_8h_source.html#l00093">ParseElement::MASK_AB</a>, <a class="el" href="parser__types_8h_source.html#l00084">ParseElement::MASK_ACTION</a>, <a class="el" href="parser__types_8h_source.html#l00085">ParseElement::MASK_FLUENT</a>, <a class="el" href="parser__types_8h_source.html#l00095">ParseElement::MASK_NON_RIGID</a>, <a class="el" href="parser__types_8h_source.html#l00094">ParseElement::MASK_NON_TRIVIAL</a>, <a class="el" href="parser__types_8h_source.html#l00086">ParseElement::MASK_RIGID</a>, <a class="el" href="parser__types_8h_source.html#l00091">ParseElement::MASK_SDFLUENT</a>, <a class="el" href="parser__types_8h_source.html#l00089">ParseElement::MASK_TRUE_FALSE</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02266">outputStmts()</a>, <a class="el" href="parser__types_8h_source.html#l00211">ParseElement::parens()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02117">resolveDynamicDeclarations()</a>, <a class="el" href="src_2cplus2asp_2utils_8h_source.html#l00088">utils::to_string()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00496">translateConstantDecl()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l01485">translateAlwaysLaw()</a>, <a class="el" href="old_2Translator_8h_source.html#l00364">translateCausalLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01741">translateCausesLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01511">translateConstraintLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01458">translateDeclarativeLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01575">translateDefaultLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01796">translateIncrementLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01679">translateMayCauseLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01605">translateNonexecutableLaw()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l01650">translatePossiblyCausedLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;{</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;    <span class="comment">// The initialized values default to &quot;static law&quot; (i.e., fluents only, no &quot;after&quot;).</span></div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;    RuleType <a class="code" href="structsymbol.html#aafff7593df974a98ea04be2b7450091e">type</a> = RULE_STATIC;    <span class="comment">// The type of the rule we&#39;re currently working with.</span></div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;    <span class="keywordtype">bool</span> assumingNotNot = <span class="keyword">false</span>;    <span class="comment">// Whether the assuming body should be encased in double negation.</span></div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;    <span class="keywordtype">bool</span> malformed = <span class="keyword">false</span>;         <span class="comment">// true if one or more problems with the law have been detected.</span></div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    std::ostringstream ossOutputBuffer; <span class="comment">// Holds translated output so things can be easily added on before or after the normal output.</span></div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;    std::string baseTimeStamp;  <span class="comment">// The timestamp used to index this rule with.</span></div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;    <span class="comment">// lists used to capture additional clauses and statments.</span></div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;    StmtList stmts;</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;    <span class="comment">// Do some basic checking on the structure of the law. This includes determining the type of law we&#39;re working with</span></div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;    <span class="comment">// and performing some basic sanity checking on each of the components...</span></div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;    <a class="code" href="classParseElement.html">ParseElement</a>* tmpAssuming = NULL;</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;    <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a> *tmp = NULL;</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;        </div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;    <span class="keywordtype">bool</span> allowChoiceInHead = <span class="keyword">false</span>;     <span class="comment">// Whether choice rules are allowed in the head of a rule.</span></div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;    <span class="keywordtype">bool</span> allowAtomicNegationInHead = <span class="keyword">false</span>; <span class="comment">// whether atomic negation (-p) is allowed in the head of a rule.    </span></div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;    </div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;    <span class="comment">// step -1: Check language specific constructs</span></div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;    <span class="keywordflow">switch</span> (<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>()) {</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;    <span class="keywordflow">case</span> LANG_CPLUS:</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;                allowChoiceInHead = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;                allowAtomicNegationInHead = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;        <span class="keywordflow">if</span> (!ifBody) tmpAssuming = assumingBody;    </div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!assumingBody) { </div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;            tmpAssuming = ifBody;</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;            ifBody = NULL;</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;            ifBody-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;            assumingBody-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;            tmpAssuming = tmp = <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(ifBody, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, assumingBody);</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;            ifBody = NULL;</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;        }</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    <span class="keywordflow">case</span> LANG_BC:</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;        tmpAssuming = assumingBody;</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;        allowChoiceInHead = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;        allowAtomicNegationInHead = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;        <span class="comment">// Enforce conjunction of literals in the rule bodies.</span></div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;<span class="preprocessor">#define ENFORCE_BC_ASSUMING_CONJ</span></div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#ifdef ENFORCE_BC_ASSUMING_CONJ</span></div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;<span class="preprocessor"></span>        <span class="comment">// TODO: Do we want to enforce that the assuming body</span></div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;        <span class="comment">// is a conjunction of literals?</span></div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;        <span class="keywordflow">if</span> (assumingBody &amp;&amp; !assumingBody-&gt;<a class="code" href="classParseElement.html#a33f6ca61ca9b8a4d817b6407b13ff0ff">isDefinite</a>(<span class="keyword">true</span>)) {</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;Language BC does not support arbitrary formulas in the assuming clause of a rule.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;            malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;        }</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;        <span class="keywordflow">if</span> (ifBody &amp;&amp; !ifBody-&gt;<a class="code" href="classParseElement.html#a33f6ca61ca9b8a4d817b6407b13ff0ff">isDefinite</a>(<span class="keyword">true</span>)) {</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;Language BC does not support arbitrary formulas in the if clause of a rule.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;            malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;        }</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;        <span class="keywordflow">if</span> (afterBody &amp;&amp; !afterBody-&gt;<a class="code" href="classParseElement.html#a33f6ca61ca9b8a4d817b6407b13ff0ff">isDefinite</a>(<span class="keyword">true</span>)) {</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;Language BC does not support arbitrary formulas in the after clause of a rule.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;            malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;        }</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;</div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;    <span class="keywordflow">case</span> LANG_BCPLUS:</div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;        tmpAssuming = assumingBody;</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;        allowChoiceInHead = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;        allowAtomicNegationInHead = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;                </div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;    <span class="keywordflow">case</span> LANG_MVPF:</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;        tmpAssuming = assumingBody;</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;        allowAtomicNegationInHead = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;        allowChoiceInHead = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;        <span class="keywordflow">if</span> (afterBody) {</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;The after clause is not supported in MVPF.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;            malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;        }</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;        <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    }</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;</div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;    <span class="comment">// Step 0, check to ensure that there are no undefined identifiers (outside the unless clause).</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;    BaseElementList maybeUndefined, undefined;</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;    <span class="keywordflow">if</span> (head) head-&gt;<a class="code" href="classParseElement.html#aed85d01764a3f624eacc78e284b75438">aggregateUndefined</a>(maybeUndefined);</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;    <span class="keywordflow">if</span> (ifBody) ifBody-&gt;<a class="code" href="classParseElement.html#aed85d01764a3f624eacc78e284b75438">aggregateUndefined</a>(maybeUndefined);</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    <span class="keywordflow">if</span> (tmpAssuming) tmpAssuming-&gt;<a class="code" href="classParseElement.html#aed85d01764a3f624eacc78e284b75438">aggregateUndefined</a>(maybeUndefined);</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    <span class="keywordflow">if</span> (afterBody) afterBody-&gt;<a class="code" href="classParseElement.html#aed85d01764a3f624eacc78e284b75438">aggregateUndefined</a>(maybeUndefined);</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="classTranslator.html#a5c11ad8502a2aeec081563dc13232462">resolveDynamicDeclarations</a>(maybeUndefined, undefined))</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    {</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;        <span class="comment">// One or more undefined elements.</span></div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;        <span class="comment">// Throw an error</span></div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;        std::ostringstream tmpErr;</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;        tmpErr &lt;&lt; <span class="stringliteral">&quot;Undeclared identifiers were encountered. The following identifiers are undeclared: &quot;</span>;</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;        <span class="keywordflow">for</span> (BaseElementList::const_iterator it = undefined.begin(); it != undefined.end(); ) {</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;            tmpErr &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;            (*it)-&gt;fullName(tmpErr);</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;            tmpErr &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;            <span class="keywordflow">if</span> (++it != undefined.end()) tmpErr &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;        }</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;        tmpErr &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(tmpErr.str(),<span class="keyword">true</span>);</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;    }</div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;    <span class="comment">// step 1: ensure the head is non-null and in the correct form</span></div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;    <span class="keywordflow">if</span> (!head || !head-&gt;<a class="code" href="classParseElement.html#a33f6ca61ca9b8a4d817b6407b13ff0ff">isDefinite</a>(<span class="keyword">false</span>, allowChoiceInHead, allowAtomicNegationInHead)) {</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;Definite causal laws must have exactly one constant in the head.\n&quot;</span>);</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;    }</div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;    <span class="comment">// step 2: Ensure that LUA calls only occur in the law&#39;s where clause (if it exists).</span></div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    <span class="keywordflow">if</span> ( head-&gt;<a class="code" href="classParseElement.html#a85faf97e4baf292e34ede3ab83d7e126">hasLuaCalls</a>(<span class="keyword">false</span>,<span class="keyword">false</span>)</div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;            || (unlessBody &amp;&amp; unlessBody-&gt;<a class="code" href="classParseElement.html#a85faf97e4baf292e34ede3ab83d7e126">hasLuaCalls</a>(<span class="keyword">false</span>,<span class="keyword">false</span>))</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;            || (ifBody &amp;&amp; ifBody-&gt;<a class="code" href="classParseElement.html#a85faf97e4baf292e34ede3ab83d7e126">hasLuaCalls</a>(<span class="keyword">false</span>,<span class="keyword">false</span>))</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;            || (afterBody &amp;&amp; afterBody-&gt;<a class="code" href="classParseElement.html#a85faf97e4baf292e34ede3ab83d7e126">hasLuaCalls</a>(<span class="keyword">false</span>,<span class="keyword">false</span>))</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;            || (tmpAssuming &amp;&amp; tmpAssuming-&gt;<a class="code" href="classParseElement.html#a85faf97e4baf292e34ede3ab83d7e126">hasLuaCalls</a>(<span class="keyword">false</span>,<span class="keyword">false</span>)))</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;    {</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;        <span class="comment">// They have at least one call to lua outside the where clause.</span></div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;        <span class="comment">// Throw an error.</span></div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;External function calls are only permitted in the where clauses of a causal law.\n&quot;</span>);</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;    }</div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;</div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;</div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;</div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;</div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;    <span class="comment">// step 3: Ensure that abnormalities are where they are supposed to be...</span></div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>() != LANG_BCPLUS &amp;&amp;</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;        (</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;            head-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6f7f4ccc2c65e1b21028059419b57655">ParseElement::MASK_AB</a>)</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;            || (ifBody &amp;&amp; ifBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6f7f4ccc2c65e1b21028059419b57655">ParseElement::MASK_AB</a>))</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;            || (afterBody &amp;&amp; afterBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6f7f4ccc2c65e1b21028059419b57655">ParseElement::MASK_AB</a>))</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;            || (tmpAssuming &amp;&amp; tmpAssuming-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6f7f4ccc2c65e1b21028059419b57655">ParseElement::MASK_AB</a>))</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;            || (unlessBody &amp;&amp; unlessBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6f7f4ccc2c65e1b21028059419b57655">ParseElement::MASK_AB</a>))</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;            || (whereBody &amp;&amp; whereBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6f7f4ccc2c65e1b21028059419b57655">ParseElement::MASK_AB</a>))</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;        )) { </div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;External constants are only supported in BC+.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( <a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>() == LANG_BCPLUS &amp;&amp; </div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;            (</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;                head-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6f7f4ccc2c65e1b21028059419b57655">ParseElement::MASK_AB</a>)</div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;                || (unlessBody &amp;&amp; unlessBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6f7f4ccc2c65e1b21028059419b57655">ParseElement::MASK_AB</a>))</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;                || (whereBody &amp;&amp; whereBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6f7f4ccc2c65e1b21028059419b57655">ParseElement::MASK_AB</a>))</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;            )) {</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;External constants can not occur in the head of a law or in it&#39;s &#39;unless&#39; or &#39;where&#39; body.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;    }</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;    <span class="comment">// step 3.5: Ensure that the where clause doesn&#39;t contain anything special.</span></div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;    <span class="keywordflow">if</span> ( whereBody &amp;&amp; whereBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36af8637dc10b0bac2ea8439e41f745899e">ParseElement::MASK_NON_TRIVIAL</a>)) {</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;The &#39;where&#39; clause of a law must not contain constants.\n&quot;</span>);</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;    }</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;<span class="comment">//#define VERBOSE_DEBUG</span></div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;</div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;<span class="preprocessor">#ifdef VERBOSE_DEBUG</span></div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;<span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;# Head: &quot;</span>;</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;    <span class="keywordflow">if</span> (head) head-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>(std::cout);</div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">&quot;NULL&quot;</span>;</div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;\n#\tAssuming: &quot;</span>;</div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;    <span class="keywordflow">if</span> (tmpAssuming) tmpAssuming-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>(std::cout);</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">&quot;NULL&quot;</span>;</div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;\n#\tIf: &quot;</span>;</div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;    <span class="keywordflow">if</span> (ifBody) ifBody-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>(std::cout);</div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">&quot;NULL&quot;</span>;</div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;\n#\tAfter: &quot;</span>;</div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;    <span class="keywordflow">if</span> (afterBody) afterBody-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>(std::cout);</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">&quot;NULL&quot;</span>;</div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;\n#\tUnless: &quot;</span>;</div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;    <span class="keywordflow">if</span> (unlessBody) unlessBody-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>(std::cout);</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">&quot;NULL&quot;</span>;</div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;\n#\tWhere: &quot;</span>;</div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;    <span class="keywordflow">if</span> (whereBody) whereBody-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>(std::cout);</div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;    <span class="keywordflow">else</span> std::cout &lt;&lt; <span class="stringliteral">&quot;NULL&quot;</span>;</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;    <span class="comment">// Step 4a: Determine if the law is a &#39;rigid&#39; law, which contains a rigid fluent in the head (Alternatively, if it contains &#39;exogenous&#39; or &#39;inertial&#39;).</span></div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;    <span class="keywordflow">if</span> (head-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36ad80ac9dcab5a3b797a7de9857bd3f95c">ParseElement::MASK_RIGID</a>)) {</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;        type = RULE_RIGID;</div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;<span class="preprocessor">#ifdef VERBOSE_DEBUG</span></div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;# RIGID LAW\n&quot;</span>;</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;<span class="preprocessor"></span>        <span class="comment">// Verification: We don&#39;t allow any non-rigid fluents in the rule.</span></div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;        <span class="keywordflow">if</span> (head-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a70009e1bf125be930e70f4eb84c892fa">ParseElement::MASK_NON_RIGID</a>)</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;                || (ifBody &amp;&amp; ifBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a70009e1bf125be930e70f4eb84c892fa">ParseElement::MASK_NON_RIGID</a>))</div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;                || (tmpAssuming &amp;&amp; tmpAssuming-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a70009e1bf125be930e70f4eb84c892fa">ParseElement::MASK_NON_RIGID</a>))</div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;                || (unlessBody &amp;&amp; unlessBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a70009e1bf125be930e70f4eb84c892fa">ParseElement::MASK_NON_RIGID</a>))</div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;            )</div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;        {</div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;A causal law w/ rigid fluents in the head and non-rigid fluents in the body is (currently) unsupported.\n&quot;</span>);</div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;            malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;        }</div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;</div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;        <span class="keywordflow">if</span> (afterBody) {</div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;A dynamic law w/ rigid fluents in the head is (currently) unsupported.\n&quot;</span>);</div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;            malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;        }</div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;    }</div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;</div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;    <span class="comment">// Step 4ab: Rigid constraints</span></div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!head-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a70009e1bf125be930e70f4eb84c892fa">ParseElement::MASK_NON_RIGID</a>)</div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;                &amp;&amp; (!ifBody || !ifBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a70009e1bf125be930e70f4eb84c892fa">ParseElement::MASK_NON_RIGID</a>))</div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;                &amp;&amp; (!tmpAssuming || !tmpAssuming-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a70009e1bf125be930e70f4eb84c892fa">ParseElement::MASK_NON_RIGID</a>))</div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;                &amp;&amp; (!afterBody)</div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;                &amp;&amp; (!unlessBody || !unlessBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a70009e1bf125be930e70f4eb84c892fa">ParseElement::MASK_NON_RIGID</a>))) {</div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;        type = RULE_RIGID;</div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;<span class="preprocessor">#ifdef VERBOSE_DEBUG</span></div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;# RIGID LAW\n&quot;</span>;</div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;<span class="preprocessor"></span>    }</div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;</div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;    <span class="comment">// Step 4b: Determine whether the law is a static law, an action dynamic law, or a fluent dynamic law...</span></div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;    <span class="comment">// Static laws...</span></div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (head-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a> | <a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36ab5afd65a2b86d219400c4d4c9c786883">ParseElement::MASK_TRUE_FALSE</a>) &amp;&amp; !head-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>)</div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;            &amp;&amp; (!ifBody || !ifBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>))</div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;            &amp;&amp; (!tmpAssuming || !tmpAssuming-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>))</div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;            &amp;&amp; !afterBody)</div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;    {</div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;        type = RULE_STATIC;</div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;        baseTimeStamp = staticTimeStamp;</div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;<span class="preprocessor">#ifdef VERBOSE_DEBUG</span></div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;# STATIC LAW\n&quot;</span>;</div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;<span class="preprocessor"></span>    }</div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;    <span class="comment">// fluent dynamic laws...</span></div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!head-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>)</div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;            &amp;&amp; (!ifBody || !ifBody-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>))</div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;            &amp;&amp; (!tmpAssuming || !tmpAssuming-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>)))</div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;    {</div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;        type = RULE_FLUENTDYNAMIC;</div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;        baseTimeStamp = dynamicTimeStamp;</div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;<span class="preprocessor">#ifdef VERBOSE_DEBUG</span></div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;# FLUENT DYNAMIC LAW\n&quot;</span>;</div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;<span class="preprocessor"></span>    }</div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;    <span class="comment">// action dynamic laws...</span></div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (head-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>) &amp;&amp; !head-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a>)</div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;            &amp;&amp; !afterBody)</div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;    {</div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;        type = RULE_ACTIONDYNAMIC;</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;        baseTimeStamp = dynamicTimeStamp + <span class="stringliteral">&quot;-1&quot;</span>;</div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;<span class="preprocessor">#ifdef VERBOSE_DEBUG</span></div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;<span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;# ACTION DYNAMIC LAW\n&quot;</span>;</div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;<span class="preprocessor"></span>    }</div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;    <span class="comment">// Malformed laws...</span></div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;    {</div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;A malformed causal law was encountered. Please ensure that all laws are either static, action dynamic, or fluent dynamic laws.\n&quot;</span>);</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;    }</div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;</div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;    <span class="comment">// Now check if we actually need &quot;not not (...)&quot; encasing the law&#39;s body (if it has one).</span></div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;    <span class="keywordflow">if</span> (!head-&gt;<a class="code" href="classParseElement.html#ab809726a4f458fa05098aa132370de94">isTrivial</a>() &amp;&amp; tmpAssuming &amp;&amp; !tmpAssuming-&gt;<a class="code" href="classParseElement.html#ab809726a4f458fa05098aa132370de94">isTrivial</a>()) {</div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;            assumingNotNot = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;<span class="preprocessor">#ifdef VERBOSE_DEBUG</span></div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;<span class="preprocessor"></span>            std::cout &lt;&lt; <span class="stringliteral">&quot;# ADDING NOT NOT...&quot;</span>;</div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;<span class="preprocessor"></span>    }</div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;</div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;</div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;    <span class="comment">// Step 5, declare undefined identifiers in the unless clause.</span></div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;    maybeUndefined.clear();</div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;    undefined.clear();</div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;    <span class="keywordflow">if</span> (unlessBody) {</div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;        unlessBody-&gt;<a class="code" href="classParseElement.html#aed85d01764a3f624eacc78e284b75438">aggregateUndefined</a>(maybeUndefined);</div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;        <a class="code" href="classTranslator.html#a5c11ad8502a2aeec081563dc13232462">resolveDynamicDeclarations</a>(maybeUndefined, undefined);</div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;</div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;</div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;        ConstSortList tmpParamSorts;</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;        <span class="keywordflow">for</span> (BaseElementList::const_iterator it = undefined.begin(); it != undefined.end(); it++) {</div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;            tmpParamSorts.clear();</div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;            <span class="keywordtype">bool</span> success = (*it)-&gt;guessParamSorts(tmpParamSorts);</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;</div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;            <span class="keywordflow">if</span> (success) {</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;                Constant::ConstantType abType =</div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;                        (type == RULE_STATIC || type == RULE_RIGID)</div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;                        ? Constant::CONST_ABFLUENT</div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;                        : Constant::CONST_ABACTION;</div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;</div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;                <span class="comment">// We successfully guessed every sort that was required. Finish the declaration.</span></div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;                <a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a>* newConst = <span class="keyword">new</span> <a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a>(</div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;                        (*it)-&gt;baseName(),</div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;                        <a class="code" href="classTranslator.html#af8a229b868ba6ee176754ec2e342b6bd">getSort</a>(<span class="stringliteral">&quot;boolean&quot;</span>),</div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;                        abType,</div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;                        <span class="keyword">false</span>,</div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;                        &amp;tmpParamSorts</div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;                );</div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;</div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;                <a class="code" href="classTranslator.html#ae81edcdd33f60dca0b494ffdf3a856b0">translateConstantDecl</a>(newConst);</div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classTranslator.html#a915d7f328ae4d090a55309522275886c">addSymbol</a>(newConst) != SymbolTable::ADDSYM_OK) {</div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;                    <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;An error ocurred while declaring the ab constant &#39;&quot;</span> + newConst-&gt;baseName() + <span class="stringliteral">&quot;/&quot;</span> + <a class="code" href="namespaceutils.html#a8f62b72e0def57deb33132dfd5d4a0ec">utils::to_string</a>(newConst-&gt;arity()) + <span class="stringliteral">&quot;&#39;&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;                    <span class="keyword">delete</span> newConst;</div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;                    malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;                } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;                    <span class="comment">// Make sure we update the declaration.</span></div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;                    (*it)-&gt;ref(newConst);</div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;                }</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;                <span class="comment">// Unable to dynamically declare the constant.</span></div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;                <span class="comment">// Tell the user.</span></div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;                <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;Unable to dynamically declare \&quot;&quot;</span> + ((<a class="code" href="classParseElement.html">ParseElement</a>*)(*it))-&gt;fullName() + <span class="stringliteral">&quot;\&quot; as the constant&#39;s parameter sorts could not be determined. Declaring the constant beforehand will fix this issue.&quot;</span>,<span class="keyword">true</span>);</div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;                malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;            }</div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;        }</div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;    }</div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;</div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;</div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;    <span class="comment">// Step 6: Check that SDFluents don&#39;t occur in the head of dynamic laws.</span></div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;    <span class="keywordflow">if</span> (type == RULE_FLUENTDYNAMIC &amp;&amp; head-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a5db09f10f1df45fb5ef721800c58e818">ParseElement::MASK_SDFLUENT</a>)) {</div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;An sdFluent cannot occur in the head of a dynamic law.&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;    }</div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;</div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;    <span class="comment">// catch malformed rules and don&#39;t translate them.</span></div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;    <span class="keywordflow">if</span> (malformed) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;</div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;    <span class="comment">// Let&#39;s do the translation!</span></div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;</div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;    <span class="comment">// We may need a &#39;static&#39; copy for the base module</span></div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;    <span class="keywordflow">if</span> (!blnStaticTrans &amp;&amp; (type == RULE_STATIC || type == RULE_RIGID)) {</div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;        <a class="code" href="classTranslator.html#ac6696248ca5c08d2fa8df07838d63e1b">makeCausalTranslation</a>(</div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;            ossOutputBuffer,</div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;            stmts,</div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;            IPART_BASE,</div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;            assumingNotNot,</div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;            <span class="stringliteral">&quot;0&quot;</span>,</div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;            head,</div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;            ifBody,</div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;            tmpAssuming,</div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;            unlessBody,</div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;            afterBody,</div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;            whereBody</div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;        );</div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;        stmts.push_back(Statement(ossOutputBuffer.str(),IPART_BASE));</div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;        ossOutputBuffer.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;    }</div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;</div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;    <span class="comment">// We also are going to need a dynamic version of the rule, unless the rule is rigid.</span></div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;    <span class="keywordflow">if</span> (blnStaticTrans || type != RULE_RIGID) {</div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;        <a class="code" href="classTranslator.html#ac6696248ca5c08d2fa8df07838d63e1b">makeCausalTranslation</a>(</div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;            ossOutputBuffer,</div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;            stmts,</div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;            IPART_CUMULATIVE,</div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;            assumingNotNot,</div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;            baseTimeStamp,</div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;            head,</div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;            ifBody,</div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;            tmpAssuming,</div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;            unlessBody,</div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;            afterBody,</div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;            whereBody</div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;        );</div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;        stmts.push_back(Statement(ossOutputBuffer.str(),IPART_CUMULATIVE));</div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;        ossOutputBuffer.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;    }</div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;</div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;</div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;    <span class="comment">// write the resulting statements to the output</span></div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;    <a class="code" href="classTranslator.html#a2c7447c0464738a176c4cc5f05397dfa">outputStmts</a>(stmts);</div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;</div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;    <span class="comment">// cleanup</span></div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;    <span class="keywordflow">if</span> (tmp) {</div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;        tmp-&gt;<a class="code" href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">detachPostOp</a>();</div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;        tmp-&gt;<a class="code" href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">detachPreOp</a>();</div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;        <span class="keyword">delete</span> tmp;</div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;    }</div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;</div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;}</div>
<div class="ttc" id="classParseElement_html_ab809726a4f458fa05098aa132370de94"><div class="ttname"><a href="classParseElement.html#ab809726a4f458fa05098aa132370de94">ParseElement::isTrivial</a></div><div class="ttdeci">bool isTrivial(bool includeParams=true, bool includeEq=true) const </div><div class="ttdoc">Determines if the element contains no (real) constants. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00162">parser_types.h:162</a></div></div>
<div class="ttc" id="classTranslator_html_a915d7f328ae4d090a55309522275886c"><div class="ttname"><a href="classTranslator.html#a915d7f328ae4d090a55309522275886c">Translator::addSymbol</a></div><div class="ttdeci">SymbolTable::SymTblResult addSymbol(Element *elem)</div><div class="ttdoc">Attempts to add a new symbol to the translator&#39;s data structures. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00259">Translator.h:259</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36ab5afd65a2b86d219400c4d4c9c786883"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36ab5afd65a2b86d219400c4d4c9c786883">ParseElement::MASK_TRUE_FALSE</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00089">parser_types.h:89</a></div></div>
<div class="ttc" id="classTranslator_html_af8a229b868ba6ee176754ec2e342b6bd"><div class="ttname"><a href="classTranslator.html#af8a229b868ba6ee176754ec2e342b6bd">Translator::getSort</a></div><div class="ttdeci">Sort * getSort(std::string const &amp;name)</div><div class="ttdoc">Finds a sort identifier associated with the name/arity (or NULL);. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00220">Translator.h:220</a></div></div>
<div class="ttc" id="namespacebcplus_1_1elements_html_ab532875292bfd1ac4993edaced4d8266"><div class="ttname"><a href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">bcplus::elements::Constant</a></div><div class="ttdeci">detail::IdentifierElement&lt; Term, detail::TermType::CONSTANT, symbols::ConstantSymbol, Term &gt; Constant</div><div class="ttdoc">A bare constant &#39;c&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00189">terms.h:189</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a1d4f5ebb966db416489ac736a87fc4db"><div class="ttname"><a href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">SimpleBinaryOperator::detachPostOp</a></div><div class="ttdeci">ParseElement * detachPostOp()</div><div class="ttdoc">Detaches the operator&#39;s sub expression, returning it. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00729">parser_types.cpp:729</a></div></div>
<div class="ttc" id="classParseElement_html"><div class="ttname"><a href="classParseElement.html">ParseElement</a></div><div class="ttdoc">General parent of all self-contained, self-translating parse tree elements. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00076">parser_types.h:76</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5"><div class="ttname"><a href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00344">parser_types.h:344</a></div></div>
<div class="ttc" id="classTranslator_html_a5c11ad8502a2aeec081563dc13232462"><div class="ttname"><a href="classTranslator.html#a5c11ad8502a2aeec081563dc13232462">Translator::resolveDynamicDeclarations</a></div><div class="ttdeci">bool resolveDynamicDeclarations(BaseElementList &amp;undefined, BaseElementList &amp;reallyUndefined)</div><div class="ttdoc">Attempts to resolve dynamic declarations that weren&#39;t caught previously. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02117">Translator.cpp:2117</a></div></div>
<div class="ttc" id="classParseElement_html_aed85d01764a3f624eacc78e284b75438"><div class="ttname"><a href="classParseElement.html#aed85d01764a3f624eacc78e284b75438">ParseElement::aggregateUndefined</a></div><div class="ttdeci">virtual void aggregateUndefined(BaseElementList &amp;outIdentifiers)=0</div><div class="ttdoc">Aggregates all of the undefined identifiers (which are assumed to be constants). </div></div>
<div class="ttc" id="classTranslator_html_ac6696248ca5c08d2fa8df07838d63e1b"><div class="ttname"><a href="classTranslator.html#ac6696248ca5c08d2fa8df07838d63e1b">Translator::makeCausalTranslation</a></div><div class="ttdeci">std::ostream &amp; makeCausalTranslation(std::ostream &amp;output, StmtList &amp;extraStmts, IPart ipart, bool assumingNotNot, std::string const &amp;baseTimeStamp, ParseElement *head, ParseElement *ifBody, ParseElement *assumingBody, ParseElement *unlessBody, ParseElement *afterBody, ParseElement *whereBody)</div><div class="ttdoc">A helper function for translating causal laws. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l01236">Translator.cpp:1236</a></div></div>
<div class="ttc" id="classTranslator_html_a2c7447c0464738a176c4cc5f05397dfa"><div class="ttname"><a href="classTranslator.html#a2c7447c0464738a176c4cc5f05397dfa">Translator::outputStmts</a></div><div class="ttdeci">void outputStmts(StmtList const &amp;stmts)</div><div class="ttdoc">Outputs a list of statements to the translators output. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02266">Translator.cpp:2266</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html"><div class="ttname"><a href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a></div><div class="ttdoc">Child of ParseElement that represents a binary operator and the associated elements it operates on...</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00330">parser_types.h:330</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a5db09f10f1df45fb5ef721800c58e818"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a5db09f10f1df45fb5ef721800c58e818">ParseElement::MASK_SDFLUENT</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00091">parser_types.h:91</a></div></div>
<div class="ttc" id="classParseElement_html_aa0ff7094f640ccd042bb7fa636a5028d"><div class="ttname"><a href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants</a></div><div class="ttdeci">virtual bool hasConstants(unsigned int types, bool includeParams=true, bool includeEq=true) const =0</div><div class="ttdoc">Returns true if the element (or any of its children) are constants of the provided types...</div></div>
<div class="ttc" id="namespaceutils_html_a8f62b72e0def57deb33132dfd5d4a0ec"><div class="ttname"><a href="namespaceutils.html#a8f62b72e0def57deb33132dfd5d4a0ec">utils::to_string</a></div><div class="ttdeci">std::string to_string(T val, std::ios_base &amp;(*fmt)(std::ios_base &amp;)=std::dec, int precision=-1)</div><div class="ttdoc">Transforms something (usually a number) into a string representation of itself. </div><div class="ttdef"><b>Definition:</b> <a href="src_2cplus2asp_2utils_8h_source.html#l00088">utils.h:88</a></div></div>
<div class="ttc" id="classParseElement_html_a4499644cdb72e234a649e768fbf762be"><div class="ttname"><a href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName</a></div><div class="ttdeci">virtual std::ostream &amp; fullName(std::ostream &amp;out) const =0</div><div class="ttdoc">Prints the untranslated element string. </div></div>
<div class="ttc" id="classTranslator_html_a7c14268a49b3551907e27ba347d13e93"><div class="ttname"><a href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">Translator::error</a></div><div class="ttdeci">void error(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02076">Translator.cpp:2076</a></div></div>
<div class="ttc" id="classParseElement_html_a33f6ca61ca9b8a4d817b6407b13ff0ff"><div class="ttname"><a href="classParseElement.html#a33f6ca61ca9b8a4d817b6407b13ff0ff">ParseElement::isDefinite</a></div><div class="ttdeci">virtual bool isDefinite(bool allowComparison=false, bool allowChoice=false, bool allowAtomicNegation=false) const =0</div><div class="ttdoc">Determines if the element contains a single atom, a unary expression w/ a single atom, or a conjunction thereof. </div></div>
<div class="ttc" id="classParseElement_html_ab219939d84aea2e8c852fc414c1fa2c1"><div class="ttname"><a href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">ParseElement::parens</a></div><div class="ttdeci">void parens(bool parens)</div><div class="ttdoc">Sets whether the expression is wrapped in parentheses. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00211">parser_types.h:211</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a87319414b8aba9d9cc18c76cdf9b83de"><div class="ttname"><a href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">SimpleBinaryOperator::detachPreOp</a></div><div class="ttdeci">ParseElement * detachPreOp()</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00736">parser_types.cpp:736</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36ad80ac9dcab5a3b797a7de9857bd3f95c"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36ad80ac9dcab5a3b797a7de9857bd3f95c">ParseElement::MASK_RIGID</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00086">parser_types.h:86</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00085">parser_types.h:85</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a70009e1bf125be930e70f4eb84c892fa"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a70009e1bf125be930e70f4eb84c892fa">ParseElement::MASK_NON_RIGID</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00095">parser_types.h:95</a></div></div>
<div class="ttc" id="classTranslator_html_ae81edcdd33f60dca0b494ffdf3a856b0"><div class="ttname"><a href="classTranslator.html#ae81edcdd33f60dca0b494ffdf3a856b0">Translator::translateConstantDecl</a></div><div class="ttdeci">void translateConstantDecl(Constant const *transConst)</div><div class="ttdoc">Translates a Constant element into an ASP-compatible constant declaration. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00496">Translator.cpp:496</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36af8637dc10b0bac2ea8439e41f745899e"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36af8637dc10b0bac2ea8439e41f745899e">ParseElement::MASK_NON_TRIVIAL</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00094">parser_types.h:94</a></div></div>
<div class="ttc" id="classParseElement_html_a85faf97e4baf292e34ede3ab83d7e126"><div class="ttname"><a href="classParseElement.html#a85faf97e4baf292e34ede3ab83d7e126">ParseElement::hasLuaCalls</a></div><div class="ttdeci">virtual bool hasLuaCalls(bool includeParams=true, bool includeEq=true) const =0</div><div class="ttdoc">Determines if the element contains any calls to LUA. </div></div>
<div class="ttc" id="structsymbol_html_aafff7593df974a98ea04be2b7450091e"><div class="ttname"><a href="structsymbol.html#aafff7593df974a98ea04be2b7450091e">symbol::type</a></div><div class="ttdeci">enum symbol_type type</div><div class="ttdef"><b>Definition:</b> <a href="as2transition_2lemon_2lemon_8c_source.html#l00248">lemon.c:248</a></div></div>
<div class="ttc" id="classTranslator_html_a864d4dc33098092fef562455dc97c9e2"><div class="ttname"><a href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">Translator::lang</a></div><div class="ttdeci">Language lang() const </div><div class="ttdoc">Gets the currently active language. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00709">Translator.h:709</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00084">parser_types.h:84</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a6f7f4ccc2c65e1b21028059419b57655"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6f7f4ccc2c65e1b21028059419b57655">ParseElement::MASK_AB</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00093">parser_types.h:93</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a75fab087654bbbb9669118336b9ce489"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::translateCausalLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>ifBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>assumingBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>afterBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whenBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>followingBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper wrapper to translateCausalLaw w/o an unlessBody. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>- The head portion of the causal law ("caused head..."). </td></tr>
    <tr><td class="paramname">ifBody</td><td>- The part of the law's body associated with the if keyword ("...if ifBody..."). </td></tr>
    <tr><td class="paramname">assumingBody</td><td>- The part of the law's body associated with the if keyword ("...assuming ifBody..."). </td></tr>
    <tr><td class="paramname">afterBody</td><td>- The part of the law's body associated with the after keyword ("...after afterBody..."). </td></tr>
    <tr><td class="paramname">whereBody</td><td>- The part of the law's body associated with the where keyword ("...where whereBody."). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00364">364</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;          { <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(head, ifBody, assumingBody, afterBody, NULL, whereBody); }</div>
<div class="ttc" id="classTranslator_html_a2745b2441a5759d77e02524ec9dad4ff"><div class="ttname"><a href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">Translator::translateCausalLaw</a></div><div class="ttdeci">void translateCausalLaw(ParseElement *head, ParseElement *ifBody, ParseElement *assumingBody, ParseElement *afterBody, ParseElement *unlessBody, ParseElement *whereBody)</div><div class="ttdoc">Translates a causal law into ASP-compatible rule(s). </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00838">Translator.cpp:838</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac8b5b97e12ba10557cc4a10764616f44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::translateCausesLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>causer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>causee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>ifBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>assumingBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>unlessBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a causal law of the form "G causes F [if H] [where J]." to basic form, then calls the translator on it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">causer</td><td>- The causing action formula. </td></tr>
    <tr><td class="paramname">causee</td><td>- The formula being caused. </td></tr>
    <tr><td class="paramname">ifBody</td><td>- Optional conditional formula to govern when the law applies. </td></tr>
    <tr><td class="paramname">assumingBody</td><td>- Optional conditional formula similar to the 'ifBody', except results in edges in the dependency graph. </td></tr>
    <tr><td class="paramname">unlessBody</td><td>- Optional atom to be dynamically declared as an default-false constant. </td></tr>
    <tr><td class="paramname">whereBody</td><td>- Another conditional formula to govern when the law applies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything translates properly, false if anything goes wrong. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01741">1741</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="parser__types_8h_source.html#l00344">SimpleBinaryOperator::BOP_AND</a>, <a class="el" href="parser__types_8cpp_source.html#l00729">SimpleBinaryOperator::detachPostOp()</a>, <a class="el" href="parser__types_8cpp_source.html#l00736">SimpleBinaryOperator::detachPreOp()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>, <a class="el" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName()</a>, <a class="el" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants()</a>, <a class="el" href="parser__types_8h_source.html#l00084">ParseElement::MASK_ACTION</a>, <a class="el" href="parser__types_8h_source.html#l00085">ParseElement::MASK_FLUENT</a>, <a class="el" href="parser__types_8h_source.html#l00211">ParseElement::parens()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;{</div>
<div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;    <span class="keywordtype">bool</span> retVal = <span class="keyword">false</span>; <span class="comment">// Start pessimistic.</span></div>
<div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;    <span class="keywordflow">if</span>(causer != NULL &amp;&amp; causee != NULL)</div>
<div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;    {</div>
<div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;        <span class="comment">// Causer has to be an action formula, or the law is not properly written.</span></div>
<div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;        <span class="keywordflow">if</span>(causer-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>) &amp;&amp; !causer-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a>))</div>
<div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;        {</div>
<div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;            <span class="comment">// Causer and assumingBody are going to end up together no matter what.</span></div>
<div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;            <span class="keywordflow">if</span> (causer) causer-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;            <span class="keywordflow">if</span> (assumingBody) assumingBody-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;            <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>* tempPE = <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(causer, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, assumingBody);</div>
<div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;</div>
<div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;            <span class="comment">// Where causer and ifBody end up in the basic form depend on what&#39;s in causee.</span></div>
<div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;            <span class="keywordflow">if</span>((!causee-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a>)))</div>
<div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;            {   <span class="comment">// Causee is an action formula, this is &quot;caused F if H assuming G &amp; L&quot;.</span></div>
<div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;                <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(causee, ifBody, tempPE, NULL, unlessBody, whereBody);</div>
<div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;                retVal = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;            }</div>
<div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!causee-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>))</div>
<div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;            {   <span class="comment">// Causee is a fluent formula, this is &quot;caused F after G &amp; L &amp; H&quot;.</span></div>
<div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;                <span class="keywordflow">if</span> (ifBody) ifBody-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;                <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>* tempPE2 = <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(ifBody, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, tempPE);</div>
<div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;</div>
<div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;                <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(causee, NULL, NULL, tempPE2, unlessBody, whereBody);</div>
<div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;                tempPE2-&gt;<a class="code" href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">detachPostOp</a>();</div>
<div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;                tempPE2-&gt;<a class="code" href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">detachPreOp</a>();</div>
<div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;                <span class="keyword">delete</span> tempPE2;</div>
<div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;                retVal = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;            }</div>
<div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;            {   <span class="comment">// Causee is mixed, that isn&#39;t allowed.</span></div>
<div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;                <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + causee-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; must be a pure action formula or pure fluent formula in this law, it can&#39;t have both kinds of constants.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;            }</div>
<div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;</div>
<div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;            tempPE-&gt;<a class="code" href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">detachPostOp</a>();</div>
<div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;            tempPE-&gt;<a class="code" href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">detachPreOp</a>();</div>
<div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;            <span class="keyword">delete</span> tempPE;</div>
<div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;        }</div>
<div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;        {</div>
<div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + causer-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; is not an action formula, can&#39;t use it as G in a \&quot;G causes F\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;        }</div>
<div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;    }</div>
<div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;}</div>
<div class="ttc" id="classSimpleBinaryOperator_html_a1d4f5ebb966db416489ac736a87fc4db"><div class="ttname"><a href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">SimpleBinaryOperator::detachPostOp</a></div><div class="ttdeci">ParseElement * detachPostOp()</div><div class="ttdoc">Detaches the operator&#39;s sub expression, returning it. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00729">parser_types.cpp:729</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5"><div class="ttname"><a href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00344">parser_types.h:344</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html"><div class="ttname"><a href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a></div><div class="ttdoc">Child of ParseElement that represents a binary operator and the associated elements it operates on...</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00330">parser_types.h:330</a></div></div>
<div class="ttc" id="classTranslator_html_a2745b2441a5759d77e02524ec9dad4ff"><div class="ttname"><a href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">Translator::translateCausalLaw</a></div><div class="ttdeci">void translateCausalLaw(ParseElement *head, ParseElement *ifBody, ParseElement *assumingBody, ParseElement *afterBody, ParseElement *unlessBody, ParseElement *whereBody)</div><div class="ttdoc">Translates a causal law into ASP-compatible rule(s). </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00838">Translator.cpp:838</a></div></div>
<div class="ttc" id="classParseElement_html_aa0ff7094f640ccd042bb7fa636a5028d"><div class="ttname"><a href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants</a></div><div class="ttdeci">virtual bool hasConstants(unsigned int types, bool includeParams=true, bool includeEq=true) const =0</div><div class="ttdoc">Returns true if the element (or any of its children) are constants of the provided types...</div></div>
<div class="ttc" id="classParseElement_html_a4499644cdb72e234a649e768fbf762be"><div class="ttname"><a href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName</a></div><div class="ttdeci">virtual std::ostream &amp; fullName(std::ostream &amp;out) const =0</div><div class="ttdoc">Prints the untranslated element string. </div></div>
<div class="ttc" id="classTranslator_html_a7c14268a49b3551907e27ba347d13e93"><div class="ttname"><a href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">Translator::error</a></div><div class="ttdeci">void error(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02076">Translator.cpp:2076</a></div></div>
<div class="ttc" id="classParseElement_html_ab219939d84aea2e8c852fc414c1fa2c1"><div class="ttname"><a href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">ParseElement::parens</a></div><div class="ttdeci">void parens(bool parens)</div><div class="ttdoc">Sets whether the expression is wrapped in parentheses. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00211">parser_types.h:211</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a87319414b8aba9d9cc18c76cdf9b83de"><div class="ttname"><a href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">SimpleBinaryOperator::detachPreOp</a></div><div class="ttdeci">ParseElement * detachPreOp()</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00736">parser_types.cpp:736</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00085">parser_types.h:85</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00084">parser_types.h:84</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae81edcdd33f60dca0b494ffdf3a856b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::translateConstantDecl </td>
          <td>(</td>
          <td class="paramtype">Constant const *&#160;</td>
          <td class="paramname"><em>transConst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates a Constant element into an ASP-compatible constant declaration. </p>
<p>Sends the result to ostOut. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transConst</td><td>- The Constant element to translate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00496">496</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02140">outputClauses()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02266">outputStmts()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l02083">warn()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;{</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="comment">// Sanity check: make sure the element isn&#39;t NULL.</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    <span class="keywordflow">if</span>(transConst)</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    {</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        <span class="comment">// Detect if it&#39;s an abnormality constant and set the appropriate flag.</span></div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        <span class="keywordflow">if</span> (transConst-&gt;isAbnormal()) {</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;            blnFoundAbnormalities = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        }</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        <span class="comment">// Detect if it&#39;s an additive constant and set the appropriate flag.</span></div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        <span class="keywordflow">if</span> (transConst-&gt;isAdditive()) {</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;            blnFoundAdditive = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        }</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;        ElementCounter eCount;                                          <span class="comment">// Used to track occurrences of identical parameters (to avoid name clashes).</span></div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        std::vector&lt;std::pair&lt;Sort const*,std::string&gt; &gt; parameterMap;  <span class="comment">// An ordered mapping from variables to parameters.</span></div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        std::string translatedConst;</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <a class="code" href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">ClauseList</a> localClauses;</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        std::ostringstream stmtBuilder;                                 <span class="comment">// Used to build each individual statement required for this declaration.</span></div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;        StmtList stmts;                                                 <span class="comment">// Used to aggregate the statements we need and output them all simultaneously.</span></div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;        <span class="comment">// Translate the constant and save it for later..</span></div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        transConst-&gt;translate(stmtBuilder, localClauses, &amp;eCount, NULL, &amp;parameterMap);</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;        translatedConst = stmtBuilder.str();</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        stmtBuilder.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        </div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        <span class="comment">// Ouput the class of constant, then its translated name.</span></div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        stmtBuilder &lt;&lt; transConst-&gt;constTypeStr() &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; translatedConst &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;        <span class="keywordflow">if</span> (localClauses.size() &gt; 0) {</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;            stmtBuilder &lt;&lt; <span class="stringliteral">&quot; &lt;- &quot;</span>;</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;            <a class="code" href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">outputClauses</a>(stmtBuilder, localClauses, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;        }</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;        stmtBuilder &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;        <span class="comment">// Add the first statement to the list.</span></div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        stmts.push_back(Statement(stmtBuilder.str(),IPART_BASE));</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;        stmtBuilder.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;        </div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;        <span class="comment">// We intentionally don&#39;t clear the clause list.</span></div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;        <span class="comment">// Output the line connecting a constant to its domain.</span></div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;        <span class="keywordflow">if</span>(transConst-&gt;domain())</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;        {</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;            stmtBuilder &lt;&lt; <span class="stringliteral">&quot;constant_sort(&quot;</span> &lt;&lt; translatedConst &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;            stmtBuilder &lt;&lt; transConst-&gt;domain()-&gt;fullTransName() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;            <span class="keywordflow">if</span> (localClauses.size() &gt; 0) {</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                stmtBuilder &lt;&lt; <span class="stringliteral">&quot; &lt;- &quot;</span>;</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                <a class="code" href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">outputClauses</a>(stmtBuilder, localClauses, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;            }</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;            stmtBuilder &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;            stmts.push_back(Statement(stmtBuilder.str(), IPART_BASE));</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;            stmtBuilder.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        }</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;        <span class="comment">// If the constant is an attribute, connect the attribute to its action.</span></div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;        <span class="keywordflow">if</span>(transConst-&gt;constType() == Constant::CONST_ATTRIBUTE &amp;&amp; ((Attribute <span class="keyword">const</span>*)transConst)-&gt;parent())</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;        {</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;            stmtBuilder &lt;&lt; <span class="stringliteral">&quot;action_attribute(&quot;</span>;</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;            <span class="keywordtype">bool</span> matched = ((Attribute <span class="keyword">const</span>*)transConst)-&gt;parent()-&gt;translate(stmtBuilder, localClauses, &amp;eCount, &amp;parameterMap, NULL);</div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;            stmtBuilder &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; translatedConst &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;            <span class="keywordflow">if</span> (localClauses.size() &gt; 0) {</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                stmtBuilder &lt;&lt; <span class="stringliteral">&quot; &lt;- &quot;</span>;</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;                <a class="code" href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">outputClauses</a>(stmtBuilder, localClauses, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;            }</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            stmtBuilder &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;            <span class="keywordflow">if</span> (!matched) {</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;                <span class="comment">// The parameter prefixes don&#39;t match. Warn the user.</span></div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;                <a class="code" href="classTranslator.html#aa07bcca529cd19ad8602fb4ec5ec16d9">warn</a>(std::string(<span class="stringliteral">&quot;The attribute \&quot;&quot;</span>)</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;                        + transConst-&gt;fullName()</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                        + std::string(<span class="stringliteral">&quot;\&quot; does not contain all arguments within its parent action \&quot;&quot;</span>)</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;                        + ((Attribute <span class="keyword">const</span>*)transConst)-&gt;parent()-&gt;fullName()</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;                        + std::string(<span class="stringliteral">&quot;\&quot;. This will likely cause unintended results.&quot;</span>),</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                        <span class="keyword">true</span>,</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;                        <span class="keyword">true</span>);</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;            }</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;            stmts.push_back(Statement(stmtBuilder.str(), IPART_BASE));</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;            stmtBuilder.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;        }</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;        <span class="comment">// Output all of the statements...</span></div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;        <a class="code" href="classTranslator.html#a2c7447c0464738a176c4cc5f05397dfa">outputStmts</a>(stmts);</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;    }</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;}</div>
<div class="ttc" id="namespacecplus2asp_1_1cplus2asp__bin_html_a2fbffbd697b2a504d23669a23961be4b"><div class="ttname"><a href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">cplus2asp::cplus2asp_bin::ClauseList</a></div><div class="ttdeci">ReferencedList&lt; std::string &gt;::type ClauseList</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00027">types.h:27</a></div></div>
<div class="ttc" id="classTranslator_html_a2c7447c0464738a176c4cc5f05397dfa"><div class="ttname"><a href="classTranslator.html#a2c7447c0464738a176c4cc5f05397dfa">Translator::outputStmts</a></div><div class="ttdeci">void outputStmts(StmtList const &amp;stmts)</div><div class="ttdoc">Outputs a list of statements to the translators output. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02266">Translator.cpp:2266</a></div></div>
<div class="ttc" id="classTranslator_html_aa07bcca529cd19ad8602fb4ec5ec16d9"><div class="ttname"><a href="classTranslator.html#aa07bcca529cd19ad8602fb4ec5ec16d9">Translator::warn</a></div><div class="ttdeci">void warn(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02083">Translator.cpp:2083</a></div></div>
<div class="ttc" id="classTranslator_html_a2973b80adebf80f00ca209502465f8e5"><div class="ttname"><a href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">Translator::outputClauses</a></div><div class="ttdeci">static std::ostream &amp; outputClauses(std::ostream &amp;out, ClauseList const &amp;clauses, bool initConj=false)</div><div class="ttdoc">helper method to output multiple clauses to an output stream. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02140">Translator.cpp:2140</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="adb752725c3e0a5fe04c3b43791f6181e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::translateConstraintLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>afterBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>unlessBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a causal law of the form "constraint F [after H] [where J]." to basic form, then calls the translator for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constraint</td><td>- The condition that must be true. </td></tr>
    <tr><td class="paramname">afterBody</td><td>- Optional conditional formula specifying restrictions from the prior time step. </td></tr>
    <tr><td class="paramname">unlessBody</td><td>- Optional formula that acts as an abnormality condition. </td></tr>
    <tr><td class="paramname">whereBody</td><td>- Another conditional formula to govern when the law applies. </td></tr>
    <tr><td class="paramname">positive</td><td>- Whether the constraint is of the positive 'constraint F' form, or negative 'impossible F' form. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything translates properly, false if anything goes wrong. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01511">1511</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="parser__types_8cpp_source.html#l00355">SimpleUnaryOperator::detachPostOp()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>, <a class="el" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00382">getOrCreateObject()</a>, <a class="el" href="parser__types_8h_source.html#l00205">ParseElement::getType()</a>, <a class="el" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants()</a>, <a class="el" href="parser__types_8h_source.html#l00084">ParseElement::MASK_ACTION</a>, <a class="el" href="parser__types_8h_source.html#l00085">ParseElement::MASK_FLUENT</a>, <a class="el" href="parser__types_8h_source.html#l00086">ParseElement::MASK_RIGID</a>, <a class="el" href="parser__types_8h_source.html#l00080">ParseElement::PELEM_UOP</a>, <a class="el" href="parser__types_8h_source.html#l00301">SimpleUnaryOperator::postOp()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>, <a class="el" href="parser__types_8h_source.html#l00262">SimpleUnaryOperator::UOP_NOT</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l02083">warn()</a>.</p>
<div class="fragment"><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;{</div>
<div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;    <span class="keywordtype">bool</span> retVal = <span class="keyword">false</span>; <span class="comment">// Start pessimistic.</span></div>
<div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;    <span class="keywordflow">if</span>(constraint != NULL)</div>
<div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;    {</div>
<div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;        <span class="comment">// constraint has to be a fluent formula or the law is malformed. Soft warn if we can&#39;t tell what it is (i.e., not a fluent or action formula).</span></div>
<div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;        <span class="keywordflow">if</span>(!constraint-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>))</div>
<div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;        {</div>
<div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;            <span class="keywordflow">if</span>(!constraint-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a>|<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36ad80ac9dcab5a3b797a7de9857bd3f95c">ParseElement::MASK_RIGID</a>))</div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;            {</div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;                <a class="code" href="classTranslator.html#aa07bcca529cd19ad8602fb4ec5ec16d9">warn</a>(<span class="stringliteral">&quot;Cannot determine if \&quot;&quot;</span> + constraint-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; is a fluent formula or not, it might not work as F in a \&quot;constraint F\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;            }</div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;</div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;            <span class="comment">// &quot;not constraint&quot; is the ifBody.</span></div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;            <a class="code" href="classParseElement.html">ParseElement</a>* tempPE = NULL; <span class="comment">// Points at whatever ends up becoming the head of the rule.</span></div>
<div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;            <a class="code" href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a>* tempUOP = NULL;</div>
<div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;</div>
<div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;            <span class="keywordflow">if</span> (positive) {</div>
<div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;                <span class="comment">// If the constraint is &quot;not something&quot;, then we can just drop the not (we&#39;d end up with &quot;not not something&quot;, which is equivalent to &quot;something&quot; since &quot;false&quot; is the head).</span></div>
<div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;                <span class="keywordflow">if</span>(constraint-&gt;<a class="code" href="classParseElement.html#acab69fbd8bec17b1260eec96c4747a6d">getType</a>() == <a class="code" href="classParseElement.html#a332651d3e938a02b564cd4c4f4decb0fa7fccd0167262c688ad1ecf400e2695f5">ParseElement::PELEM_UOP</a></div>
<div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;                        &amp;&amp; ((<a class="code" href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a>*)constraint)-&gt;opType() == <a class="code" href="classSimpleUnaryOperator.html#ac0a7153989edd90defb764943758827aa2521e3f2084fe2a72431630a1f6eeb37">SimpleUnaryOperator::UOP_NOT</a>)</div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;                {</div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;                    tempPE = ((<a class="code" href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a>*)constraint)-&gt;detachPostOp();</div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;                }</div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;                <span class="keywordflow">else</span></div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;                {   <span class="comment">// It&#39;s not an optimizable case, just tack &quot;not&quot; onto the constraint.</span></div>
<div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;                    tempPE = tempUOP = <span class="keyword">new</span> <a class="code" href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a>(<a class="code" href="classSimpleUnaryOperator.html#ac0a7153989edd90defb764943758827aa2521e3f2084fe2a72431630a1f6eeb37">SimpleUnaryOperator::UOP_NOT</a>, constraint);</div>
<div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;                }</div>
<div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;            }</div>
<div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;            <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;                <span class="comment">// We are working with the negative version of the constraint, we don&#39;t have to negate the body.</span></div>
<div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;                tempPE = constraint;</div>
<div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;            }</div>
<div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;</div>
<div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;            <span class="comment">// The head is &quot;false&quot;.</span></div>
<div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;            <a class="code" href="classObjectLikeElement.html">ObjectLikeElement</a>* tempObj = <span class="keyword">new</span> <a class="code" href="classObjectLikeElement.html">ObjectLikeElement</a>(<span class="stringliteral">&quot;false&quot;</span>, <a class="code" href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">getOrCreateObject</a>(<span class="stringliteral">&quot;false&quot;</span>));</div>
<div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;</div>
<div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;            <span class="comment">// The law becomes &quot;caused false if -F after H where L.&quot;</span></div>
<div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;            <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(tempObj, tempPE, NULL, afterBody, unlessBody, whereBody);</div>
<div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;            <span class="keyword">delete</span> tempObj;</div>
<div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;            <span class="keywordflow">if</span> (tempUOP) {</div>
<div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;                tempUOP-&gt;<a class="code" href="classSimpleUnaryOperator.html#a7327224ac87e0b3d511c8d84295ff980">detachPostOp</a>();</div>
<div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;                <span class="keyword">delete</span> tempUOP;</div>
<div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (tempPE != constraint) {</div>
<div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;                <span class="comment">// Put the constraint&#39;s postop back, just in case.</span></div>
<div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;                ((<a class="code" href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a>*)constraint)-&gt;<a class="code" href="classSimpleUnaryOperator.html#ace20ebab0aafafc6a48e98202c7439bc">postOp</a>(tempPE);</div>
<div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;            }</div>
<div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;            retVal = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;        }</div>
<div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;        {</div>
<div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + constraint-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; is not a fluent formula, can&#39;t use it as F in a \&quot;constraint F\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;        }</div>
<div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;    }</div>
<div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;}</div>
<div class="ttc" id="classObjectLikeElement_html"><div class="ttname"><a href="classObjectLikeElement.html">ObjectLikeElement</a></div><div class="ttdoc">Child of BaseLikeElement that represents a base element with the behavior of an object. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00786">parser_types.h:786</a></div></div>
<div class="ttc" id="classParseElement_html_a332651d3e938a02b564cd4c4f4decb0fa7fccd0167262c688ad1ecf400e2695f5"><div class="ttname"><a href="classParseElement.html#a332651d3e938a02b564cd4c4f4decb0fa7fccd0167262c688ad1ecf400e2695f5">ParseElement::PELEM_UOP</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00080">parser_types.h:80</a></div></div>
<div class="ttc" id="classSimpleUnaryOperator_html_a7327224ac87e0b3d511c8d84295ff980"><div class="ttname"><a href="classSimpleUnaryOperator.html#a7327224ac87e0b3d511c8d84295ff980">SimpleUnaryOperator::detachPostOp</a></div><div class="ttdeci">ParseElement * detachPostOp()</div><div class="ttdoc">Detaches the operator&#39;s sub expression, returning it. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00355">parser_types.cpp:355</a></div></div>
<div class="ttc" id="classParseElement_html_acab69fbd8bec17b1260eec96c4747a6d"><div class="ttname"><a href="classParseElement.html#acab69fbd8bec17b1260eec96c4747a6d">ParseElement::getType</a></div><div class="ttdeci">ParseElementType getType() const </div><div class="ttdoc">Gets the type of the parse element. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00205">parser_types.h:205</a></div></div>
<div class="ttc" id="classSimpleUnaryOperator_html_ace20ebab0aafafc6a48e98202c7439bc"><div class="ttname"><a href="classSimpleUnaryOperator.html#ace20ebab0aafafc6a48e98202c7439bc">SimpleUnaryOperator::postOp</a></div><div class="ttdeci">ParseElement const * postOp() const </div><div class="ttdoc">Gets the operator&#39;s sub expression. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00301">parser_types.h:301</a></div></div>
<div class="ttc" id="classParseElement_html"><div class="ttname"><a href="classParseElement.html">ParseElement</a></div><div class="ttdoc">General parent of all self-contained, self-translating parse tree elements. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00076">parser_types.h:76</a></div></div>
<div class="ttc" id="classSimpleUnaryOperator_html_ac0a7153989edd90defb764943758827aa2521e3f2084fe2a72431630a1f6eeb37"><div class="ttname"><a href="classSimpleUnaryOperator.html#ac0a7153989edd90defb764943758827aa2521e3f2084fe2a72431630a1f6eeb37">SimpleUnaryOperator::UOP_NOT</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00262">parser_types.h:262</a></div></div>
<div class="ttc" id="classTranslator_html_aa07bcca529cd19ad8602fb4ec5ec16d9"><div class="ttname"><a href="classTranslator.html#aa07bcca529cd19ad8602fb4ec5ec16d9">Translator::warn</a></div><div class="ttdeci">void warn(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02083">Translator.cpp:2083</a></div></div>
<div class="ttc" id="classTranslator_html_a2745b2441a5759d77e02524ec9dad4ff"><div class="ttname"><a href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">Translator::translateCausalLaw</a></div><div class="ttdeci">void translateCausalLaw(ParseElement *head, ParseElement *ifBody, ParseElement *assumingBody, ParseElement *afterBody, ParseElement *unlessBody, ParseElement *whereBody)</div><div class="ttdoc">Translates a causal law into ASP-compatible rule(s). </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00838">Translator.cpp:838</a></div></div>
<div class="ttc" id="classParseElement_html_aa0ff7094f640ccd042bb7fa636a5028d"><div class="ttname"><a href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants</a></div><div class="ttdeci">virtual bool hasConstants(unsigned int types, bool includeParams=true, bool includeEq=true) const =0</div><div class="ttdoc">Returns true if the element (or any of its children) are constants of the provided types...</div></div>
<div class="ttc" id="classParseElement_html_a4499644cdb72e234a649e768fbf762be"><div class="ttname"><a href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName</a></div><div class="ttdeci">virtual std::ostream &amp; fullName(std::ostream &amp;out) const =0</div><div class="ttdoc">Prints the untranslated element string. </div></div>
<div class="ttc" id="classTranslator_html_a7c14268a49b3551907e27ba347d13e93"><div class="ttname"><a href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">Translator::error</a></div><div class="ttdeci">void error(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02076">Translator.cpp:2076</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36ad80ac9dcab5a3b797a7de9857bd3f95c"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36ad80ac9dcab5a3b797a7de9857bd3f95c">ParseElement::MASK_RIGID</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00086">parser_types.h:86</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00085">parser_types.h:85</a></div></div>
<div class="ttc" id="classTranslator_html_ab255d800190701bc36af2f4b7582c1d0"><div class="ttname"><a href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">Translator::getOrCreateObject</a></div><div class="ttdeci">Object * getOrCreateObject(std::string const &amp;symName, Object::ObjectType type=Object::OBJ_NAME, bool internal=false, size_t arity=0)</div><div class="ttdoc">Helper function for getting an Object type reference or dynamically adding it if it doesn&#39;t occur...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00382">Translator.cpp:382</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00084">parser_types.h:84</a></div></div>
<div class="ttc" id="classSimpleUnaryOperator_html"><div class="ttname"><a href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a></div><div class="ttdoc">Child of ParseElement that represents a unary operator and the associated elements it operates on...</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00258">parser_types.h:258</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5b01f7354c40ab8005ee08e87a791579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::translateDeclarativeLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>ifBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>assumingBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>afterBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>unlessBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimpleUnaryOperator.html#ac0a7153989edd90defb764943758827a">SimpleUnaryOperator::UnaryOperatorType</a>&#160;</td>
          <td class="paramname"><em>opType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms declarative laws ("inertial p", "exogenous a(X)", "rigid q", etc.) to basic form and calls the translator for them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>- The head of the law, in this case a bare constant-like expression. </td></tr>
    <tr><td class="paramname">ifBody</td><td>- Optional conditional formula to govern when the law applies. </td></tr>
    <tr><td class="paramname">assumingBody</td><td>- Optional conditional formula similar to the 'ifBody', except results in edges in the dependency graph. </td></tr>
    <tr><td class="paramname">afterBody</td><td>- Optional conditional formula specifying conditions from the prior time step. </td></tr>
    <tr><td class="paramname">unlessBody</td><td>- Optional formula that acts as an abnormality condition. </td></tr>
    <tr><td class="paramname">whereBody</td><td>- Another conditional formula to govern when the law applies. </td></tr>
    <tr><td class="paramname">opType</td><td>- The kind of declaration this is (exogenous, inertial, etc.). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything translates properly, false if anything goes wrong. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01458">1458</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="parser__types_8cpp_source.html#l00355">SimpleUnaryOperator::detachPostOp()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;{</div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;    <span class="keywordtype">bool</span> retVal = <span class="keyword">false</span>; <span class="comment">// Start pessimistic.</span></div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;    <span class="keywordflow">if</span>(head != NULL)</div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;    {</div>
<div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;        <span class="comment">// head needs to be wrapped in the appropriate declarative operator.</span></div>
<div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;        <a class="code" href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a>* tempPE = <span class="keyword">new</span> <a class="code" href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a>(opType, head);</div>
<div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;</div>
<div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;        <span class="comment">// This law becomes &quot;delaration(F) [if G] [after H] [unless J] [when K] [following L] [where M].&quot;</span></div>
<div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;        <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(tempPE, ifBody, assumingBody, afterBody, unlessBody, whereBody);</div>
<div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;        retVal = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;</div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;        tempPE-&gt;<a class="code" href="classSimpleUnaryOperator.html#a7327224ac87e0b3d511c8d84295ff980">detachPostOp</a>();</div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;        <span class="keyword">delete</span> tempPE;</div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;    }</div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;}</div>
<div class="ttc" id="classSimpleUnaryOperator_html_a7327224ac87e0b3d511c8d84295ff980"><div class="ttname"><a href="classSimpleUnaryOperator.html#a7327224ac87e0b3d511c8d84295ff980">SimpleUnaryOperator::detachPostOp</a></div><div class="ttdeci">ParseElement * detachPostOp()</div><div class="ttdoc">Detaches the operator&#39;s sub expression, returning it. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00355">parser_types.cpp:355</a></div></div>
<div class="ttc" id="classTranslator_html_a2745b2441a5759d77e02524ec9dad4ff"><div class="ttname"><a href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">Translator::translateCausalLaw</a></div><div class="ttdeci">void translateCausalLaw(ParseElement *head, ParseElement *ifBody, ParseElement *assumingBody, ParseElement *afterBody, ParseElement *unlessBody, ParseElement *whereBody)</div><div class="ttdoc">Translates a causal law into ASP-compatible rule(s). </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00838">Translator.cpp:838</a></div></div>
<div class="ttc" id="classSimpleUnaryOperator_html"><div class="ttname"><a href="classSimpleUnaryOperator.html">SimpleUnaryOperator</a></div><div class="ttdoc">Child of ParseElement that represents a unary operator and the associated elements it operates on...</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00258">parser_types.h:258</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac188d9ed1e5882268f3eb29f21e2c6d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::translateDefaultLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>ifBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>assumingBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>afterBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>unlessBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a causal law of the form "default F [if G] [after H] [where J]." to basic form, then calls the translator on it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>- The head of the law. </td></tr>
    <tr><td class="paramname">ifBody</td><td>- Optional conditional formula to govern when the law applies. </td></tr>
    <tr><td class="paramname">assumingBody</td><td>- Optional conditional formula similar to the 'ifBody', except results in edges in the dependency graph. </td></tr>
    <tr><td class="paramname">afterBody</td><td>- Optional conditional formula specifying conditions from the prior time step. </td></tr>
    <tr><td class="paramname">unlessBody</td><td>- Optional atom to be dynamically declared as an default-false constant. </td></tr>
    <tr><td class="paramname">whenBody</td><td>- Optional conditional formula specifying abnormalities in the current time step. </td></tr>
    <tr><td class="paramname">followingBody</td><td>- Optional conditional formula specifying abnormalities in the previous time step. </td></tr>
    <tr><td class="paramname">whereBody</td><td>- Another conditional formula to govern when the law applies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything translates properly, false if anything goes wrong. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01575">1575</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="parser__types_8h_source.html#l00344">SimpleBinaryOperator::BOP_AND</a>, <a class="el" href="parser__types_8cpp_source.html#l00729">SimpleBinaryOperator::detachPostOp()</a>, <a class="el" href="parser__types_8cpp_source.html#l00736">SimpleBinaryOperator::detachPreOp()</a>, <a class="el" href="parser__types_8h_source.html#l00211">ParseElement::parens()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;{</div>
<div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;    <span class="keywordtype">bool</span> retVal = <span class="keyword">false</span>; <span class="comment">// Start pessimistic.</span></div>
<div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;    <span class="keywordflow">if</span>(head != NULL)</div>
<div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;    {</div>
<div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;        <span class="comment">// head and ifBody are going to end up together no matter what.</span></div>
<div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;        <span class="keywordflow">if</span> (head) head-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;        <span class="keywordflow">if</span> (assumingBody) assumingBody-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;        <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>* tempPE = <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(head, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, assumingBody);</div>
<div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;</div>
<div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;        <span class="comment">// This law becomes &quot;caused F if G assuming F [&amp; H] [after J] [where M].&quot;</span></div>
<div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;        <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(head, ifBody, tempPE, afterBody, unlessBody, whereBody);</div>
<div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;        retVal = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;</div>
<div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;        tempPE-&gt;<a class="code" href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">detachPostOp</a>();</div>
<div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;        tempPE-&gt;<a class="code" href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">detachPreOp</a>();</div>
<div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;        <span class="keyword">delete</span> tempPE;</div>
<div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;</div>
<div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;    }</div>
<div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;}</div>
<div class="ttc" id="classSimpleBinaryOperator_html_a1d4f5ebb966db416489ac736a87fc4db"><div class="ttname"><a href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">SimpleBinaryOperator::detachPostOp</a></div><div class="ttdeci">ParseElement * detachPostOp()</div><div class="ttdoc">Detaches the operator&#39;s sub expression, returning it. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00729">parser_types.cpp:729</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5"><div class="ttname"><a href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00344">parser_types.h:344</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html"><div class="ttname"><a href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a></div><div class="ttdoc">Child of ParseElement that represents a binary operator and the associated elements it operates on...</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00330">parser_types.h:330</a></div></div>
<div class="ttc" id="classTranslator_html_a2745b2441a5759d77e02524ec9dad4ff"><div class="ttname"><a href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">Translator::translateCausalLaw</a></div><div class="ttdeci">void translateCausalLaw(ParseElement *head, ParseElement *ifBody, ParseElement *assumingBody, ParseElement *afterBody, ParseElement *unlessBody, ParseElement *whereBody)</div><div class="ttdoc">Translates a causal law into ASP-compatible rule(s). </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00838">Translator.cpp:838</a></div></div>
<div class="ttc" id="classParseElement_html_ab219939d84aea2e8c852fc414c1fa2c1"><div class="ttname"><a href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">ParseElement::parens</a></div><div class="ttdeci">void parens(bool parens)</div><div class="ttdoc">Sets whether the expression is wrapped in parentheses. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00211">parser_types.h:211</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a87319414b8aba9d9cc18c76cdf9b83de"><div class="ttname"><a href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">SimpleBinaryOperator::detachPreOp</a></div><div class="ttdeci">ParseElement * detachPreOp()</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00736">parser_types.cpp:736</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa6d4577d2e194a8ad15cdf11103ff278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::translateIncrementLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>causer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>causee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>ifBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>assumingBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>unlessBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isIncrement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a causal law of the form "A increments B by N [if H] [where J]." to basic form, then calls the translator on it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">causer</td><td>- The causing action. </td></tr>
    <tr><td class="paramname">causee</td><td>- The additive constant being incremented. </td></tr>
    <tr><td class="paramname">increment</td><td>- The increment expression </td></tr>
    <tr><td class="paramname">ifBody</td><td>- Optional conditional formula to govern when the law applies. </td></tr>
    <tr><td class="paramname">assumingBody</td><td>- Optional conditional formula similar to the 'ifBody', except results in edges in the dependency graph. </td></tr>
    <tr><td class="paramname">unlessBody</td><td>- Optional atom to be dynamically declared as an default-false constant. </td></tr>
    <tr><td class="paramname">whereBody</td><td>- Another conditional formula to govern when the law applies. </td></tr>
    <tr><td class="paramname">isIncrement</td><td>- True if the law is increment, false if it is decrement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything translates properly, false if anything goes wrong. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01796">1796</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="parser__types_8h_source.html#l00344">SimpleBinaryOperator::BOP_AND</a>, <a class="el" href="parser__types_8h_source.html#l00349">SimpleBinaryOperator::BOP_EQ</a>, <a class="el" href="parser__types_8h_source.html#l00341">SimpleBinaryOperator::BOP_TIMES</a>, <a class="el" href="parser__types_8h_source.html#l00656">BaseLikeElement::detachParams()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>, <a class="el" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName()</a>, <a class="el" href="old_2Translator_8h_source.html#l00210">getConstant()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00382">getOrCreateObject()</a>, <a class="el" href="parser__types_8h_source.html#l00205">ParseElement::getType()</a>, <a class="el" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants()</a>, <a class="el" href="classParseElement.html#a6c99027be209f067d3e4074457ccf4d0">ParseElement::isArithExpr()</a>, <a class="el" href="parser__types_8h_source.html#l00084">ParseElement::MASK_ACTION</a>, <a class="el" href="parser__types_8h_source.html#l00085">ParseElement::MASK_FLUENT</a>, <a class="el" href="parser__types_8h_source.html#l00211">ParseElement::parens()</a>, <a class="el" href="parser__types_8h_source.html#l00080">ParseElement::PELEM_CONSTLIKE</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;{</div>
<div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;    <a class="code" href="classParseElement.html">ParseElement</a>* inc_expr = NULL;</div>
<div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;    <a class="code" href="classConstantLikeElement.html">ConstantLikeElement</a>* contrib = NULL;</div>
<div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;    <a class="code" href="classParseElement.html">ParseElement</a>* head, *newIf = NULL;</div>
<div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;</div>
<div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;    std::list&lt;SimpleBinaryOperator*&gt; tmpBinOps;</div>
<div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;    std::list&lt;BaseLikeElement*&gt; tmpBaseElems;</div>
<div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;</div>
<div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;    <span class="keywordtype">bool</span> malformed = <span class="keyword">false</span>;</div>
<div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;</div>
<div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;    <span class="comment">// Some checking...</span></div>
<div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;</div>
<div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;    <span class="keywordflow">if</span>(!causer || !causee || !increment ) {</div>
<div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;An error occurred while parsing the incremental law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;    }</div>
<div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;</div>
<div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;    <span class="comment">/*********************************************************/</span></div>
<div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;    <span class="comment">/* Check the causer */</span></div>
<div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;    <span class="comment">/*********************************************************/</span></div>
<div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;</div>
<div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;    <span class="keywordflow">if</span> (causer-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a>)</div>
<div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;        || !causer-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>)</div>
<div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;        || causer-&gt;<a class="code" href="classParseElement.html#acab69fbd8bec17b1260eec96c4747a6d">getType</a>() != <a class="code" href="classParseElement.html#a332651d3e938a02b564cd4c4f4decb0fade3acc8b22d851c69145a2e268f8904d">ParseElement::PELEM_CONSTLIKE</a>)</div>
<div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;    {</div>
<div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + causer-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; is not a boolean action, can&#39;t use it as A in a \&quot;A increments B by N\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;</div>
<div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;    }</div>
<div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!((<a class="code" href="classConstantLikeElement.html">ConstantLikeElement</a>*)causer)-&gt;ref()</div>
<div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;        || !((<a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a> <span class="keyword">const</span>*)((<a class="code" href="classConstantLikeElement.html">ConstantLikeElement</a>*)causer)-&gt;ref())-&gt;domain())</div>
<div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;    {</div>
<div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + causer-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; does not appear to be properly declared, can&#39;t use it as A in a \&quot;A increments B by N\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;    }</div>
<div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!((<a class="code" href="classConstantLikeElement.html">ConstantLikeElement</a>*)causer)-&gt;isBoolean())</div>
<div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;    {</div>
<div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + causer-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; is not a boolean action, can&#39;t use it as A in a \&quot;A increments B by N\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;    }</div>
<div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;</div>
<div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;    <span class="comment">/*********************************************************/</span></div>
<div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;    <span class="comment">/* Check the causee */</span></div>
<div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;    <span class="comment">/*********************************************************/</span></div>
<div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;</div>
<div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;    <span class="keywordtype">bool</span> isAction = causee-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>);</div>
<div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;    <span class="keywordtype">bool</span> isFluent = causee-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a>);</div>
<div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;</div>
<div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;    <span class="keywordflow">if</span> ((!isAction &amp;&amp; !isFluent) || (isAction &amp;&amp; isFluent)</div>
<div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;        || causee-&gt;<a class="code" href="classParseElement.html#acab69fbd8bec17b1260eec96c4747a6d">getType</a>() != <a class="code" href="classParseElement.html#a332651d3e938a02b564cd4c4f4decb0fade3acc8b22d851c69145a2e268f8904d">ParseElement::PELEM_CONSTLIKE</a>)</div>
<div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;    {</div>
<div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + causee-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; is not an additive constant, can&#39;t use it as B in a \&quot;A increments B by N\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;    }</div>
<div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!((<a class="code" href="classConstantLikeElement.html">ConstantLikeElement</a>*)causee)-&gt;ref()</div>
<div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;        || !((<a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a> <span class="keyword">const</span>*)((<a class="code" href="classConstantLikeElement.html">ConstantLikeElement</a>*)causee)-&gt;ref())-&gt;domain())</div>
<div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;    {</div>
<div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + causee-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; does not appear to be properly declared, can&#39;t use it as B in a \&quot;A increments B by N\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;    }</div>
<div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;</div>
<div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!((<a class="code" href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">Constant</a> <span class="keyword">const</span>*)((<a class="code" href="classConstantLikeElement.html">ConstantLikeElement</a>*)causee)-&gt;ref())-&gt;isAdditive())</div>
<div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;    {</div>
<div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + causee-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; is not an additive constant, can&#39;t use it as B in a \&quot;A increments B by N\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;    }</div>
<div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;</div>
<div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;    <span class="comment">/*********************************************************/</span></div>
<div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;    <span class="comment">/* Check the Increment Clause */</span></div>
<div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;    <span class="comment">/*********************************************************/</span></div>
<div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;</div>
<div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;    <span class="keywordflow">if</span> (!increment-&gt;<a class="code" href="classParseElement.html#a6c99027be209f067d3e4074457ccf4d0">isArithExpr</a>()) {</div>
<div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;        <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>( <span class="stringliteral">&quot;\&quot;&quot;</span> + increment-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; does not appear to be a valid arithmetic expression, can&#39;t use it as N in a \&quot;A increments B by N\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;        malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;    }</div>
<div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;</div>
<div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;    <span class="comment">/**************************************************************/</span></div>
<div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;    <span class="comment">/* Done Checking */</span></div>
<div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;    <span class="comment">/**************************************************************/</span></div>
<div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;</div>
<div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;    <span class="keywordflow">if</span> (malformed) {</div>
<div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;    }</div>
<div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;</div>
<div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;    <span class="comment">// At this point, we know that the critical portions of the law appear to be</span></div>
<div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;    <span class="comment">// correct. We can procede with the translation.</span></div>
<div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;</div>
<div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;    <span class="comment">// Step one is to step up the atomic formula that will be in the head of our law.</span></div>
<div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;</div>
<div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;</div>
<div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;    <span class="comment">// Craft the LHS of the atomic formula</span></div>
<div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;    ParseElementList tmpParams;</div>
<div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;    tmpParams.push_back(causer);</div>
<div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;    tmpParams.push_back(causee);</div>
<div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;    tmpBaseElems.push_back(contrib = <span class="keyword">new</span> <a class="code" href="classConstantLikeElement.html">ConstantLikeElement</a>(<span class="stringliteral">&quot;contribution&quot;</span>, <a class="code" href="classTranslator.html#ae973090fa0d53bbf36bef3ccf6f50439">getConstant</a>(<span class="stringliteral">&quot;contribution&quot;</span>, 2), &amp;tmpParams));</div>
<div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;</div>
<div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;    <span class="comment">// Determine the RHS of the atomic formula.</span></div>
<div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;    <span class="keywordflow">if</span> (isIncrement) {</div>
<div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;        inc_expr = increment;</div>
<div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;    } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;        tmpBaseElems.push_back(<span class="keyword">new</span> <a class="code" href="classObjectLikeElement.html">ObjectLikeElement</a>(<span class="stringliteral">&quot;-1&quot;</span>, <a class="code" href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">getOrCreateObject</a>(<span class="stringliteral">&quot;-1&quot;</span>)));</div>
<div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;        <span class="keywordflow">if</span> (increment) increment-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;        inc_expr = <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(tmpBaseElems.back(), <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdea81795aa2b720697f2b4e236a8a0ee7bd">SimpleBinaryOperator::BOP_TIMES</a>, increment);</div>
<div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;        tmpBinOps.push_back((<a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>*) inc_expr);</div>
<div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;    }</div>
<div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;</div>
<div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;    <span class="comment">// Craft the atomic formula</span></div>
<div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;</div>
<div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;    <span class="comment">//if (inc_expr) inc_expr-&gt;parens(true);</span></div>
<div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;    head = <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(contrib, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdea4443e8048fb3f8cb9d25b9e201d43fef">SimpleBinaryOperator::BOP_EQ</a>, inc_expr);</div>
<div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;    tmpBinOps.push_back((<a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>*) head);</div>
<div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;</div>
<div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;    <span class="comment">// Step 2 is to craft the new if clause....</span></div>
<div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;    <span class="comment">// The new if body is the result of conjoining the old ifBody</span></div>
<div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;    <span class="comment">// with the boolean causer action.</span></div>
<div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;</div>
<div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;</div>
<div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;    <span class="keywordflow">if</span> (causer) causer-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;    tmpBaseElems.push_back(<span class="keyword">new</span> <a class="code" href="classObjectLikeElement.html">ObjectLikeElement</a>(<span class="stringliteral">&quot;true&quot;</span>, <a class="code" href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">getOrCreateObject</a>(<span class="stringliteral">&quot;true&quot;</span>)));</div>
<div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;    tmpBinOps.push_back(<span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(causer, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdea4443e8048fb3f8cb9d25b9e201d43fef">SimpleBinaryOperator::BOP_EQ</a>, tmpBaseElems.back()));</div>
<div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;</div>
<div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;    <span class="keywordflow">if</span> (ifBody || assumingBody) tmpBinOps.back()-&gt;parens(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;</div>
<div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;</div>
<div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;    <span class="keywordflow">if</span> (ifBody) {</div>
<div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;        ifBody-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;        tmpBinOps.push_back(<span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(tmpBinOps.back(), <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, ifBody));</div>
<div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;    }</div>
<div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;</div>
<div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;    <span class="keywordflow">if</span> (assumingBody) {</div>
<div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;        assumingBody-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;        tmpBinOps.push_back(<span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(tmpBinOps.back(), <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, assumingBody));</div>
<div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;    }</div>
<div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;</div>
<div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;    newIf = tmpBinOps.back();       </div>
<div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;    </div>
<div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;    <span class="comment">// Finally, translate!</span></div>
<div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;    <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(head, newIf, NULL, NULL, unlessBody, whereBody);</div>
<div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;</div>
<div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;    <span class="comment">// Clean up!</span></div>
<div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;    <span class="keywordflow">for</span> (std::list&lt;SimpleBinaryOperator*&gt;::iterator it = tmpBinOps.begin(); it != tmpBinOps.end(); it++) {</div>
<div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;        (*it)-&gt;detachPostOp();</div>
<div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;        (*it)-&gt;detachPreOp();</div>
<div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;        <span class="keyword">delete</span> *it;</div>
<div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;    }</div>
<div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;    contrib-&gt;<a class="code" href="classBaseLikeElement.html#a8ecda112402f5ee1e33452633a734038">detachParams</a>();</div>
<div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;</div>
<div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;    <span class="keywordflow">for</span> (std::list&lt;BaseLikeElement*&gt;::iterator it = tmpBaseElems.begin(); it != tmpBaseElems.end(); it++) {</div>
<div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;        <span class="keyword">delete</span> *it;</div>
<div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;    }</div>
<div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;</div>
<div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;}</div>
<div class="ttc" id="classObjectLikeElement_html"><div class="ttname"><a href="classObjectLikeElement.html">ObjectLikeElement</a></div><div class="ttdoc">Child of BaseLikeElement that represents a base element with the behavior of an object. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00786">parser_types.h:786</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a4540d8cb2db758d9d780596224519cdea81795aa2b720697f2b4e236a8a0ee7bd"><div class="ttname"><a href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdea81795aa2b720697f2b4e236a8a0ee7bd">SimpleBinaryOperator::BOP_TIMES</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00341">parser_types.h:341</a></div></div>
<div class="ttc" id="namespacebcplus_1_1elements_html_ab532875292bfd1ac4993edaced4d8266"><div class="ttname"><a href="namespacebcplus_1_1elements.html#ab532875292bfd1ac4993edaced4d8266">bcplus::elements::Constant</a></div><div class="ttdeci">detail::IdentifierElement&lt; Term, detail::TermType::CONSTANT, symbols::ConstantSymbol, Term &gt; Constant</div><div class="ttdoc">A bare constant &#39;c&#39;. </div><div class="ttdef"><b>Definition:</b> <a href="terms_8h_source.html#l00189">terms.h:189</a></div></div>
<div class="ttc" id="classParseElement_html_acab69fbd8bec17b1260eec96c4747a6d"><div class="ttname"><a href="classParseElement.html#acab69fbd8bec17b1260eec96c4747a6d">ParseElement::getType</a></div><div class="ttdeci">ParseElementType getType() const </div><div class="ttdoc">Gets the type of the parse element. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00205">parser_types.h:205</a></div></div>
<div class="ttc" id="classBaseLikeElement_html_a8ecda112402f5ee1e33452633a734038"><div class="ttname"><a href="classBaseLikeElement.html#a8ecda112402f5ee1e33452633a734038">BaseLikeElement::detachParams</a></div><div class="ttdeci">void detachParams()</div><div class="ttdoc">Clears the list of parameters without deallocating them. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00656">parser_types.h:656</a></div></div>
<div class="ttc" id="classParseElement_html"><div class="ttname"><a href="classParseElement.html">ParseElement</a></div><div class="ttdoc">General parent of all self-contained, self-translating parse tree elements. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00076">parser_types.h:76</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5"><div class="ttname"><a href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00344">parser_types.h:344</a></div></div>
<div class="ttc" id="classTranslator_html_ae973090fa0d53bbf36bef3ccf6f50439"><div class="ttname"><a href="classTranslator.html#ae973090fa0d53bbf36bef3ccf6f50439">Translator::getConstant</a></div><div class="ttdeci">Constant * getConstant(std::string const &amp;name, size_t arity=0)</div><div class="ttdoc">Finds a constant identifier associated with the name/arity (or NULL);. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00210">Translator.h:210</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html"><div class="ttname"><a href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a></div><div class="ttdoc">Child of ParseElement that represents a binary operator and the associated elements it operates on...</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00330">parser_types.h:330</a></div></div>
<div class="ttc" id="classTranslator_html_a2745b2441a5759d77e02524ec9dad4ff"><div class="ttname"><a href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">Translator::translateCausalLaw</a></div><div class="ttdeci">void translateCausalLaw(ParseElement *head, ParseElement *ifBody, ParseElement *assumingBody, ParseElement *afterBody, ParseElement *unlessBody, ParseElement *whereBody)</div><div class="ttdoc">Translates a causal law into ASP-compatible rule(s). </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00838">Translator.cpp:838</a></div></div>
<div class="ttc" id="classParseElement_html_a332651d3e938a02b564cd4c4f4decb0fade3acc8b22d851c69145a2e268f8904d"><div class="ttname"><a href="classParseElement.html#a332651d3e938a02b564cd4c4f4decb0fade3acc8b22d851c69145a2e268f8904d">ParseElement::PELEM_CONSTLIKE</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00080">parser_types.h:80</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a4540d8cb2db758d9d780596224519cdea4443e8048fb3f8cb9d25b9e201d43fef"><div class="ttname"><a href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdea4443e8048fb3f8cb9d25b9e201d43fef">SimpleBinaryOperator::BOP_EQ</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00349">parser_types.h:349</a></div></div>
<div class="ttc" id="classParseElement_html_aa0ff7094f640ccd042bb7fa636a5028d"><div class="ttname"><a href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants</a></div><div class="ttdeci">virtual bool hasConstants(unsigned int types, bool includeParams=true, bool includeEq=true) const =0</div><div class="ttdoc">Returns true if the element (or any of its children) are constants of the provided types...</div></div>
<div class="ttc" id="classParseElement_html_a4499644cdb72e234a649e768fbf762be"><div class="ttname"><a href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName</a></div><div class="ttdeci">virtual std::ostream &amp; fullName(std::ostream &amp;out) const =0</div><div class="ttdoc">Prints the untranslated element string. </div></div>
<div class="ttc" id="classTranslator_html_a7c14268a49b3551907e27ba347d13e93"><div class="ttname"><a href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">Translator::error</a></div><div class="ttdeci">void error(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02076">Translator.cpp:2076</a></div></div>
<div class="ttc" id="classParseElement_html_ab219939d84aea2e8c852fc414c1fa2c1"><div class="ttname"><a href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">ParseElement::parens</a></div><div class="ttdeci">void parens(bool parens)</div><div class="ttdoc">Sets whether the expression is wrapped in parentheses. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00211">parser_types.h:211</a></div></div>
<div class="ttc" id="classParseElement_html_a6c99027be209f067d3e4074457ccf4d0"><div class="ttname"><a href="classParseElement.html#a6c99027be209f067d3e4074457ccf4d0">ParseElement::isArithExpr</a></div><div class="ttdeci">virtual bool isArithExpr() const =0</div><div class="ttdoc">Determines if the element is a valid arithmetic expression. </div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00085">parser_types.h:85</a></div></div>
<div class="ttc" id="classTranslator_html_ab255d800190701bc36af2f4b7582c1d0"><div class="ttname"><a href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">Translator::getOrCreateObject</a></div><div class="ttdeci">Object * getOrCreateObject(std::string const &amp;symName, Object::ObjectType type=Object::OBJ_NAME, bool internal=false, size_t arity=0)</div><div class="ttdoc">Helper function for getting an Object type reference or dynamically adding it if it doesn&#39;t occur...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00382">Translator.cpp:382</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00084">parser_types.h:84</a></div></div>
<div class="ttc" id="classConstantLikeElement_html"><div class="ttname"><a href="classConstantLikeElement.html">ConstantLikeElement</a></div><div class="ttdoc">Child of BaseLikeElement that represents a base element with the behavior of a constant. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00703">parser_types.h:703</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2676b6b181db69a8d1e3596e81ae25d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::translateMayCauseLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>causer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>causee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>ifBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>assumingBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a causal law of the form "G may cause F [if H] [where J]." to basic form, then calls the translator on it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">causer</td><td>- The causing action formula. </td></tr>
    <tr><td class="paramname">causee</td><td>- The formula being caused. </td></tr>
    <tr><td class="paramname">ifBody</td><td>- Optional conditional formula to govern when the law applies. </td></tr>
    <tr><td class="paramname">assumingBody</td><td>- Optional conditional formula similar to the 'ifBody', except results in edges in the dependency graph. </td></tr>
    <tr><td class="paramname">whereBody</td><td>- Another conditional formula to govern when the law applies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything translates properly, false if anything goes wrong. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01679">1679</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="parser__types_8h_source.html#l00344">SimpleBinaryOperator::BOP_AND</a>, <a class="el" href="parser__types_8cpp_source.html#l00729">SimpleBinaryOperator::detachPostOp()</a>, <a class="el" href="parser__types_8cpp_source.html#l00736">SimpleBinaryOperator::detachPreOp()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>, <a class="el" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName()</a>, <a class="el" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants()</a>, <a class="el" href="parser__types_8h_source.html#l00084">ParseElement::MASK_ACTION</a>, <a class="el" href="parser__types_8h_source.html#l00085">ParseElement::MASK_FLUENT</a>, <a class="el" href="parser__types_8h_source.html#l00211">ParseElement::parens()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l02083">warn()</a>.</p>
<div class="fragment"><div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;{</div>
<div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;    <span class="keywordtype">bool</span> retVal = <span class="keyword">false</span>; <span class="comment">// Start pessimistic.</span></div>
<div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;    <span class="keywordflow">if</span>(causer != NULL &amp;&amp; causee != NULL)</div>
<div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;    {</div>
<div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;        <span class="comment">// Causer has to be an action formula, or the law is not properly written.</span></div>
<div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;        <span class="keywordflow">if</span>(causer-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>) &amp;&amp; !causer-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a>))</div>
<div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;        {</div>
<div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;            <span class="comment">// Causer and assumingBody are going to end up together no matter what.</span></div>
<div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;            <span class="keywordflow">if</span> (causer) causer-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;            <span class="keywordflow">if</span> (assumingBody) assumingBody-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;            <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>* tempPE = <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(causer, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, assumingBody);</div>
<div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;</div>
<div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;            <span class="comment">// Where causer and ifBody end up in the basic form depend on what&#39;s in causee.</span></div>
<div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;            <span class="keywordflow">if</span>(!causee-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a>))</div>
<div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;            {   <span class="comment">// Causee is an action formula, this is &quot;caused F if H assuming F &amp; L where K&quot;.</span></div>
<div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;                <span class="comment">// Merge F into G &amp; L.</span></div>
<div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;                <span class="keywordflow">if</span> (causee) causee-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;                <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>* tempPE2 = <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(causee, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, tempPE);</div>
<div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;                <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(causee, ifBody, tempPE2, NULL, NULL, whereBody);</div>
<div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;</div>
<div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;                retVal = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;                tempPE2-&gt;<a class="code" href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">detachPostOp</a>();</div>
<div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;                tempPE2-&gt;<a class="code" href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">detachPreOp</a>();</div>
<div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;                deallocateTempBinaryOp(tempPE2);</div>
<div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;            }</div>
<div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!causee-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>))</div>
<div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;            {   <span class="comment">// Causee is a fluent formula, this is &quot;caused F assuming F after G &amp; H &amp; L where K&quot;.</span></div>
<div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;                <span class="comment">// Merge H into G &amp; L.</span></div>
<div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;                <span class="keywordflow">if</span> (ifBody) ifBody-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;                <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>* tempPE2 = <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(ifBody, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, tempPE);</div>
<div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;                <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(causee, NULL, causee, tempPE2, NULL, whereBody);</div>
<div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;</div>
<div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;                retVal = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;                tempPE2-&gt;<a class="code" href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">detachPostOp</a>();</div>
<div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;                tempPE2-&gt;<a class="code" href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">detachPreOp</a>();</div>
<div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;                deallocateTempBinaryOp(tempPE2);</div>
<div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;            }</div>
<div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;            {   <span class="comment">// Causee is mixed, that isn&#39;t allowed.</span></div>
<div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;                <a class="code" href="classTranslator.html#aa07bcca529cd19ad8602fb4ec5ec16d9">warn</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + causee-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; must be a pure action formula or pure fluent formula in this law, it can&#39;t have both kinds of constants.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;            }</div>
<div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;</div>
<div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;            tempPE-&gt;<a class="code" href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">detachPostOp</a>();</div>
<div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;            tempPE-&gt;<a class="code" href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">detachPreOp</a>();</div>
<div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;            deallocateTempBinaryOp(tempPE);</div>
<div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;        }</div>
<div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;        {</div>
<div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + causer-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; is not an action formula, can&#39;t use it as G in a \&quot;G may cause F\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;        }</div>
<div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;    }</div>
<div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;}</div>
<div class="ttc" id="classSimpleBinaryOperator_html_a1d4f5ebb966db416489ac736a87fc4db"><div class="ttname"><a href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">SimpleBinaryOperator::detachPostOp</a></div><div class="ttdeci">ParseElement * detachPostOp()</div><div class="ttdoc">Detaches the operator&#39;s sub expression, returning it. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00729">parser_types.cpp:729</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5"><div class="ttname"><a href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00344">parser_types.h:344</a></div></div>
<div class="ttc" id="classTranslator_html_aa07bcca529cd19ad8602fb4ec5ec16d9"><div class="ttname"><a href="classTranslator.html#aa07bcca529cd19ad8602fb4ec5ec16d9">Translator::warn</a></div><div class="ttdeci">void warn(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02083">Translator.cpp:2083</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html"><div class="ttname"><a href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a></div><div class="ttdoc">Child of ParseElement that represents a binary operator and the associated elements it operates on...</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00330">parser_types.h:330</a></div></div>
<div class="ttc" id="classTranslator_html_a2745b2441a5759d77e02524ec9dad4ff"><div class="ttname"><a href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">Translator::translateCausalLaw</a></div><div class="ttdeci">void translateCausalLaw(ParseElement *head, ParseElement *ifBody, ParseElement *assumingBody, ParseElement *afterBody, ParseElement *unlessBody, ParseElement *whereBody)</div><div class="ttdoc">Translates a causal law into ASP-compatible rule(s). </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00838">Translator.cpp:838</a></div></div>
<div class="ttc" id="classParseElement_html_aa0ff7094f640ccd042bb7fa636a5028d"><div class="ttname"><a href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants</a></div><div class="ttdeci">virtual bool hasConstants(unsigned int types, bool includeParams=true, bool includeEq=true) const =0</div><div class="ttdoc">Returns true if the element (or any of its children) are constants of the provided types...</div></div>
<div class="ttc" id="classParseElement_html_a4499644cdb72e234a649e768fbf762be"><div class="ttname"><a href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName</a></div><div class="ttdeci">virtual std::ostream &amp; fullName(std::ostream &amp;out) const =0</div><div class="ttdoc">Prints the untranslated element string. </div></div>
<div class="ttc" id="classTranslator_html_a7c14268a49b3551907e27ba347d13e93"><div class="ttname"><a href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">Translator::error</a></div><div class="ttdeci">void error(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02076">Translator.cpp:2076</a></div></div>
<div class="ttc" id="classParseElement_html_ab219939d84aea2e8c852fc414c1fa2c1"><div class="ttname"><a href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">ParseElement::parens</a></div><div class="ttdeci">void parens(bool parens)</div><div class="ttdoc">Sets whether the expression is wrapped in parentheses. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00211">parser_types.h:211</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a87319414b8aba9d9cc18c76cdf9b83de"><div class="ttname"><a href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">SimpleBinaryOperator::detachPreOp</a></div><div class="ttdeci">ParseElement * detachPreOp()</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00736">parser_types.cpp:736</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00085">parser_types.h:85</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00084">parser_types.h:84</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a26257de0623490f5d6fcc19dbcdffd28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::translateNonexecutableLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>nonEx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>ifBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>unlessBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a causal law of the form "nonexecutable F [if G] [where H]." to basic form, then calls the translator for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonEx</td><td>- The formula that should not be executed. </td></tr>
    <tr><td class="paramname">ifBody</td><td>- Optional conditional formula to govern when the law applies. </td></tr>
    <tr><td class="paramname">unlessBody</td><td>- Optional atom to be dynamically declared as an default-false constant. </td></tr>
    <tr><td class="paramname">whereBody</td><td>- Another conditional formula to govern when the law applies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything translates properly, false if anything goes wrong. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01605">1605</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="parser__types_8h_source.html#l00344">SimpleBinaryOperator::BOP_AND</a>, <a class="el" href="parser__types_8cpp_source.html#l00729">SimpleBinaryOperator::detachPostOp()</a>, <a class="el" href="parser__types_8cpp_source.html#l00736">SimpleBinaryOperator::detachPreOp()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>, <a class="el" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00382">getOrCreateObject()</a>, <a class="el" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants()</a>, <a class="el" href="parser__types_8h_source.html#l00084">ParseElement::MASK_ACTION</a>, <a class="el" href="parser__types_8h_source.html#l00085">ParseElement::MASK_FLUENT</a>, <a class="el" href="parser__types_8h_source.html#l00211">ParseElement::parens()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l02083">warn()</a>.</p>
<div class="fragment"><div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;{</div>
<div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;    <span class="keywordtype">bool</span> retVal = <span class="keyword">false</span>; <span class="comment">// Start pessimistic.</span></div>
<div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;    <span class="keywordflow">if</span>(nonEx != NULL)</div>
<div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;    {</div>
<div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;        <span class="comment">// nonEx has to be an action formula or the law is malformed. Soft warn if its neither kind of formula.</span></div>
<div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;        <span class="keywordflow">if</span>(!nonEx-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a>))</div>
<div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;        {</div>
<div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;            <span class="keywordflow">if</span>(!nonEx-&gt;<a class="code" href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">hasConstants</a>(<a class="code" href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a>))</div>
<div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;            {</div>
<div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;                <a class="code" href="classTranslator.html#aa07bcca529cd19ad8602fb4ec5ec16d9">warn</a>(<span class="stringliteral">&quot;Cannot determine if \&quot;&quot;</span> + nonEx-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; is an action formula or not, it might not work as F in a \&quot;nonexecutable F\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;            }</div>
<div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;</div>
<div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;            <span class="comment">// nonEx and ifBody are going to end up together no matter what.</span></div>
<div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;            <span class="keywordflow">if</span> (ifBody) ifBody-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;            <span class="keywordflow">if</span> (nonEx) nonEx-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;            <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>* tempPE = <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(nonEx, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, ifBody);</div>
<div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;</div>
<div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;            <span class="comment">// Create a head of &quot;false&quot;.</span></div>
<div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;            <a class="code" href="classObjectLikeElement.html">ObjectLikeElement</a>* tempObj = <span class="keyword">new</span> <a class="code" href="classObjectLikeElement.html">ObjectLikeElement</a>(<span class="stringliteral">&quot;false&quot;</span>, <a class="code" href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">getOrCreateObject</a>(<span class="stringliteral">&quot;false&quot;</span>));</div>
<div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;</div>
<div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;            <span class="comment">// becomes caused false after F [&amp; G] where K.</span></div>
<div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;            <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(tempObj, NULL, NULL, tempPE, unlessBody, whereBody);</div>
<div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;</div>
<div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;            <span class="keyword">delete</span> tempObj;</div>
<div class="line"><a name="l01635"></a><span class="lineno"> 1635</span>&#160;            tempPE-&gt;<a class="code" href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">detachPostOp</a>();</div>
<div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;            tempPE-&gt;<a class="code" href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">detachPreOp</a>();</div>
<div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;            <span class="keyword">delete</span> tempPE;</div>
<div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;</div>
<div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;            retVal = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;        }</div>
<div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;        {</div>
<div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;            <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(<span class="stringliteral">&quot;\&quot;&quot;</span> + nonEx-&gt;<a class="code" href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">fullName</a>() + <span class="stringliteral">&quot;\&quot; is not an action formula, can&#39;t use it as F in a \&quot;nonexecutable F\&quot; style law.&quot;</span>, <span class="keyword">true</span>, <span class="keyword">true</span>);</div>
<div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;        }</div>
<div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;    }</div>
<div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;}</div>
<div class="ttc" id="classObjectLikeElement_html"><div class="ttname"><a href="classObjectLikeElement.html">ObjectLikeElement</a></div><div class="ttdoc">Child of BaseLikeElement that represents a base element with the behavior of an object. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00786">parser_types.h:786</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a1d4f5ebb966db416489ac736a87fc4db"><div class="ttname"><a href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">SimpleBinaryOperator::detachPostOp</a></div><div class="ttdeci">ParseElement * detachPostOp()</div><div class="ttdoc">Detaches the operator&#39;s sub expression, returning it. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00729">parser_types.cpp:729</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5"><div class="ttname"><a href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00344">parser_types.h:344</a></div></div>
<div class="ttc" id="classTranslator_html_aa07bcca529cd19ad8602fb4ec5ec16d9"><div class="ttname"><a href="classTranslator.html#aa07bcca529cd19ad8602fb4ec5ec16d9">Translator::warn</a></div><div class="ttdeci">void warn(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02083">Translator.cpp:2083</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html"><div class="ttname"><a href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a></div><div class="ttdoc">Child of ParseElement that represents a binary operator and the associated elements it operates on...</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00330">parser_types.h:330</a></div></div>
<div class="ttc" id="classTranslator_html_a2745b2441a5759d77e02524ec9dad4ff"><div class="ttname"><a href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">Translator::translateCausalLaw</a></div><div class="ttdeci">void translateCausalLaw(ParseElement *head, ParseElement *ifBody, ParseElement *assumingBody, ParseElement *afterBody, ParseElement *unlessBody, ParseElement *whereBody)</div><div class="ttdoc">Translates a causal law into ASP-compatible rule(s). </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00838">Translator.cpp:838</a></div></div>
<div class="ttc" id="classParseElement_html_aa0ff7094f640ccd042bb7fa636a5028d"><div class="ttname"><a href="classParseElement.html#aa0ff7094f640ccd042bb7fa636a5028d">ParseElement::hasConstants</a></div><div class="ttdeci">virtual bool hasConstants(unsigned int types, bool includeParams=true, bool includeEq=true) const =0</div><div class="ttdoc">Returns true if the element (or any of its children) are constants of the provided types...</div></div>
<div class="ttc" id="classParseElement_html_a4499644cdb72e234a649e768fbf762be"><div class="ttname"><a href="classParseElement.html#a4499644cdb72e234a649e768fbf762be">ParseElement::fullName</a></div><div class="ttdeci">virtual std::ostream &amp; fullName(std::ostream &amp;out) const =0</div><div class="ttdoc">Prints the untranslated element string. </div></div>
<div class="ttc" id="classTranslator_html_a7c14268a49b3551907e27ba347d13e93"><div class="ttname"><a href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">Translator::error</a></div><div class="ttdeci">void error(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02076">Translator.cpp:2076</a></div></div>
<div class="ttc" id="classParseElement_html_ab219939d84aea2e8c852fc414c1fa2c1"><div class="ttname"><a href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">ParseElement::parens</a></div><div class="ttdeci">void parens(bool parens)</div><div class="ttdoc">Sets whether the expression is wrapped in parentheses. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00211">parser_types.h:211</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a87319414b8aba9d9cc18c76cdf9b83de"><div class="ttname"><a href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">SimpleBinaryOperator::detachPreOp</a></div><div class="ttdeci">ParseElement * detachPreOp()</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00736">parser_types.cpp:736</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a82c93f6887c4c63c332de9f04f145d61">ParseElement::MASK_FLUENT</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00085">parser_types.h:85</a></div></div>
<div class="ttc" id="classTranslator_html_ab255d800190701bc36af2f4b7582c1d0"><div class="ttname"><a href="classTranslator.html#ab255d800190701bc36af2f4b7582c1d0">Translator::getOrCreateObject</a></div><div class="ttdeci">Object * getOrCreateObject(std::string const &amp;symName, Object::ObjectType type=Object::OBJ_NAME, bool internal=false, size_t arity=0)</div><div class="ttdoc">Helper function for getting an Object type reference or dynamically adding it if it doesn&#39;t occur...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00382">Translator.cpp:382</a></div></div>
<div class="ttc" id="classParseElement_html_a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8"><div class="ttname"><a href="classParseElement.html#a4417ee0536696eeb0b9fbb703a03bc36a6faaa4136350f5ae7a4acf12dbeda1f8">ParseElement::MASK_ACTION</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00084">parser_types.h:84</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa05427462bb0825e125b6d4f3054cf78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::translateObjectDecl </td>
          <td>(</td>
          <td class="paramtype">Object const *&#160;</td>
          <td class="paramname"><em>transObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort const *&#160;</td>
          <td class="paramname"><em>sortObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates an Object element into an ASP-compatible declaration of an object as a member of a sort's domain. </p>
<p>Sends the result to ostOut. If the sort pointer is NULL, will not output anything. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transObj</td><td>- The Object element to translate. </td></tr>
    <tr><td class="paramname">sortObj</td><td>- The Sort element the object belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00594">594</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02260">output()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l02140">outputClauses()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00400">addSort()</a>.</p>
<div class="fragment"><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;{</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;    <span class="comment">// Sanity check: make sure the object isn&#39;t NULL, and neither is its sort.</span></div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    <span class="keywordflow">if</span>(transObj &amp;&amp; sortObj)</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    {</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;        <span class="comment">// An object delcaration is the sort&#39;s name, and then the object</span></div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;        <span class="comment">// name in parentheses.</span></div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        std::stringstream stmtBuilder;                  <span class="comment">// Used to build each individual statement required for this declaration.</span></div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        <a class="code" href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">ClauseList</a> localClauses;</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        stmtBuilder &lt;&lt; sortObj-&gt;fullTransName() &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        transObj-&gt;translate(stmtBuilder, localClauses);</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;        stmtBuilder &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;        <span class="keywordflow">if</span> (localClauses.size()) {</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;            stmtBuilder &lt;&lt; <span class="stringliteral">&quot; &lt;- &quot;</span>;</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;            <a class="code" href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">outputClauses</a>(stmtBuilder, localClauses, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        }</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;        stmtBuilder &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;        <span class="comment">// Output the statement</span></div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;        <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>(stmtBuilder.str(), IPART_BASE, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;    }</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;}</div>
<div class="ttc" id="namespacecplus2asp_1_1cplus2asp__bin_html_a2fbffbd697b2a504d23669a23961be4b"><div class="ttname"><a href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">cplus2asp::cplus2asp_bin::ClauseList</a></div><div class="ttdeci">ReferencedList&lt; std::string &gt;::type ClauseList</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00027">types.h:27</a></div></div>
<div class="ttc" id="classTranslator_html_a2973b80adebf80f00ca209502465f8e5"><div class="ttname"><a href="classTranslator.html#a2973b80adebf80f00ca209502465f8e5">Translator::outputClauses</a></div><div class="ttdeci">static std::ostream &amp; outputClauses(std::ostream &amp;out, ClauseList const &amp;clauses, bool initConj=false)</div><div class="ttdoc">helper method to output multiple clauses to an output stream. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02140">Translator.cpp:2140</a></div></div>
<div class="ttc" id="classTranslator_html_acbb634f19ffb6d601eae8ad032d72ce9"><div class="ttname"><a href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">Translator::output</a></div><div class="ttdeci">void output(std::string const &amp;str, IPart incPart, bool endWithNewline=false)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02260">Translator.cpp:2260</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a01c76f48f345c4258fe01a6a746e82ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Translator::translatePossiblyCausedLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>ifBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>assumingBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>afterBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>unlessBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParseElement.html">ParseElement</a> *&#160;</td>
          <td class="paramname"><em>whereBody</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms a causal law of the form "possibly caused F [if G] [after H] [where J]." to basic form, then calls the translator on it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>- The head of the law. </td></tr>
    <tr><td class="paramname">ifBody</td><td>- Optional conditional formula to govern when the law applies. </td></tr>
    <tr><td class="paramname">assumingBody</td><td>- Optional conditional formula similar to the 'ifBody', except results in edges in the dependency graph. </td></tr>
    <tr><td class="paramname">afterBody</td><td>- Optional conditional formula specifying conditions from the prior time step. </td></tr>
    <tr><td class="paramname">unlessBody</td><td>- Optional atom to be dynamically declared as an default-false constant. </td></tr>
    <tr><td class="paramname">whereBody</td><td>- Another conditional formula to govern when the law applies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything translates properly, false if anything goes wrong. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01650">1650</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="parser__types_8h_source.html#l00344">SimpleBinaryOperator::BOP_AND</a>, <a class="el" href="parser__types_8cpp_source.html#l00729">SimpleBinaryOperator::detachPostOp()</a>, <a class="el" href="parser__types_8cpp_source.html#l00736">SimpleBinaryOperator::detachPreOp()</a>, <a class="el" href="parser__types_8h_source.html#l00211">ParseElement::parens()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00838">translateCausalLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;{</div>
<div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;    <span class="keywordtype">bool</span> retVal = <span class="keyword">false</span>; <span class="comment">// Start pessimistic.</span></div>
<div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;    <span class="keywordflow">if</span>(head != NULL)</div>
<div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;    {</div>
<div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;        <span class="comment">// head and ifBody are going to end up together no matter what.</span></div>
<div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;        <span class="keywordflow">if</span> (assumingBody) assumingBody-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;        <span class="keywordflow">if</span> (head) head-&gt;<a class="code" href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">parens</a>(<span class="keyword">true</span>);</div>
<div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;        <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>* tempPE = <span class="keyword">new</span> <a class="code" href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a>(head, <a class="code" href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a>, assumingBody);</div>
<div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;</div>
<div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;        <span class="comment">// This law becomes &quot;caused F if G assuming F [&amp; H] [after J] [unless K] [when L] [following M] [where N].&quot;</span></div>
<div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;        <a class="code" href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">translateCausalLaw</a>(head, ifBody, tempPE, afterBody, unlessBody, whereBody);</div>
<div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;</div>
<div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;        retVal = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;        tempPE-&gt;<a class="code" href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">detachPostOp</a>();</div>
<div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;        tempPE-&gt;<a class="code" href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">detachPreOp</a>();</div>
<div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;        <span class="keyword">delete</span> tempPE;</div>
<div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;    }</div>
<div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;    <span class="keywordflow">return</span> retVal;</div>
<div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;}</div>
<div class="ttc" id="classSimpleBinaryOperator_html_a1d4f5ebb966db416489ac736a87fc4db"><div class="ttname"><a href="classSimpleBinaryOperator.html#a1d4f5ebb966db416489ac736a87fc4db">SimpleBinaryOperator::detachPostOp</a></div><div class="ttdeci">ParseElement * detachPostOp()</div><div class="ttdoc">Detaches the operator&#39;s sub expression, returning it. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00729">parser_types.cpp:729</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5"><div class="ttname"><a href="classSimpleBinaryOperator.html#a4540d8cb2db758d9d780596224519cdeaa40b63aba437b71da8f77b7166b515e5">SimpleBinaryOperator::BOP_AND</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00344">parser_types.h:344</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html"><div class="ttname"><a href="classSimpleBinaryOperator.html">SimpleBinaryOperator</a></div><div class="ttdoc">Child of ParseElement that represents a binary operator and the associated elements it operates on...</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00330">parser_types.h:330</a></div></div>
<div class="ttc" id="classTranslator_html_a2745b2441a5759d77e02524ec9dad4ff"><div class="ttname"><a href="classTranslator.html#a2745b2441a5759d77e02524ec9dad4ff">Translator::translateCausalLaw</a></div><div class="ttdeci">void translateCausalLaw(ParseElement *head, ParseElement *ifBody, ParseElement *assumingBody, ParseElement *afterBody, ParseElement *unlessBody, ParseElement *whereBody)</div><div class="ttdoc">Translates a causal law into ASP-compatible rule(s). </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00838">Translator.cpp:838</a></div></div>
<div class="ttc" id="classParseElement_html_ab219939d84aea2e8c852fc414c1fa2c1"><div class="ttname"><a href="classParseElement.html#ab219939d84aea2e8c852fc414c1fa2c1">ParseElement::parens</a></div><div class="ttdeci">void parens(bool parens)</div><div class="ttdoc">Sets whether the expression is wrapped in parentheses. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00211">parser_types.h:211</a></div></div>
<div class="ttc" id="classSimpleBinaryOperator_html_a87319414b8aba9d9cc18c76cdf9b83de"><div class="ttname"><a href="classSimpleBinaryOperator.html#a87319414b8aba9d9cc18c76cdf9b83de">SimpleBinaryOperator::detachPreOp</a></div><div class="ttdeci">ParseElement * detachPreOp()</div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8cpp_source.html#l00736">parser_types.cpp:736</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae9405371b013e5879931fdb3cf985de5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::translateQuery </td>
          <td>(</td>
          <td class="paramtype">Query const *&#160;</td>
          <td class="paramname"><em>transQuery</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates a Query into an ASP-compatible query declaration. </p>
<p>Sends the result to ostOut. Also ensures the standard query label linking statement has been output. If the query's label or maxstep are blank, will not output anything. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transQuery</td><td>- The Query element to translate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00737">737</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02150">bindAndTranslate()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>, <a class="el" href="old_2Translator_8h_source.html#l00709">lang()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l02266">outputStmts()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l02117">resolveDynamicDeclarations()</a>.</p>
<div class="fragment"><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;{</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    <a class="code" href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">ClauseList</a> localClauses;</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;    StmtList stmts;</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;    <span class="comment">// TODO: These aren&#39;t behaving correctly...</span></div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;    <span class="keywordflow">if</span>(transQuery &amp;&amp; transQuery-&gt;label != <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="comment">//          &amp;&amp; (!blnStaticTrans || transQuery-&gt;maxstep != &quot;&quot;))</span></div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;    {</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        std::ostringstream ossOutputBuffer; <span class="comment">// Holds translated output so things can be easily added on before or after the normal output.</span></div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;        <span class="comment">// Output special &quot;hint&quot; flags/comments for this query.</span></div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;        std::string hintMaxstep = transQuery-&gt;maxstep;</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;        <span class="comment">// f2lp does weird things with periods in comments, so replace the dots in a ranged maxstep with something else.</span></div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;        <span class="keywordflow">if</span>(hintMaxstep.find(<span class="stringliteral">&quot;..&quot;</span>) != std::string::npos)</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;        {</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;            hintMaxstep.replace(hintMaxstep.find(<span class="stringliteral">&quot;..&quot;</span>), 2, <span class="stringliteral">&quot;::&quot;</span>);</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;        }</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;        stmts.push_back(</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;            Statement(</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;                    <span class="stringliteral">&quot;% [Query: Label:&quot;</span> + transQuery-&gt;label + ((hintMaxstep != <span class="stringliteral">&quot;&quot;</span>) ? <span class="stringliteral">&quot;, Maxstep:&quot;</span> + hintMaxstep : <span class="stringliteral">&quot;&quot;</span> ) + <span class="stringliteral">&quot;]&quot;</span>,</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;                    IPART_NONE</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;                    )</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;            );</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;        <span class="comment">// For each item in queryConditions, output an ASP-style constraint for it.</span></div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;        <span class="keywordflow">for</span>(ParseElementList::const_iterator lIter = transQuery-&gt;queryConditions.begin(); lIter != transQuery-&gt;queryConditions.end(); ++lIter)</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;        {</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;            IPart part = IPART_BASE;</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;            <span class="keywordtype">bool</span> alteredTimestamp = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;            <span class="keywordtype">bool</span> malformed = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;            <span class="keywordtype">int</span> tmpLoc;</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;            std::string tmpQueryTimeStamp;</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;            <span class="comment">// set up everything for our use</span></div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;            ossOutputBuffer.str(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;            <span class="comment">// Transform &#39;maxstep&#39; to the appropriate timestamp</span></div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;            <span class="keywordflow">if</span> (!blnStaticTrans) {</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;                part = (*lIter)-&gt;determineQueryIPart();</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;            }</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;            <span class="comment">// Quick checking for undeclared identifiers....</span></div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;            BaseElementList maybeUndefined, undefined;</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;            (*lIter)-&gt;aggregateUndefined(maybeUndefined);</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;            <span class="keywordflow">if</span> (!<a class="code" href="classTranslator.html#a5c11ad8502a2aeec081563dc13232462">resolveDynamicDeclarations</a>(maybeUndefined, undefined)) {</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;                <span class="comment">// One or more undefined elements.</span></div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;                <span class="comment">// Throw an error</span></div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;                std::ostringstream tmpErr;</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;                tmpErr &lt;&lt; <span class="stringliteral">&quot;Undeclared identifiers were encountered. The following identifiers are undeclared: &quot;</span>;</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;                <span class="keywordflow">for</span> (BaseElementList::const_iterator it = undefined.begin(); it != undefined.end(); ) {</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;                    tmpErr &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;                    (*it)-&gt;fullName(tmpErr);</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;                    tmpErr &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>;</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;                    <span class="keywordflow">if</span> (++it != undefined.end()) tmpErr &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;                }</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;                tmpErr &lt;&lt; <span class="stringliteral">&quot;.&quot;</span>;</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;                <a class="code" href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">error</a>(tmpErr.str(),<span class="keyword">true</span>);</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;                malformed = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;            }</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;            <span class="comment">// Don&#39;t translate malformed queries</span></div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;            <span class="keywordflow">if</span> (malformed) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;            <span class="comment">// Translate the query.</span></div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;            std::ostringstream stmtBuilder;</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;            Context localContext = Context(<a class="code" href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">lang</a>(),</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;                    Context::POS_QUERY,</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;                    part,</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;                    Context::EMPTY_STR,</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;                    NULL,</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;                    NULL,</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;                    <span class="keyword">true</span>,</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;                    <span class="keyword">true</span>,</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;                    &amp;stmts</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;            );</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;            stmtBuilder &lt;&lt; <span class="stringliteral">&quot;false &lt;- query_label(&quot;</span> &lt;&lt; transQuery-&gt;label &lt;&lt; <span class="stringliteral">&quot;) &amp; not (&quot;</span>;</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;            <a class="code" href="classTranslator.html#a0d2965d026bb2cfb15f62b533beaa155">bindAndTranslate</a>(stmtBuilder, (*lIter), localContext, <span class="keyword">false</span>, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;            <span class="comment">// end the statement.</span></div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;            stmtBuilder &lt;&lt; <span class="stringliteral">&quot;).&quot;</span>;</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;            <span class="comment">// push the results in the statements list.</span></div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;            stmts.push_back(Statement(stmtBuilder.str(), part));</div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;        }</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;        <span class="comment">// output all the resulting statements.</span></div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;        <a class="code" href="classTranslator.html#a2c7447c0464738a176c4cc5f05397dfa">outputStmts</a>(stmts);</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;    }</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;}</div>
<div class="ttc" id="namespacecplus2asp_1_1cplus2asp__bin_html_a2fbffbd697b2a504d23669a23961be4b"><div class="ttname"><a href="namespacecplus2asp_1_1cplus2asp__bin.html#a2fbffbd697b2a504d23669a23961be4b">cplus2asp::cplus2asp_bin::ClauseList</a></div><div class="ttdeci">ReferencedList&lt; std::string &gt;::type ClauseList</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00027">types.h:27</a></div></div>
<div class="ttc" id="classTranslator_html_a5c11ad8502a2aeec081563dc13232462"><div class="ttname"><a href="classTranslator.html#a5c11ad8502a2aeec081563dc13232462">Translator::resolveDynamicDeclarations</a></div><div class="ttdeci">bool resolveDynamicDeclarations(BaseElementList &amp;undefined, BaseElementList &amp;reallyUndefined)</div><div class="ttdoc">Attempts to resolve dynamic declarations that weren&#39;t caught previously. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02117">Translator.cpp:2117</a></div></div>
<div class="ttc" id="classTranslator_html_a0d2965d026bb2cfb15f62b533beaa155"><div class="ttname"><a href="classTranslator.html#a0d2965d026bb2cfb15f62b533beaa155">Translator::bindAndTranslate</a></div><div class="ttdeci">static std::ostream &amp; bindAndTranslate(std::ostream &amp;out, ParseElement const *expr, Context &amp;context, bool upwardMobileClauses, bool suppressQuantifier=false)</div><div class="ttdoc">helper method to translate a sub expression, capturing all of its clauses and variables in the meanwh...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02150">Translator.cpp:2150</a></div></div>
<div class="ttc" id="classTranslator_html_a2c7447c0464738a176c4cc5f05397dfa"><div class="ttname"><a href="classTranslator.html#a2c7447c0464738a176c4cc5f05397dfa">Translator::outputStmts</a></div><div class="ttdeci">void outputStmts(StmtList const &amp;stmts)</div><div class="ttdoc">Outputs a list of statements to the translators output. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02266">Translator.cpp:2266</a></div></div>
<div class="ttc" id="classTranslator_html_a7c14268a49b3551907e27ba347d13e93"><div class="ttname"><a href="classTranslator.html#a7c14268a49b3551907e27ba347d13e93">Translator::error</a></div><div class="ttdeci">void error(std::string const &amp;str, bool endWithNewline=false, bool location=true)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s error output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02076">Translator.cpp:2076</a></div></div>
<div class="ttc" id="classTranslator_html_a864d4dc33098092fef562455dc97c9e2"><div class="ttname"><a href="classTranslator.html#a864d4dc33098092fef562455dc97c9e2">Translator::lang</a></div><div class="ttdeci">Language lang() const </div><div class="ttdoc">Gets the currently active language. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00709">Translator.h:709</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aec2c314812bca3c1c52f62f3dca0e4b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::translateShowStmt </td>
          <td>(</td>
          <td class="paramtype">ParseElementList const &amp;&#160;</td>
          <td class="paramname"><em>atomicFormulas</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles a ':- show' statement, adding the appropriate #show statements to the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atomicFormulas</td><td>The list of atomic formulas which were included in the show statement. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l01378">1378</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8h_source.html#l00691">addToFooter()</a>, <a class="el" href="parser__types_8h_source.html#l00736">ConstantLikeElement::domain()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01420">makeShowStmt()</a>, and <a class="el" href="parser__types_8h_source.html#l00080">ParseElement::PELEM_CONSTLIKE</a>.</p>
<div class="fragment"><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;                                                                         {</div>
<div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;    StmtList stmts;</div>
<div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;</div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;    <span class="comment">// By default, user defined atoms are shown in the answer set.</span></div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;    <span class="comment">// The presence of a show statement overrides this and makes them all</span></div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;    <span class="comment">// default to hidden.</span></div>
<div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;    <span class="keywordflow">if</span> (!blnEncounteredShowStmt) {</div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;        blnEncounteredShowStmt = <span class="keyword">true</span>;</div>
<div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;        stmts.push_back(Statement(<span class="stringliteral">&quot;#hide h/2.&quot;</span>, IPART_BASE));</div>
<div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;        stmts.push_back(Statement(<span class="stringliteral">&quot;#hide h/1.&quot;</span>, IPART_BASE));</div>
<div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;    }</div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;</div>
<div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;</div>
<div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;    <span class="comment">// Iterate through each element and add the appropriate show statements.</span></div>
<div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;    <span class="keywordflow">for</span> (ParseElementList::const_iterator it = atomicFormulas.begin(); it != atomicFormulas.end(); it++) {</div>
<div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;</div>
<div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;        <span class="comment">// Sanity check: Non-null parse elements.</span></div>
<div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;        <span class="keywordflow">if</span> (!(*it)) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;</div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;</div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;        <span class="keywordflow">if</span> ((*it)-&gt;getType() == <a class="code" href="classParseElement.html#a332651d3e938a02b564cd4c4f4decb0fade3acc8b22d851c69145a2e268f8904d">ParseElement::PELEM_CONSTLIKE</a>) {</div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;            <span class="comment">// It&#39;s a bare constant. Take this to be a shortcut for &#39;c=v&#39; where V is a variable ranging of the constant&#39;s domain</span></div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;            <a class="code" href="classConstantLikeElement.html">ConstantLikeElement</a>* constlike = ((<a class="code" href="classConstantLikeElement.html">ConstantLikeElement</a>*)(*it));</div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;            <span class="keywordflow">if</span> (constlike-&gt;<a class="code" href="classConstantLikeElement.html#a71bfb3177eab34428b117d0c72bda0f3">domain</a>())</div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;            {</div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;                <a class="code" href="classTranslator.html#ab7c3fc88127578322d7065dd89ab54f6">makeShowStmt</a>(*it, stmts, constlike-&gt;<a class="code" href="classConstantLikeElement.html#a71bfb3177eab34428b117d0c72bda0f3">domain</a>()-&gt;var());</div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;            } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;                <span class="comment">// This appears to be missing one or more references...</span></div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;                <span class="comment">// Just try a normal translation and hope for the best.</span></div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;                <a class="code" href="classTranslator.html#ab7c3fc88127578322d7065dd89ab54f6">makeShowStmt</a>(*it, stmts);</div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;            }</div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;            <span class="comment">// It&#39;s must be &#39;c=v&#39;. We can translate this without any further ado</span></div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;            <a class="code" href="classTranslator.html#ab7c3fc88127578322d7065dd89ab54f6">makeShowStmt</a>(*it, stmts);</div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;        }</div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;    }</div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;</div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;    <span class="comment">// Add the statements to the footer.</span></div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;    <a class="code" href="classTranslator.html#aed3dafe51e51a6bc4bc63c7d35dc63f3">addToFooter</a>(stmts);</div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_aed3dafe51e51a6bc4bc63c7d35dc63f3"><div class="ttname"><a href="classTranslator.html#aed3dafe51e51a6bc4bc63c7d35dc63f3">Translator::addToFooter</a></div><div class="ttdeci">void addToFooter(StmtList &amp;stmts)</div><div class="ttdoc">Appends the provided statement to the program&#39;s footer buffer, resulting them in being included in th...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00691">Translator.h:691</a></div></div>
<div class="ttc" id="classParseElement_html_a332651d3e938a02b564cd4c4f4decb0fade3acc8b22d851c69145a2e268f8904d"><div class="ttname"><a href="classParseElement.html#a332651d3e938a02b564cd4c4f4decb0fade3acc8b22d851c69145a2e268f8904d">ParseElement::PELEM_CONSTLIKE</a></div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00080">parser_types.h:80</a></div></div>
<div class="ttc" id="classConstantLikeElement_html_a71bfb3177eab34428b117d0c72bda0f3"><div class="ttname"><a href="classConstantLikeElement.html#a71bfb3177eab34428b117d0c72bda0f3">ConstantLikeElement::domain</a></div><div class="ttdeci">Sort const * domain() const </div><div class="ttdoc">Gets the domain of the constant ( or null ) </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00736">parser_types.h:736</a></div></div>
<div class="ttc" id="classTranslator_html_ab7c3fc88127578322d7065dd89ab54f6"><div class="ttname"><a href="classTranslator.html#ab7c3fc88127578322d7065dd89ab54f6">Translator::makeShowStmt</a></div><div class="ttdeci">void makeShowStmt(ParseElement *elem, StmtList &amp;stmts, Variable const *eql=NULL)</div><div class="ttdoc">Makes a &#39;#show&#39; statement for the provided element. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l01420">Translator.cpp:1420</a></div></div>
<div class="ttc" id="classConstantLikeElement_html"><div class="ttname"><a href="classConstantLikeElement.html">ConstantLikeElement</a></div><div class="ttdoc">Child of BaseLikeElement that represents a base element with the behavior of a constant. </div><div class="ttdef"><b>Definition:</b> <a href="parser__types_8h_source.html#l00703">parser_types.h:703</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac261db6a4a61d4b0e9c86874199bbe9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::translateSortDecl </td>
          <td>(</td>
          <td class="paramtype">Sort const *&#160;</td>
          <td class="paramname"><em>transSort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates a Sort element into an ASP-compatible sort declaration. </p>
<p>Sends the result to ostOut. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transSort</td><td>- The Sort element to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Error if sortVar == NULL. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00651">651</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02266">outputStmts()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00708">translateSubsortDecl()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00400">addSort()</a>.</p>
<div class="fragment"><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;{</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;    <span class="comment">// Sanity check: make sure the sort isn&#39;t NULL.</span></div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;    <span class="keywordflow">if</span>(transSort)</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;    {</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;        StmtList stmts;                                 <span class="comment">// Used to aggregate the statements we need and output them all simultaneously.</span></div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;        <span class="comment">// A translated sort declaration involves three things:</span></div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;        <span class="comment">// Declare the sort name.</span></div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;        stmts.push_back(Statement(<span class="stringliteral">&quot;sort(&quot;</span> + transSort-&gt;fullTransName() + <span class="stringliteral">&quot;).&quot;</span>,IPART_BASE));</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;        <span class="comment">// The sort&#39;s default variable and the line connecting the sort </span></div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        <span class="comment">// to its objects (if the variable reference isn&#39;t NULL).</span></div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        <span class="keywordflow">if</span>(transSort-&gt;var())</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;        {</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;            stmts.push_back(</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;                Statement(</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                        <span class="stringliteral">&quot;#domain &quot;</span> + transSort-&gt;fullTransName()</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;                        + <span class="stringliteral">&quot;(&quot;</span> + transSort-&gt;var()-&gt;fullTransName() + <span class="stringliteral">&quot;).&quot;</span>, IPART_BASE</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;                        )</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;                );</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;            stmts.push_back(</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;                Statement(</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;                        <span class="stringliteral">&quot;sort_object(&quot;</span> + transSort-&gt;fullTransName() + <span class="stringliteral">&quot;,&quot;</span></div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;                        + transSort-&gt;var()-&gt;fullTransName() + <span class="stringliteral">&quot;).&quot;</span>, IPART_BASE</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;                        )</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;                );</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;        }</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;        {</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;        }</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;        <span class="comment">// If the sort has subsorts, add lines indicating that all members of</span></div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;        <span class="comment">// the subsorts are also members of the sort.</span></div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;        <span class="keywordflow">if</span>(transSort-&gt;numSubsorts())</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;        {</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;            <span class="keywordflow">for</span> (SortList::const_iterator it = transSort-&gt;beginSubsorts(); it != transSort-&gt;endSubsorts(); it++) {</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;                <a class="code" href="classTranslator.html#a99cf4f330597ed14aa67a18fdf4df9b1">Translator::translateSubsortDecl</a>(transSort, *it);</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;            }</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;        }</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;        <span class="comment">// Additionally, we&#39;re going to hide the sort from view to prevent clutter</span></div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;        stmts.push_back(</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;            Statement(</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;                    <span class="stringliteral">&quot;#hide &quot;</span> + transSort-&gt;fullTransName() + <span class="stringliteral">&quot;(&quot;</span></div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;                    + transSort-&gt;var()-&gt;fullTransName() + <span class="stringliteral">&quot;).\n&quot;</span>, IPART_BASE</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;                    )</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;            );</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;        <span class="comment">// Output all the statements!</span></div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;        <a class="code" href="classTranslator.html#a2c7447c0464738a176c4cc5f05397dfa">outputStmts</a>(stmts);</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;    }</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_a99cf4f330597ed14aa67a18fdf4df9b1"><div class="ttname"><a href="classTranslator.html#a99cf4f330597ed14aa67a18fdf4df9b1">Translator::translateSubsortDecl</a></div><div class="ttdeci">void translateSubsortDecl(Sort const *transSupersort, Sort const *transSubsort)</div><div class="ttdoc">Translates a declaration of a super/sub-sort relationship into ASP-compatible syntax. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00708">Translator.cpp:708</a></div></div>
<div class="ttc" id="classTranslator_html_a2c7447c0464738a176c4cc5f05397dfa"><div class="ttname"><a href="classTranslator.html#a2c7447c0464738a176c4cc5f05397dfa">Translator::outputStmts</a></div><div class="ttdeci">void outputStmts(StmtList const &amp;stmts)</div><div class="ttdoc">Outputs a list of statements to the translators output. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02266">Translator.cpp:2266</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a99cf4f330597ed14aa67a18fdf4df9b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::translateSubsortDecl </td>
          <td>(</td>
          <td class="paramtype">Sort const *&#160;</td>
          <td class="paramname"><em>transSupersort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sort const *&#160;</td>
          <td class="paramname"><em>transSubsort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates a declaration of a super/sub-sort relationship into ASP-compatible syntax. </p>
<p>Assumes the sorts are declared elsewhere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transSupersort</td><td>- The "parent" sort object. </td></tr>
    <tr><td class="paramname">transSubsort</td><td>- The "child" sort object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Error if transSubsort's sortVar == NULL. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00708">708</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02260">output()</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00651">translateSortDecl()</a>.</p>
<div class="fragment"><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;{</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;    <span class="keywordflow">if</span>(transSupersort &amp;&amp; transSubsort)</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;    {</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;        <span class="keywordflow">if</span>(transSubsort-&gt;var())</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;        {</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;            <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>(</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                    transSupersort-&gt;fullTransName() + <span class="stringliteral">&quot;(&quot;</span> + transSubsort-&gt;var()-&gt;fullTransName() + <span class="stringliteral">&quot;).&quot;</span></div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;                    , IPART_BASE, true</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;                    );</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;        }</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;        {</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;        }</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;    }</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_acbb634f19ffb6d601eae8ad032d72ce9"><div class="ttname"><a href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">Translator::output</a></div><div class="ttdeci">void output(std::string const &amp;str, IPart incPart, bool endWithNewline=false)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02260">Translator.cpp:2260</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9040939e5a6702b9713daa1381da635e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::translateVariableDecl </td>
          <td>(</td>
          <td class="paramtype">Variable const *&#160;</td>
          <td class="paramname"><em>transVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates a Variable element into an ASP-compatible variable declaration. </p>
<p>Sends the result to ostOut. If the variable's sort reference is NULL, will not output anything. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transVar</td><td>- The Variable element to translate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00728">728</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02260">output()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l00213">translateVariableDeclToString()</a>.</p>
<div class="fragment"><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;{</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;    <span class="comment">// We&#39;ve got a version that already creates a string of the declaration,</span></div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    <span class="comment">// just use that and send it to output.</span></div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;    <a class="code" href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">output</a>(<a class="code" href="classTranslator.html#a3cf2e102b780108a6d66f795f6774007">Translator::translateVariableDeclToString</a>(transVar), IPART_BASE, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_a3cf2e102b780108a6d66f795f6774007"><div class="ttname"><a href="classTranslator.html#a3cf2e102b780108a6d66f795f6774007">Translator::translateVariableDeclToString</a></div><div class="ttdeci">static std::string translateVariableDeclToString(Variable const *transVar)</div><div class="ttdoc">Static version of translateVariableDecl that returns the result as a string instead of sending the re...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l00213">Translator.cpp:213</a></div></div>
<div class="ttc" id="classTranslator_html_acbb634f19ffb6d601eae8ad032d72ce9"><div class="ttname"><a href="classTranslator.html#acbb634f19ffb6d601eae8ad032d72ce9">Translator::output</a></div><div class="ttdeci">void output(std::string const &amp;str, IPart incPart, bool endWithNewline=false)</div><div class="ttdoc">Outputs the contents of str to wherever the translator&#39;s output stream is aimed. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02260">Translator.cpp:2260</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3cf2e102b780108a6d66f795f6774007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Translator::translateVariableDeclToString </td>
          <td>(</td>
          <td class="paramtype">Variable const *&#160;</td>
          <td class="paramname"><em>transVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static version of translateVariableDecl that returns the result as a string instead of sending the result to an output stream. </p>
<p>Translates a Variable element into an ASP-compatible variable declaration. If the variable's sort reference is NULL, will return a blank string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transVar</td><td>- The Variable element to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the ASP-equivalent variable declaration, or a blank string ("") on an error. </dd></dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l00213">213</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00728">translateVariableDecl()</a>.</p>
<div class="fragment"><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;{</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    std::ostringstream retStream;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    <span class="comment">// Sanity check: make sure the variable isn&#39;t NULL and neither is its sort.</span></div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    <span class="keywordflow">if</span>(transVar &amp;&amp; transVar-&gt;domain())</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    {</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="comment">// Variable declarations are just domain variable declarations.</span></div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        retStream &lt;&lt; <span class="stringliteral">&quot;#domain &quot;</span> &lt;&lt; transVar-&gt;domain()-&gt;fullTransName() &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        retStream &lt;&lt; transVar-&gt;fullTransName() &lt;&lt; <span class="stringliteral">&quot;).&quot;</span>;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    }</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="keywordflow">return</span> retStream.str();</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa07bcca529cd19ad8602fb4ec5ec16d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Translator::warn </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endWithNewline</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>location</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs the contents of str to wherever the translator's error output stream is aimed. </p>
<p>Mirrors output to the standard output stream as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- The text to output. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="old_2Translator_8cpp_source.html#l02083">2083</a> of file <a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a>.</p>

<p>References <a class="el" href="old_2Translator_8cpp_source.html#l02101">outputToErr()</a>, and <a class="el" href="old_2Translator_8h_source.html#l00092">translatorNumWarnings</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l00400">addSort()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00496">translateConstantDecl()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01511">translateConstraintLaw()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l01679">translateMayCauseLaw()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l01605">translateNonexecutableLaw()</a>.</p>
<div class="fragment"><div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;{</div>
<div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;    <a class="code" href="classTranslator.html#a8a88e8bc81269b07f6ce7a7b31aea94d">outputToErr</a>(<span class="stringliteral">&quot;% Warning&quot;</span>,str,endWithNewline,location);</div>
<div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;    this-&gt;<a class="code" href="classTranslator.html#ab9dc79c758ae00960cdcf22ae8eebcf2">translatorNumWarnings</a>++;</div>
<div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;}</div>
<div class="ttc" id="classTranslator_html_ab9dc79c758ae00960cdcf22ae8eebcf2"><div class="ttname"><a href="classTranslator.html#ab9dc79c758ae00960cdcf22ae8eebcf2">Translator::translatorNumWarnings</a></div><div class="ttdeci">int translatorNumWarnings</div><div class="ttdoc">Tracks how many warnings the translator module encounters during operation. </div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8h_source.html#l00092">Translator.h:92</a></div></div>
<div class="ttc" id="classTranslator_html_a8a88e8bc81269b07f6ce7a7b31aea94d"><div class="ttname"><a href="classTranslator.html#a8a88e8bc81269b07f6ce7a7b31aea94d">Translator::outputToErr</a></div><div class="ttdeci">void outputToErr(std::string const &amp;hdr, std::string const &amp;str, bool endWithNewline, bool location)</div><div class="ttdoc">Outputs the contents of hdr followed by str to wherever the translator&#39;s error output stream is aimed...</div><div class="ttdef"><b>Definition:</b> <a href="old_2Translator_8cpp_source.html#l02101">Translator.cpp:2101</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa75abc327fac9fd6890fe20b76a0331b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Query* Translator::tempQuery</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helps the parser process and prepare queries for translation. </p>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00093">93</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l02017">allocateNewTempQuery()</a>, <a class="el" href="old_2Translator_8cpp_source.html#l00270">Translator()</a>, and <a class="el" href="old_2Translator_8cpp_source.html#l02201">~Translator()</a>.</p>

</div>
</div>
<a class="anchor" id="a237353d1182e41e51c3c3c99b66f2e63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Translator::translatorNumErrors</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracks how many errors the translator module encounters while translating things. </p>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00091">91</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l02076">error()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9dc79c758ae00960cdcf22ae8eebcf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Translator::translatorNumWarnings</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracks how many warnings the translator module encounters during operation. </p>

<p>Definition at line <a class="el" href="old_2Translator_8h_source.html#l00092">92</a> of file <a class="el" href="old_2Translator_8h_source.html">Translator.h</a>.</p>

<p>Referenced by <a class="el" href="old_2Translator_8cpp_source.html#l02083">warn()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cplus2asp.bin/old/<a class="el" href="old_2Translator_8h_source.html">Translator.h</a></li>
<li>cplus2asp.bin/old/<a class="el" href="old_2Translator_8cpp_source.html">Translator.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classTranslator.html">Translator</a></li>
    <li class="footer">Generated on Fri Aug 29 2014 17:51:12 for cplus2asp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
